// Code generated by goctl. DO NOT EDIT.
// versions:
//  goctl version: 1.7.1

package model

import (
	"context"
	"database/sql"
	"strings"
	"time"

	"github.com/Masterminds/squirrel"
	"github.com/pkg/errors"
	"github.com/zeromicro/go-zero/core/stores/builder"
	"github.com/zeromicro/go-zero/core/stores/sqlx"
)

var _ planBatchModel = (*defaultPlanBatchModel)(nil)

type (
	planBatchModel interface {
		Insert(ctx context.Context, session sqlx.Session, data *PlanBatch) (sql.Result, error)
		FindOne(ctx context.Context, id int64) (*PlanBatch, error)
		FindOneByBatchId(ctx context.Context, batchId string) (*PlanBatch, error)
		Update(ctx context.Context, session sqlx.Session, data *PlanBatch) (sql.Result, error)
		UpdateWithVersion(ctx context.Context, session sqlx.Session, data *PlanBatch) error
		Trans(ctx context.Context, fn func(ctx context.Context, session sqlx.Session) error) error
		ExecCtx(ctx context.Context, session sqlx.Session, query string, args ...any) (sql.Result, error)
		SelectWithBuilder(ctx context.Context, builder squirrel.SelectBuilder) ([]*PlanBatch, error)
		SelectOneWithBuilder(ctx context.Context, builder squirrel.SelectBuilder) (*PlanBatch, error)
		InsertWithBuilder(ctx context.Context, session sqlx.Session, builder squirrel.InsertBuilder) (sql.Result, error)
		UpdateWithBuilder(ctx context.Context, session sqlx.Session, builder squirrel.UpdateBuilder) (sql.Result, error)
		DeleteWithBuilder(ctx context.Context, session sqlx.Session, builder squirrel.DeleteBuilder) (sql.Result, error)
		SelectBuilder() squirrel.SelectBuilder
		InsertBuilder() squirrel.InsertBuilder
		UpdateBuilder() squirrel.UpdateBuilder
		DeleteBuilder() squirrel.DeleteBuilder
		DeleteSoft(ctx context.Context, session sqlx.Session, id int64) error
		FindSum(ctx context.Context, sumBuilder squirrel.SelectBuilder, field string) (float64, error)
		FindCount(ctx context.Context, countBuilder squirrel.SelectBuilder, field string) (int64, error)
		FindAll(ctx context.Context, rowBuilder squirrel.SelectBuilder, orderBy ...string) ([]*PlanBatch, error)
		FindPageListByPage(ctx context.Context, rowBuilder squirrel.SelectBuilder, page, pageSize int64, orderBy ...string) ([]*PlanBatch, error)
		FindPageListByPageWithTotal(ctx context.Context, rowBuilder squirrel.SelectBuilder, page, pageSize int64, orderBy ...string) ([]*PlanBatch, int64, error)
		FindPageListByIdDESC(ctx context.Context, rowBuilder squirrel.SelectBuilder, preMinId, pageSize int64) ([]*PlanBatch, error)
		FindPageListByIdASC(ctx context.Context, rowBuilder squirrel.SelectBuilder, preMaxId, pageSize int64) ([]*PlanBatch, error)
		Delete(ctx context.Context, session sqlx.Session, id int64) error
	}

	defaultPlanBatchModel struct {
		conn          sqlx.SqlConn
		table         string
		dbType        DatabaseType
		planBatchRows string
	}

	PlanBatch struct {
		Id               int64          `db:"id"`                // 自增主键ID
		CreateTime       time.Time      `db:"create_time"`       // 创建时间
		UpdateTime       time.Time      `db:"update_time"`       // 更新时间
		DeleteTime       sql.NullTime   `db:"delete_time"`       // 删除时间（软删除标记）
		DelState         int64          `db:"del_state"`         // 删除状态：0-未删除，1-已删除
		Version          int64          `db:"version"`           // 版本号（乐观锁）
		CreateUser       sql.NullString `db:"create_user"`       // 创建人
		UpdateUser       sql.NullString `db:"update_user"`       // 更新人
		DeptCode         sql.NullString `db:"dept_code"`         // 机构code
		PlanPk           int64          `db:"plan_pk"`           // 关联的计划主键ID
		PlanId           string         `db:"plan_id"`           // 关联的计划ID
		BatchId          string         `db:"batch_id"`          // 批ID
		BatchName        sql.NullString `db:"batch_name"`        // 批次名称
		Status           int64          `db:"status"`            // 状态：0-禁用，1-启用，2-暂停，3-终止
		PlanTriggerTime  sql.NullTime   `db:"plan_trigger_time"` // 计划触发时间
		TerminatedReason sql.NullString `db:"terminated_reason"` // 终止原因
		PausedTime       sql.NullTime   `db:"paused_time"`       // 暂停时间
		PausedReason     sql.NullString `db:"paused_reason"`     // 暂停原因
		FinishedTime     sql.NullTime   `db:"finished_time"`     // 结束时间
		Ext1             sql.NullString `db:"ext_1"`             // 扩展字段1
		Ext2             sql.NullString `db:"ext_2"`             // 扩展字段2
		Ext3             sql.NullString `db:"ext_3"`             // 扩展字段3
		Ext4             sql.NullString `db:"ext_4"`             // 扩展字段4
		Ext5             sql.NullString `db:"ext_5"`             // 扩展字段5
	}
)

func newPlanBatchModel(conn sqlx.SqlConn) *defaultPlanBatchModel {
	return newPlanBatchModelWithDBType(conn, DatabaseTypeMySQL)
}

func newPlanBatchModelWithDBType(conn sqlx.SqlConn, dbType DatabaseType) *defaultPlanBatchModel {
	tableName := "plan_batch"
	fieldNames := builder.RawFieldNames(&PlanBatch{}, true)
	rows := strings.Join(fieldNames, ",")
	return &defaultPlanBatchModel{
		conn:          conn,
		table:         tableName,
		dbType:        dbType,
		planBatchRows: rows,
	}
}

func (m *defaultPlanBatchModel) Delete(ctx context.Context, session sqlx.Session, id int64) error {
	deleteBuilder := m.DeleteBuilder().Where("id = ?", id)
	query, args, err := deleteBuilder.ToSql()
	if err != nil {
		return err
	}
	var execErr error
	if session != nil {
		_, execErr = session.ExecCtx(ctx, query, args...)
	} else {
		_, execErr = m.conn.ExecCtx(ctx, query, args...)
	}
	return execErr
}

func (m *defaultPlanBatchModel) FindOne(ctx context.Context, id int64) (*PlanBatch, error) {
	selectBuilder := m.SelectBuilder().Columns(m.planBatchRows).
		Where("id = ?", id).
		Where("del_state = ?", 0).
		Limit(1)
	query, args, err := selectBuilder.ToSql()
	if err != nil {
		return nil, err
	}
	var resp PlanBatch
	err = m.conn.QueryRowCtx(ctx, &resp, query, args...)
	switch err {
	case nil:
		return &resp, nil
	case sqlx.ErrNotFound:
		return nil, ErrNotFound
	default:
		return nil, err
	}
}

func (m *defaultPlanBatchModel) FindOneByBatchId(ctx context.Context, batchId string) (*PlanBatch, error) {
	selectBuilder := m.SelectBuilder().Columns(m.planBatchRows).
		Where("batch_id = ?", batchId).
		Where("del_state = ?", 0).
		Limit(1)
	query, args, err := selectBuilder.ToSql()
	if err != nil {
		return nil, err
	}
	var resp PlanBatch
	err = m.conn.QueryRowCtx(ctx, &resp, query, args...)
	switch err {
	case nil:
		return &resp, nil
	case sqlx.ErrNotFound:
		return nil, ErrNotFound
	default:
		return nil, err
	}
}

func (m *defaultPlanBatchModel) Insert(ctx context.Context, session sqlx.Session, data *PlanBatch) (sql.Result, error) {
	data.DeleteTime = sql.NullTime{
		Valid: false,
	}
	data.DelState = 0
	columns, values := generateColumnsAndValues(data, []string{})
	insertBuilder := m.InsertBuilder().Columns(columns...).Values(values...)

	if m.dbType == DatabaseTypePostgres {
		insertBuilder = insertBuilder.Suffix("RETURNING id")
		query, args, err := insertBuilder.ToSql()
		if err != nil {
			return nil, err
		}
		var id int64
		var execErr error
		if session != nil {
			execErr = session.QueryRowCtx(ctx, &id, query, args...)
		} else {
			execErr = m.conn.QueryRowCtx(ctx, &id, query, args...)
		}
		if execErr != nil {
			return nil, execErr
		}
		data.Id = id
		return &postgresResult{id: id}, nil
	} else {
		query, args, err := insertBuilder.ToSql()
		if err != nil {
			return nil, err
		}
		var result sql.Result
		var execErr error
		if session != nil {
			result, execErr = session.ExecCtx(ctx, query, args...)
		} else {
			result, execErr = m.conn.ExecCtx(ctx, query, args...)
		}
		return result, execErr
	}
}

func (m *defaultPlanBatchModel) Update(ctx context.Context, session sqlx.Session, newData *PlanBatch) (sql.Result, error) {
	newData.DeleteTime = sql.NullTime{
		Valid: false,
	}
	newData.DelState = 0
	columns, values := generateColumnsAndValues(newData, []string{})
	updateBuilder := m.UpdateBuilder()
	for i, column := range columns {
		updateBuilder = updateBuilder.Set(column, values[i])
	}
	updateBuilder = updateBuilder.Where("id = ?", newData.Id)
	query, args, err := updateBuilder.ToSql()
	if err != nil {
		return nil, err
	}
	var result sql.Result
	var execErr error
	if session != nil {
		result, execErr = session.ExecCtx(ctx, query, args...)
	} else {
		result, execErr = m.conn.ExecCtx(ctx, query, args...)
	}
	return result, execErr
}

func (m *defaultPlanBatchModel) UpdateWithVersion(ctx context.Context, session sqlx.Session, newData *PlanBatch) error {
	oldVersion := newData.Version
	newData.Version += 1
	newData.DeleteTime = sql.NullTime{
		Valid: false,
	}
	newData.DelState = 0
	columns, values := generateColumnsAndValues(newData, []string{})
	updateBuilder := m.UpdateBuilder()
	for i, column := range columns {
		updateBuilder = updateBuilder.Set(column, values[i])
	}
	updateBuilder = updateBuilder.Where("id = ?", newData.Id).Where("version = ?", oldVersion)
	query, args, err := updateBuilder.ToSql()
	if err != nil {
		return err
	}
	var sqlResult sql.Result
	var execErr error
	if session != nil {
		sqlResult, execErr = session.ExecCtx(ctx, query, args...)
	} else {
		sqlResult, execErr = m.conn.ExecCtx(ctx, query, args...)
	}
	if execErr != nil {
		return execErr
	}
	updateCount, err := sqlResult.RowsAffected()
	if err != nil {
		return err
	}
	if updateCount == 0 {
		return ErrNoRowsUpdate
	}
	return nil
}

func (m *defaultPlanBatchModel) DeleteSoft(ctx context.Context, session sqlx.Session, id int64) error {
	data, err := m.FindOne(ctx, id)
	if err != nil {
		return err
	}
	data.DelState = 1
	data.DeleteTime = sql.NullTime{
		Time:  time.Now(),
		Valid: true,
	}
	if err := m.UpdateWithVersion(ctx, session, data); err != nil {
		return errors.Wrapf(errors.New("delete soft failed "), "PlanBatchModel delete err : %+v", err)
	}
	return nil
}

func (m *defaultPlanBatchModel) FindSum(ctx context.Context, builder squirrel.SelectBuilder, field string) (float64, error) {
	if len(field) == 0 {
		return 0, errors.Wrapf(errors.New("FindSum Least One Field"), "FindSum Least One Field")
	}
	sumFunction := "COALESCE(SUM(" + field + "),0)"
	builder = builder.Columns(sumFunction)
	query, values, err := builder.Where("del_state = ?", 0).ToSql()
	if err != nil {
		return 0, err
	}
	var resp float64
	err = m.conn.QueryRowCtx(ctx, &resp, query, values...)
	switch err {
	case nil:
		return resp, nil
	default:
		return 0, err
	}
}

func (m *defaultPlanBatchModel) FindCount(ctx context.Context, builder squirrel.SelectBuilder, field string) (int64, error) {
	if len(field) == 0 {
		return 0, errors.Wrapf(errors.New("FindCount Least One Field"), "FindCount Least One Field")
	}

	builder = builder.Columns("COUNT(" + field + ")")

	query, values, err := builder.Where("del_state = ?", 0).ToSql()
	if err != nil {
		return 0, err
	}

	var resp int64
	err = m.conn.QueryRowCtx(ctx, &resp, query, values...)
	switch err {
	case nil:
		return resp, nil
	default:
		return 0, err
	}
}

func (m *defaultPlanBatchModel) FindAll(ctx context.Context, builder squirrel.SelectBuilder, orderBy ...string) ([]*PlanBatch, error) {
	builder = builder.Columns(m.planBatchRows)

	if len(orderBy) == 0 {
		builder = builder.OrderBy("id DESC")
	} else {
		builder = builder.OrderBy(orderBy...)
	}

	query, values, err := builder.Where("del_state = ?", 0).ToSql()
	if err != nil {
		return nil, err
	}

	var resp []*PlanBatch
	err = m.conn.QueryRowsCtx(ctx, &resp, query, values...)
	switch err {
	case nil:
		return resp, nil
	default:
		return nil, err
	}
}

func (m *defaultPlanBatchModel) FindPageListByPage(ctx context.Context, builder squirrel.SelectBuilder, page, pageSize int64, orderBy ...string) ([]*PlanBatch, error) {
	builder = builder.Columns(m.planBatchRows)

	if len(orderBy) == 0 {
		builder = builder.OrderBy("id DESC")
	} else {
		builder = builder.OrderBy(orderBy...)
	}

	if page < 1 {
		page = 1
	}
	offset := (page - 1) * pageSize

	query, values, err := builder.Where("del_state = ?", 0).Offset(uint64(offset)).Limit(uint64(pageSize)).ToSql()
	if err != nil {
		return nil, err
	}

	var resp []*PlanBatch
	err = m.conn.QueryRowsCtx(ctx, &resp, query, values...)
	switch err {
	case nil:
		return resp, nil
	default:
		return nil, err
	}
}

func (m *defaultPlanBatchModel) FindPageListByPageWithTotal(ctx context.Context, builder squirrel.SelectBuilder, page, pageSize int64, orderBy ...string) ([]*PlanBatch, int64, error) {
	total, err := m.FindCount(ctx, builder, "id")
	if err != nil {
		return nil, 0, err
	}

	builder = builder.Columns(m.planBatchRows)

	if len(orderBy) == 0 {
		builder = builder.OrderBy("id DESC")
	} else {
		builder = builder.OrderBy(orderBy...)
	}

	if page < 1 {
		page = 1
	}
	offset := (page - 1) * pageSize

	query, values, err := builder.Where("del_state = ?", 0).Offset(uint64(offset)).Limit(uint64(pageSize)).ToSql()
	if err != nil {
		return nil, total, err
	}

	var resp []*PlanBatch
	err = m.conn.QueryRowsCtx(ctx, &resp, query, values...)
	switch err {
	case nil:
		return resp, total, nil
	default:
		return nil, total, err
	}
}

func (m *defaultPlanBatchModel) FindPageListByIdDESC(ctx context.Context, builder squirrel.SelectBuilder, preMinId, pageSize int64) ([]*PlanBatch, error) {
	builder = builder.Columns(m.planBatchRows)

	if preMinId > 0 {
		builder = builder.Where("id < ?", preMinId)
	}

	query, values, err := builder.Where("del_state = ?", 0).OrderBy("id DESC").Limit(uint64(pageSize)).ToSql()
	if err != nil {
		return nil, err
	}

	var resp []*PlanBatch
	err = m.conn.QueryRowsCtx(ctx, &resp, query, values...)
	switch err {
	case nil:
		return resp, nil
	default:
		return nil, err
	}
}

func (m *defaultPlanBatchModel) FindPageListByIdASC(ctx context.Context, builder squirrel.SelectBuilder, preMaxId, pageSize int64) ([]*PlanBatch, error) {
	builder = builder.Columns(m.planBatchRows)

	if preMaxId > 0 {
		builder = builder.Where("id > ?", preMaxId)
	}

	query, values, err := builder.Where("del_state = ?", 0).OrderBy("id ASC").Limit(uint64(pageSize)).ToSql()
	if err != nil {
		return nil, err
	}

	var resp []*PlanBatch
	err = m.conn.QueryRowsCtx(ctx, &resp, query, values...)
	switch err {
	case nil:
		return resp, nil
	default:
		return nil, err
	}
}

func (m *defaultPlanBatchModel) Trans(ctx context.Context, fn func(ctx context.Context, session sqlx.Session) error) error {
	return m.conn.TransactCtx(ctx, func(ctx context.Context, session sqlx.Session) error {
		return fn(ctx, session)
	})
}

func (m *defaultPlanBatchModel) ExecCtx(ctx context.Context, session sqlx.Session, query string, args ...any) (sql.Result, error) {
	if session != nil {
		return session.ExecCtx(ctx, query, args...)
	}
	return m.conn.ExecCtx(ctx, query, args...)
}

func (m *defaultPlanBatchModel) SelectWithBuilder(ctx context.Context, builder squirrel.SelectBuilder) ([]*PlanBatch, error) {
	query, args, err := builder.ToSql()
	if err != nil {
		return nil, err
	}

	var resp []*PlanBatch
	err = m.conn.QueryRowsPartialCtx(ctx, &resp, query, args...)
	switch err {
	case nil:
		return resp, nil
	default:
		return nil, err
	}
}

func (m *defaultPlanBatchModel) SelectOneWithBuilder(ctx context.Context, builder squirrel.SelectBuilder) (*PlanBatch, error) {
	query, args, err := builder.ToSql()
	if err != nil {
		return nil, err
	}

	var resp PlanBatch
	err = m.conn.QueryRowPartialCtx(ctx, &resp, query, args...)
	switch err {
	case nil:
		return &resp, nil
	case sqlx.ErrNotFound:
		return nil, ErrNotFound
	default:
		return nil, err
	}
}

func (m *defaultPlanBatchModel) InsertWithBuilder(ctx context.Context, session sqlx.Session, builder squirrel.InsertBuilder) (sql.Result, error) {
	query, args, err := builder.ToSql()
	if err != nil {
		return nil, err
	}
	return m.ExecCtx(ctx, session, query, args...)
}

func (m *defaultPlanBatchModel) UpdateWithBuilder(ctx context.Context, session sqlx.Session, builder squirrel.UpdateBuilder) (sql.Result, error) {
	query, args, err := builder.ToSql()
	if err != nil {
		return nil, err
	}
	return m.ExecCtx(ctx, session, query, args...)
}

func (m *defaultPlanBatchModel) DeleteWithBuilder(ctx context.Context, session sqlx.Session, builder squirrel.DeleteBuilder) (sql.Result, error) {
	query, args, err := builder.ToSql()
	if err != nil {
		return nil, err
	}
	return m.ExecCtx(ctx, session, query, args...)
}

func (m *defaultPlanBatchModel) SelectBuilder() squirrel.SelectBuilder {
	builder := squirrel.Select().From(m.table)
	if m.dbType == DatabaseTypePostgres {
		builder = builder.PlaceholderFormat(squirrel.Dollar)
	}
	return builder
}

func (m *defaultPlanBatchModel) UpdateBuilder() squirrel.UpdateBuilder {
	builder := squirrel.Update(m.table)
	if m.dbType == DatabaseTypePostgres {
		builder = builder.PlaceholderFormat(squirrel.Dollar)
	}
	return builder
}

func (m *defaultPlanBatchModel) DeleteBuilder() squirrel.DeleteBuilder {
	builder := squirrel.Delete(m.table)
	if m.dbType == DatabaseTypePostgres {
		builder = builder.PlaceholderFormat(squirrel.Dollar)
	}
	return builder
}

func (m *defaultPlanBatchModel) InsertBuilder() squirrel.InsertBuilder {
	builder := squirrel.Insert(m.table)
	if m.dbType == DatabaseTypePostgres {
		builder = builder.PlaceholderFormat(squirrel.Dollar)
	}
	return builder
}

func (m *defaultPlanBatchModel) tableName() string {
	return m.table
}
