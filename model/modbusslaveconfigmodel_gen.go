// Code generated by goctl. DO NOT EDIT.
// versions:
//  goctl version: 1.7.1

package model

import (
	"context"
	"database/sql"
	"fmt"
	"strings"
	"time"

	"github.com/Masterminds/squirrel"
	"github.com/pkg/errors"
	"github.com/zeromicro/go-zero/core/stores/builder"
	"github.com/zeromicro/go-zero/core/stores/sqlx"
	"github.com/zeromicro/go-zero/core/stringx"
)

var (
	modbusSlaveConfigFieldNames          = builder.RawFieldNames(&ModbusSlaveConfig{})
	modbusSlaveConfigRows                = strings.Join(modbusSlaveConfigFieldNames, ",")
	modbusSlaveConfigRowsExpectAutoSet   = strings.Join(stringx.Remove(modbusSlaveConfigFieldNames, "`id`", "`create_at`", "`create_time`", "`created_at`", "`update_at`", "`update_time`", "`updated_at`"), ",")
	modbusSlaveConfigRowsWithPlaceHolder = strings.Join(stringx.Remove(modbusSlaveConfigFieldNames, "`id`", "`create_at`", "`create_time`", "`created_at`", "`update_at`", "`update_time`", "`updated_at`"), "=?,") + "=?"
)

type (
	modbusSlaveConfigModel interface {
		Insert(ctx context.Context, session sqlx.Session, data *ModbusSlaveConfig) (sql.Result, error)
		FindOne(ctx context.Context, id int64) (*ModbusSlaveConfig, error)
		FindOneByModbusCode(ctx context.Context, modbusCode string) (*ModbusSlaveConfig, error)
		Update(ctx context.Context, session sqlx.Session, data *ModbusSlaveConfig) (sql.Result, error)
		UpdateWithVersion(ctx context.Context, session sqlx.Session, data *ModbusSlaveConfig) error
		Trans(ctx context.Context, fn func(context context.Context, session sqlx.Session) error) error
		ExecCtx(ctx context.Context, session sqlx.Session, query string, args ...any) (sql.Result, error)
		SelectBuilder() squirrel.SelectBuilder
		InsertBuilder() squirrel.InsertBuilder
		UpdateBuilder() squirrel.UpdateBuilder
		DeleteBuilder() squirrel.DeleteBuilder
		DeleteSoft(ctx context.Context, session sqlx.Session, id int64) error
		FindSum(ctx context.Context, sumBuilder squirrel.SelectBuilder, field string) (float64, error)
		FindCount(ctx context.Context, countBuilder squirrel.SelectBuilder, field string) (int64, error)
		FindAll(ctx context.Context, rowBuilder squirrel.SelectBuilder, orderBy ...string) ([]*ModbusSlaveConfig, error)
		FindPageListByPage(ctx context.Context, rowBuilder squirrel.SelectBuilder, page, pageSize int64, orderBy ...string) ([]*ModbusSlaveConfig, error)
		FindPageListByPageWithTotal(ctx context.Context, rowBuilder squirrel.SelectBuilder, page, pageSize int64, orderBy ...string) ([]*ModbusSlaveConfig, int64, error)
		FindPageListByIdDESC(ctx context.Context, rowBuilder squirrel.SelectBuilder, preMinId, pageSize int64) ([]*ModbusSlaveConfig, error)
		FindPageListByIdASC(ctx context.Context, rowBuilder squirrel.SelectBuilder, preMaxId, pageSize int64) ([]*ModbusSlaveConfig, error)
		Delete(ctx context.Context, session sqlx.Session, id int64) error
	}

	defaultModbusSlaveConfigModel struct {
		conn  sqlx.SqlConn
		table string
	}

	ModbusSlaveConfig struct {
		Id                      int64     `db:"id"`                        // 主键ID
		CreateTime              time.Time `db:"create_time"`               // 创建时间
		UpdateTime              time.Time `db:"update_time"`               // 更新时间
		DeleteTime              time.Time `db:"delete_time"`               // 删除时间（软删除标记）
		DelState                int64     `db:"del_state"`                 // 删除状态：0-未删除，1-已删除
		Version                 int64     `db:"version"`                   // 版本号（乐观锁，防并发修改）
		ModbusCode              string    `db:"modbus_code"`               // Modbus配置唯一编码（如：modbus-192.168.1.100）
		SlaveAddress            string    `db:"slave_address"`             // TCP设备地址（格式：IP:Port，对应结构体 Address）
		Slave                   int64     `db:"slave"`                     // Modbus从站地址（Slave ID/Unit ID，对应结构体 Slave）
		Timeout                 int64     `db:"timeout"`                   // 发送/接收超时（单位：毫秒，对应结构体 Timeout，默认10000）
		IdleTimeout             int64     `db:"idle_timeout"`              // 空闲连接自动关闭时间（单位：毫秒，对应结构体 IdleTimeout，默认60000）
		LinkRecoveryTimeout     int64     `db:"link_recovery_timeout"`     // TCP连接出错重连间隔（单位：毫秒，对应结构体 LinkRecoveryTimeout，默认3000）
		ProtocolRecoveryTimeout int64     `db:"protocol_recovery_timeout"` // 协议异常重试间隔（单位：毫秒，对应结构体 ProtocolRecoveryTimeout，默认2000）
		ConnectDelay            int64     `db:"connect_delay"`             // 连接建立后等待时间（单位：毫秒，对应结构体 ConnectDelay，默认100）
		EnableTls               int64     `db:"enable_tls"`                // 是否启用TLS（对应结构体 TLS.Enable：0-不启用，1-启用）
		TlsCertFile             string    `db:"tls_cert_file"`             // TLS客户端证书路径（对应结构体 TLS.CertFile，enable_tls=1时生效）
		TlsKeyFile              string    `db:"tls_key_file"`              // TLS客户端密钥路径（对应结构体 TLS.KeyFile，enable_tls=1时生效）
		TlsCaFile               string    `db:"tls_ca_file"`               // TLS根证书路径（对应结构体 TLS.CAFile，enable_tls=1时生效）
		Status                  int64     `db:"status"`                    // 配置状态：1-启用（可初始化连接池），2-禁用（不加载）
		Remark                  string    `db:"remark"`                    // 备注（如：生产车间A-水泵控制从站）
	}
)

func newModbusSlaveConfigModel(conn sqlx.SqlConn) *defaultModbusSlaveConfigModel {
	return &defaultModbusSlaveConfigModel{
		conn:  conn,
		table: "`modbus_slave_config`",
	}
}

func (m *defaultModbusSlaveConfigModel) Delete(ctx context.Context, session sqlx.Session, id int64) error {
	query := fmt.Sprintf("delete from %s where `id` = ?", m.table)
	if session != nil {
		_, err := session.ExecCtx(ctx, query, id)
		return err
	}
	_, err := m.conn.ExecCtx(ctx, query, id)
	return err
}
func (m *defaultModbusSlaveConfigModel) FindOne(ctx context.Context, id int64) (*ModbusSlaveConfig, error) {
	query := fmt.Sprintf("select %s from %s where `id` = ? and del_state = ? limit 1", modbusSlaveConfigRows, m.table)
	var resp ModbusSlaveConfig
	err := m.conn.QueryRowCtx(ctx, &resp, query, id, 0)
	switch err {
	case nil:
		return &resp, nil
	case sqlx.ErrNotFound:
		return nil, ErrNotFound
	default:
		return nil, err
	}
}

func (m *defaultModbusSlaveConfigModel) FindOneByModbusCode(ctx context.Context, modbusCode string) (*ModbusSlaveConfig, error) {
	var resp ModbusSlaveConfig
	query := fmt.Sprintf("select %s from %s where `modbus_code` = ?  and del_state = ? limit 1", modbusSlaveConfigRows, m.table)
	err := m.conn.QueryRowCtx(ctx, &resp, query, modbusCode, 0)
	switch err {
	case nil:
		return &resp, nil
	case sqlx.ErrNotFound:
		return nil, ErrNotFound
	default:
		return nil, err
	}
}

func (m *defaultModbusSlaveConfigModel) Insert(ctx context.Context, session sqlx.Session, data *ModbusSlaveConfig) (sql.Result, error) {
	data.DeleteTime = time.Unix(0, 0)
	data.DelState = 0

	query := fmt.Sprintf("insert into %s (%s) values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)", m.table, modbusSlaveConfigRowsExpectAutoSet)
	if session != nil {
		return session.ExecCtx(ctx, query, data.DeleteTime, data.DelState, data.Version, data.ModbusCode, data.SlaveAddress, data.Slave, data.Timeout, data.IdleTimeout, data.LinkRecoveryTimeout, data.ProtocolRecoveryTimeout, data.ConnectDelay, data.EnableTls, data.TlsCertFile, data.TlsKeyFile, data.TlsCaFile, data.Status, data.Remark)
	}
	return m.conn.ExecCtx(ctx, query, data.DeleteTime, data.DelState, data.Version, data.ModbusCode, data.SlaveAddress, data.Slave, data.Timeout, data.IdleTimeout, data.LinkRecoveryTimeout, data.ProtocolRecoveryTimeout, data.ConnectDelay, data.EnableTls, data.TlsCertFile, data.TlsKeyFile, data.TlsCaFile, data.Status, data.Remark)
}

func (m *defaultModbusSlaveConfigModel) Update(ctx context.Context, session sqlx.Session, newData *ModbusSlaveConfig) (sql.Result, error) {
	newData.DeleteTime = time.Unix(0, 0)
	newData.DelState = 0
	query := fmt.Sprintf("update %s set %s where `id` = ?", m.table, modbusSlaveConfigRowsWithPlaceHolder)
	if session != nil {
		return session.ExecCtx(ctx, query, newData.DeleteTime, newData.DelState, newData.Version, newData.ModbusCode, newData.SlaveAddress, newData.Slave, newData.Timeout, newData.IdleTimeout, newData.LinkRecoveryTimeout, newData.ProtocolRecoveryTimeout, newData.ConnectDelay, newData.EnableTls, newData.TlsCertFile, newData.TlsKeyFile, newData.TlsCaFile, newData.Status, newData.Remark, newData.Id)
	}
	return m.conn.ExecCtx(ctx, query, newData.DeleteTime, newData.DelState, newData.Version, newData.ModbusCode, newData.SlaveAddress, newData.Slave, newData.Timeout, newData.IdleTimeout, newData.LinkRecoveryTimeout, newData.ProtocolRecoveryTimeout, newData.ConnectDelay, newData.EnableTls, newData.TlsCertFile, newData.TlsKeyFile, newData.TlsCaFile, newData.Status, newData.Remark, newData.Id)
}

func (m *defaultModbusSlaveConfigModel) UpdateWithVersion(ctx context.Context, session sqlx.Session, newData *ModbusSlaveConfig) error {

	oldVersion := newData.Version
	newData.Version += 1

	var sqlResult sql.Result
	var err error

	query := fmt.Sprintf("update %s set %s where `id` = ? and version = ? ", m.table, modbusSlaveConfigRowsWithPlaceHolder)
	if session != nil {
		sqlResult, err = session.ExecCtx(ctx, query, newData.DeleteTime, newData.DelState, newData.Version, newData.ModbusCode, newData.SlaveAddress, newData.Slave, newData.Timeout, newData.IdleTimeout, newData.LinkRecoveryTimeout, newData.ProtocolRecoveryTimeout, newData.ConnectDelay, newData.EnableTls, newData.TlsCertFile, newData.TlsKeyFile, newData.TlsCaFile, newData.Status, newData.Remark, newData.Id, oldVersion)
	} else {
		sqlResult, err = m.conn.ExecCtx(ctx, query, newData.DeleteTime, newData.DelState, newData.Version, newData.ModbusCode, newData.SlaveAddress, newData.Slave, newData.Timeout, newData.IdleTimeout, newData.LinkRecoveryTimeout, newData.ProtocolRecoveryTimeout, newData.ConnectDelay, newData.EnableTls, newData.TlsCertFile, newData.TlsKeyFile, newData.TlsCaFile, newData.Status, newData.Remark, newData.Id, oldVersion)
	}

	if err != nil {
		return err
	}
	updateCount, err := sqlResult.RowsAffected()
	if err != nil {
		return err
	}
	if updateCount == 0 {
		return ErrNoRowsUpdate
	}

	return nil
}

func (m *defaultModbusSlaveConfigModel) DeleteSoft(ctx context.Context, session sqlx.Session, id int64) error {
	data, err := m.FindOne(ctx, id)
	if err != nil {
		return err
	}
	data.DelState = 1
	data.DeleteTime = time.Now()
	if err := m.UpdateWithVersion(ctx, session, data); err != nil {
		return errors.Wrapf(errors.New("delete soft failed "), "ModbusSlaveConfigModel delete err : %+v", err)
	}
	return nil
}

func (m *defaultModbusSlaveConfigModel) FindSum(ctx context.Context, builder squirrel.SelectBuilder, field string) (float64, error) {

	if len(field) == 0 {
		return 0, errors.Wrapf(errors.New("FindSum Least One Field"), "FindSum Least One Field")
	}

	builder = builder.Columns("IFNULL(SUM(" + field + "),0)")

	query, values, err := builder.Where("del_state = ?", 0).ToSql()
	if err != nil {
		return 0, err
	}

	var resp float64

	err = m.conn.QueryRowCtx(ctx, &resp, query, values...)

	switch err {
	case nil:
		return resp, nil
	default:
		return 0, err
	}
}

func (m *defaultModbusSlaveConfigModel) FindCount(ctx context.Context, builder squirrel.SelectBuilder, field string) (int64, error) {

	if len(field) == 0 {
		return 0, errors.Wrapf(errors.New("FindCount Least One Field"), "FindCount Least One Field")
	}

	builder = builder.Columns("COUNT(" + field + ")")

	query, values, err := builder.Where("del_state = ?", 0).ToSql()
	if err != nil {
		return 0, err
	}

	var resp int64

	err = m.conn.QueryRowCtx(ctx, &resp, query, values...)

	switch err {
	case nil:
		return resp, nil
	default:
		return 0, err
	}
}

func (m *defaultModbusSlaveConfigModel) FindAll(ctx context.Context, builder squirrel.SelectBuilder, orderBy ...string) ([]*ModbusSlaveConfig, error) {

	builder = builder.Columns(modbusSlaveConfigRows)

	if len(orderBy) == 0 {
		builder = builder.OrderBy("id DESC")
	} else {
		builder = builder.OrderBy(orderBy...)
	}

	query, values, err := builder.Where("del_state = ?", 0).ToSql()
	if err != nil {
		return nil, err
	}

	var resp []*ModbusSlaveConfig

	err = m.conn.QueryRowsCtx(ctx, &resp, query, values...)

	switch err {
	case nil:
		return resp, nil
	default:
		return nil, err
	}
}

func (m *defaultModbusSlaveConfigModel) FindPageListByPage(ctx context.Context, builder squirrel.SelectBuilder, page, pageSize int64, orderBy ...string) ([]*ModbusSlaveConfig, error) {

	builder = builder.Columns(modbusSlaveConfigRows)

	if len(orderBy) == 0 {
		builder = builder.OrderBy("id DESC")
	} else {
		builder = builder.OrderBy(orderBy...)
	}

	if page < 1 {
		page = 1
	}
	offset := (page - 1) * pageSize

	query, values, err := builder.Where("del_state = ?", 0).Offset(uint64(offset)).Limit(uint64(pageSize)).ToSql()
	if err != nil {
		return nil, err
	}

	var resp []*ModbusSlaveConfig

	err = m.conn.QueryRowsCtx(ctx, &resp, query, values...)

	switch err {
	case nil:
		return resp, nil
	default:
		return nil, err
	}
}

func (m *defaultModbusSlaveConfigModel) FindPageListByPageWithTotal(ctx context.Context, builder squirrel.SelectBuilder, page, pageSize int64, orderBy ...string) ([]*ModbusSlaveConfig, int64, error) {

	total, err := m.FindCount(ctx, builder, "id")
	if err != nil {
		return nil, 0, err
	}

	builder = builder.Columns(modbusSlaveConfigRows)

	if len(orderBy) == 0 {
		builder = builder.OrderBy("id DESC")
	} else {
		builder = builder.OrderBy(orderBy...)
	}

	if page < 1 {
		page = 1
	}
	offset := (page - 1) * pageSize

	query, values, err := builder.Where("del_state = ?", 0).Offset(uint64(offset)).Limit(uint64(pageSize)).ToSql()
	if err != nil {
		return nil, total, err
	}

	var resp []*ModbusSlaveConfig

	err = m.conn.QueryRowsCtx(ctx, &resp, query, values...)

	switch err {
	case nil:
		return resp, total, nil
	default:
		return nil, total, err
	}
}

func (m *defaultModbusSlaveConfigModel) FindPageListByIdDESC(ctx context.Context, builder squirrel.SelectBuilder, preMinId, pageSize int64) ([]*ModbusSlaveConfig, error) {

	builder = builder.Columns(modbusSlaveConfigRows)

	if preMinId > 0 {
		builder = builder.Where(" id < ? ", preMinId)
	}

	query, values, err := builder.Where("del_state = ?", 0).OrderBy("id DESC").Limit(uint64(pageSize)).ToSql()
	if err != nil {
		return nil, err
	}

	var resp []*ModbusSlaveConfig

	err = m.conn.QueryRowsCtx(ctx, &resp, query, values...)

	switch err {
	case nil:
		return resp, nil
	default:
		return nil, err
	}
}

func (m *defaultModbusSlaveConfigModel) FindPageListByIdASC(ctx context.Context, builder squirrel.SelectBuilder, preMaxId, pageSize int64) ([]*ModbusSlaveConfig, error) {

	builder = builder.Columns(modbusSlaveConfigRows)

	if preMaxId > 0 {
		builder = builder.Where(" id > ? ", preMaxId)
	}

	query, values, err := builder.Where("del_state = ?", 0).OrderBy("id ASC").Limit(uint64(pageSize)).ToSql()
	if err != nil {
		return nil, err
	}

	var resp []*ModbusSlaveConfig

	err = m.conn.QueryRowsCtx(ctx, &resp, query, values...)

	switch err {
	case nil:
		return resp, nil
	default:
		return nil, err
	}
}

func (m *defaultModbusSlaveConfigModel) Trans(ctx context.Context, fn func(ctx context.Context, session sqlx.Session) error) error {
	return m.conn.TransactCtx(ctx, func(ctx context.Context, session sqlx.Session) error {
		return fn(ctx, session)
	})
}

func (m *defaultModbusSlaveConfigModel) ExecCtx(ctx context.Context, session sqlx.Session, query string, args ...any) (sql.Result, error) {
	if session != nil {
		return session.ExecCtx(ctx, query, args...)
	}
	return m.conn.ExecCtx(ctx, query, args...)
}

func (m *defaultModbusSlaveConfigModel) SelectBuilder() squirrel.SelectBuilder {
	return squirrel.Select().From(m.table)
}

func (m *defaultModbusSlaveConfigModel) InsertBuilder() squirrel.InsertBuilder {
	return squirrel.Insert(m.table)
}

func (m *defaultModbusSlaveConfigModel) UpdateBuilder() squirrel.UpdateBuilder {
	return squirrel.Update(m.table)
}

func (m *defaultModbusSlaveConfigModel) DeleteBuilder() squirrel.DeleteBuilder {
	return squirrel.Delete(m.table)
}

func (m *defaultModbusSlaveConfigModel) tableName() string {
	return m.table
}
