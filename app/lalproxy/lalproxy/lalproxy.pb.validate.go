// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: lalproxy.proto

package lalproxy

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on FrameData with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FrameData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FrameData with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FrameDataMultiError, or nil
// if none found.
func (m *FrameData) ValidateAll() error {
	return m.validate(true)
}

func (m *FrameData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UnixSec

	// no validation rules for V

	if len(errors) > 0 {
		return FrameDataMultiError(errors)
	}

	return nil
}

// FrameDataMultiError is an error wrapping multiple validation errors returned
// by FrameData.ValidateAll() if the designated constraints aren't met.
type FrameDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FrameDataMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FrameDataMultiError) AllErrors() []error { return m }

// FrameDataValidationError is the validation error returned by
// FrameData.Validate if the designated constraints aren't met.
type FrameDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FrameDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FrameDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FrameDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FrameDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FrameDataValidationError) ErrorName() string { return "FrameDataValidationError" }

// Error satisfies the builtin error interface
func (e FrameDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFrameData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FrameDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FrameDataValidationError{}

// Validate checks the field values on PubSessionInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PubSessionInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PubSessionInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PubSessionInfoMultiError,
// or nil if none found.
func (m *PubSessionInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *PubSessionInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SessionId

	// no validation rules for Protocol

	// no validation rules for BaseType

	// no validation rules for StartTime

	// no validation rules for RemoteAddr

	// no validation rules for ReadBytesSum

	// no validation rules for WroteBytesSum

	// no validation rules for BitrateKbits

	// no validation rules for ReadBitrateKbits

	// no validation rules for WriteBitrateKbits

	if len(errors) > 0 {
		return PubSessionInfoMultiError(errors)
	}

	return nil
}

// PubSessionInfoMultiError is an error wrapping multiple validation errors
// returned by PubSessionInfo.ValidateAll() if the designated constraints
// aren't met.
type PubSessionInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PubSessionInfoMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PubSessionInfoMultiError) AllErrors() []error { return m }

// PubSessionInfoValidationError is the validation error returned by
// PubSessionInfo.Validate if the designated constraints aren't met.
type PubSessionInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PubSessionInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PubSessionInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PubSessionInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PubSessionInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PubSessionInfoValidationError) ErrorName() string { return "PubSessionInfoValidationError" }

// Error satisfies the builtin error interface
func (e PubSessionInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPubSessionInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PubSessionInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PubSessionInfoValidationError{}

// Validate checks the field values on SubSessionInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SubSessionInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SubSessionInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SubSessionInfoMultiError,
// or nil if none found.
func (m *SubSessionInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *SubSessionInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SessionId

	// no validation rules for Protocol

	// no validation rules for BaseType

	// no validation rules for StartTime

	// no validation rules for RemoteAddr

	// no validation rules for ReadBytesSum

	// no validation rules for WroteBytesSum

	// no validation rules for BitrateKbits

	// no validation rules for ReadBitrateKbits

	// no validation rules for WriteBitrateKbits

	if len(errors) > 0 {
		return SubSessionInfoMultiError(errors)
	}

	return nil
}

// SubSessionInfoMultiError is an error wrapping multiple validation errors
// returned by SubSessionInfo.ValidateAll() if the designated constraints
// aren't met.
type SubSessionInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SubSessionInfoMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SubSessionInfoMultiError) AllErrors() []error { return m }

// SubSessionInfoValidationError is the validation error returned by
// SubSessionInfo.Validate if the designated constraints aren't met.
type SubSessionInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SubSessionInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SubSessionInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SubSessionInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SubSessionInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SubSessionInfoValidationError) ErrorName() string { return "SubSessionInfoValidationError" }

// Error satisfies the builtin error interface
func (e SubSessionInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubSessionInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SubSessionInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SubSessionInfoValidationError{}

// Validate checks the field values on PullSessionInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *PullSessionInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PullSessionInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PullSessionInfoMultiError, or nil if none found.
func (m *PullSessionInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *PullSessionInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SessionId

	// no validation rules for Protocol

	// no validation rules for BaseType

	// no validation rules for StartTime

	// no validation rules for RemoteAddr

	// no validation rules for ReadBytesSum

	// no validation rules for WroteBytesSum

	// no validation rules for BitrateKbits

	// no validation rules for ReadBitrateKbits

	// no validation rules for WriteBitrateKbits

	if len(errors) > 0 {
		return PullSessionInfoMultiError(errors)
	}

	return nil
}

// PullSessionInfoMultiError is an error wrapping multiple validation errors
// returned by PullSessionInfo.ValidateAll() if the designated constraints
// aren't met.
type PullSessionInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PullSessionInfoMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PullSessionInfoMultiError) AllErrors() []error { return m }

// PullSessionInfoValidationError is the validation error returned by
// PullSessionInfo.Validate if the designated constraints aren't met.
type PullSessionInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PullSessionInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PullSessionInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PullSessionInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PullSessionInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PullSessionInfoValidationError) ErrorName() string { return "PullSessionInfoValidationError" }

// Error satisfies the builtin error interface
func (e PullSessionInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPullSessionInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PullSessionInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PullSessionInfoValidationError{}

// Validate checks the field values on PushSessionInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *PushSessionInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PushSessionInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PushSessionInfoMultiError, or nil if none found.
func (m *PushSessionInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *PushSessionInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return PushSessionInfoMultiError(errors)
	}

	return nil
}

// PushSessionInfoMultiError is an error wrapping multiple validation errors
// returned by PushSessionInfo.ValidateAll() if the designated constraints
// aren't met.
type PushSessionInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PushSessionInfoMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PushSessionInfoMultiError) AllErrors() []error { return m }

// PushSessionInfoValidationError is the validation error returned by
// PushSessionInfo.Validate if the designated constraints aren't met.
type PushSessionInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PushSessionInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PushSessionInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PushSessionInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PushSessionInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PushSessionInfoValidationError) ErrorName() string { return "PushSessionInfoValidationError" }

// Error satisfies the builtin error interface
func (e PushSessionInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPushSessionInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PushSessionInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PushSessionInfoValidationError{}

// Validate checks the field values on GroupData with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GroupData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GroupData with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GroupDataMultiError, or nil
// if none found.
func (m *GroupData) ValidateAll() error {
	return m.validate(true)
}

func (m *GroupData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for StreamName

	// no validation rules for AppName

	// no validation rules for AudioCodec

	// no validation rules for VideoCodec

	// no validation rules for VideoWidth

	// no validation rules for VideoHeight

	if all {
		switch v := interface{}(m.GetPub()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GroupDataValidationError{
					field:  "Pub",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GroupDataValidationError{
					field:  "Pub",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPub()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GroupDataValidationError{
				field:  "Pub",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetSubs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GroupDataValidationError{
						field:  fmt.Sprintf("Subs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GroupDataValidationError{
						field:  fmt.Sprintf("Subs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GroupDataValidationError{
					field:  fmt.Sprintf("Subs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetPull()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GroupDataValidationError{
					field:  "Pull",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GroupDataValidationError{
					field:  "Pull",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPull()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GroupDataValidationError{
				field:  "Pull",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetPushs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GroupDataValidationError{
						field:  fmt.Sprintf("Pushs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GroupDataValidationError{
						field:  fmt.Sprintf("Pushs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GroupDataValidationError{
					field:  fmt.Sprintf("Pushs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetInFramePerSec() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GroupDataValidationError{
						field:  fmt.Sprintf("InFramePerSec[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GroupDataValidationError{
						field:  fmt.Sprintf("InFramePerSec[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GroupDataValidationError{
					field:  fmt.Sprintf("InFramePerSec[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GroupDataMultiError(errors)
	}

	return nil
}

// GroupDataMultiError is an error wrapping multiple validation errors returned
// by GroupData.ValidateAll() if the designated constraints aren't met.
type GroupDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GroupDataMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GroupDataMultiError) AllErrors() []error { return m }

// GroupDataValidationError is the validation error returned by
// GroupData.Validate if the designated constraints aren't met.
type GroupDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GroupDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GroupDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GroupDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GroupDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GroupDataValidationError) ErrorName() string { return "GroupDataValidationError" }

// Error satisfies the builtin error interface
func (e GroupDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGroupData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GroupDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GroupDataValidationError{}

// Validate checks the field values on LalServerData with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LalServerData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LalServerData with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LalServerDataMultiError, or
// nil if none found.
func (m *LalServerData) ValidateAll() error {
	return m.validate(true)
}

func (m *LalServerData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ServerId

	// no validation rules for BinInfo

	// no validation rules for LalVersion

	// no validation rules for ApiVersion

	// no validation rules for NotifyVersion

	// no validation rules for WebUiVersion

	// no validation rules for StartTime

	if len(errors) > 0 {
		return LalServerDataMultiError(errors)
	}

	return nil
}

// LalServerDataMultiError is an error wrapping multiple validation errors
// returned by LalServerData.ValidateAll() if the designated constraints
// aren't met.
type LalServerDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LalServerDataMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LalServerDataMultiError) AllErrors() []error { return m }

// LalServerDataValidationError is the validation error returned by
// LalServerData.Validate if the designated constraints aren't met.
type LalServerDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LalServerDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LalServerDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LalServerDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LalServerDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LalServerDataValidationError) ErrorName() string { return "LalServerDataValidationError" }

// Error satisfies the builtin error interface
func (e LalServerDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLalServerData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LalServerDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LalServerDataValidationError{}

// Validate checks the field values on GetGroupInfoReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetGroupInfoReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetGroupInfoReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetGroupInfoReqMultiError, or nil if none found.
func (m *GetGroupInfoReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetGroupInfoReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for StreamName

	if len(errors) > 0 {
		return GetGroupInfoReqMultiError(errors)
	}

	return nil
}

// GetGroupInfoReqMultiError is an error wrapping multiple validation errors
// returned by GetGroupInfoReq.ValidateAll() if the designated constraints
// aren't met.
type GetGroupInfoReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetGroupInfoReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetGroupInfoReqMultiError) AllErrors() []error { return m }

// GetGroupInfoReqValidationError is the validation error returned by
// GetGroupInfoReq.Validate if the designated constraints aren't met.
type GetGroupInfoReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetGroupInfoReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetGroupInfoReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetGroupInfoReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetGroupInfoReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetGroupInfoReqValidationError) ErrorName() string { return "GetGroupInfoReqValidationError" }

// Error satisfies the builtin error interface
func (e GetGroupInfoReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetGroupInfoReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetGroupInfoReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetGroupInfoReqValidationError{}

// Validate checks the field values on GetGroupInfoRes with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetGroupInfoRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetGroupInfoRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetGroupInfoResMultiError, or nil if none found.
func (m *GetGroupInfoRes) ValidateAll() error {
	return m.validate(true)
}

func (m *GetGroupInfoRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ErrorCode

	// no validation rules for Desp

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetGroupInfoResValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetGroupInfoResValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetGroupInfoResValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetGroupInfoResMultiError(errors)
	}

	return nil
}

// GetGroupInfoResMultiError is an error wrapping multiple validation errors
// returned by GetGroupInfoRes.ValidateAll() if the designated constraints
// aren't met.
type GetGroupInfoResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetGroupInfoResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetGroupInfoResMultiError) AllErrors() []error { return m }

// GetGroupInfoResValidationError is the validation error returned by
// GetGroupInfoRes.Validate if the designated constraints aren't met.
type GetGroupInfoResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetGroupInfoResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetGroupInfoResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetGroupInfoResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetGroupInfoResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetGroupInfoResValidationError) ErrorName() string { return "GetGroupInfoResValidationError" }

// Error satisfies the builtin error interface
func (e GetGroupInfoResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetGroupInfoRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetGroupInfoResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetGroupInfoResValidationError{}

// Validate checks the field values on GetAllGroupsReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetAllGroupsReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetAllGroupsReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetAllGroupsReqMultiError, or nil if none found.
func (m *GetAllGroupsReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetAllGroupsReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return GetAllGroupsReqMultiError(errors)
	}

	return nil
}

// GetAllGroupsReqMultiError is an error wrapping multiple validation errors
// returned by GetAllGroupsReq.ValidateAll() if the designated constraints
// aren't met.
type GetAllGroupsReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetAllGroupsReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetAllGroupsReqMultiError) AllErrors() []error { return m }

// GetAllGroupsReqValidationError is the validation error returned by
// GetAllGroupsReq.Validate if the designated constraints aren't met.
type GetAllGroupsReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetAllGroupsReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetAllGroupsReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetAllGroupsReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetAllGroupsReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetAllGroupsReqValidationError) ErrorName() string { return "GetAllGroupsReqValidationError" }

// Error satisfies the builtin error interface
func (e GetAllGroupsReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetAllGroupsReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetAllGroupsReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetAllGroupsReqValidationError{}

// Validate checks the field values on GetAllGroupsRes with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetAllGroupsRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetAllGroupsRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetAllGroupsResMultiError, or nil if none found.
func (m *GetAllGroupsRes) ValidateAll() error {
	return m.validate(true)
}

func (m *GetAllGroupsRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ErrorCode

	// no validation rules for Desp

	for idx, item := range m.GetGroups() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetAllGroupsResValidationError{
						field:  fmt.Sprintf("Groups[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetAllGroupsResValidationError{
						field:  fmt.Sprintf("Groups[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetAllGroupsResValidationError{
					field:  fmt.Sprintf("Groups[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetAllGroupsResMultiError(errors)
	}

	return nil
}

// GetAllGroupsResMultiError is an error wrapping multiple validation errors
// returned by GetAllGroupsRes.ValidateAll() if the designated constraints
// aren't met.
type GetAllGroupsResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetAllGroupsResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetAllGroupsResMultiError) AllErrors() []error { return m }

// GetAllGroupsResValidationError is the validation error returned by
// GetAllGroupsRes.Validate if the designated constraints aren't met.
type GetAllGroupsResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetAllGroupsResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetAllGroupsResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetAllGroupsResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetAllGroupsResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetAllGroupsResValidationError) ErrorName() string { return "GetAllGroupsResValidationError" }

// Error satisfies the builtin error interface
func (e GetAllGroupsResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetAllGroupsRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetAllGroupsResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetAllGroupsResValidationError{}

// Validate checks the field values on GetLalInfoReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetLalInfoReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetLalInfoReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetLalInfoReqMultiError, or
// nil if none found.
func (m *GetLalInfoReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetLalInfoReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return GetLalInfoReqMultiError(errors)
	}

	return nil
}

// GetLalInfoReqMultiError is an error wrapping multiple validation errors
// returned by GetLalInfoReq.ValidateAll() if the designated constraints
// aren't met.
type GetLalInfoReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetLalInfoReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetLalInfoReqMultiError) AllErrors() []error { return m }

// GetLalInfoReqValidationError is the validation error returned by
// GetLalInfoReq.Validate if the designated constraints aren't met.
type GetLalInfoReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetLalInfoReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetLalInfoReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetLalInfoReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetLalInfoReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetLalInfoReqValidationError) ErrorName() string { return "GetLalInfoReqValidationError" }

// Error satisfies the builtin error interface
func (e GetLalInfoReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetLalInfoReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetLalInfoReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetLalInfoReqValidationError{}

// Validate checks the field values on GetLalInfoRes with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetLalInfoRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetLalInfoRes with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetLalInfoResMultiError, or
// nil if none found.
func (m *GetLalInfoRes) ValidateAll() error {
	return m.validate(true)
}

func (m *GetLalInfoRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ErrorCode

	// no validation rules for Desp

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetLalInfoResValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetLalInfoResValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetLalInfoResValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetLalInfoResMultiError(errors)
	}

	return nil
}

// GetLalInfoResMultiError is an error wrapping multiple validation errors
// returned by GetLalInfoRes.ValidateAll() if the designated constraints
// aren't met.
type GetLalInfoResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetLalInfoResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetLalInfoResMultiError) AllErrors() []error { return m }

// GetLalInfoResValidationError is the validation error returned by
// GetLalInfoRes.Validate if the designated constraints aren't met.
type GetLalInfoResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetLalInfoResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetLalInfoResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetLalInfoResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetLalInfoResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetLalInfoResValidationError) ErrorName() string { return "GetLalInfoResValidationError" }

// Error satisfies the builtin error interface
func (e GetLalInfoResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetLalInfoRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetLalInfoResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetLalInfoResValidationError{}

// Validate checks the field values on StartRelayPullReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *StartRelayPullReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StartRelayPullReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// StartRelayPullReqMultiError, or nil if none found.
func (m *StartRelayPullReq) ValidateAll() error {
	return m.validate(true)
}

func (m *StartRelayPullReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Url

	// no validation rules for StreamName

	// no validation rules for PullTimeoutMs

	// no validation rules for PullRetryNum

	// no validation rules for AutoStopPullAfterNoOutMs

	// no validation rules for RtspMode

	// no validation rules for DebugDumpPacket

	if len(errors) > 0 {
		return StartRelayPullReqMultiError(errors)
	}

	return nil
}

// StartRelayPullReqMultiError is an error wrapping multiple validation errors
// returned by StartRelayPullReq.ValidateAll() if the designated constraints
// aren't met.
type StartRelayPullReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StartRelayPullReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StartRelayPullReqMultiError) AllErrors() []error { return m }

// StartRelayPullReqValidationError is the validation error returned by
// StartRelayPullReq.Validate if the designated constraints aren't met.
type StartRelayPullReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StartRelayPullReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StartRelayPullReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StartRelayPullReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StartRelayPullReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StartRelayPullReqValidationError) ErrorName() string {
	return "StartRelayPullReqValidationError"
}

// Error satisfies the builtin error interface
func (e StartRelayPullReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStartRelayPullReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StartRelayPullReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StartRelayPullReqValidationError{}

// Validate checks the field values on StartRelayPullRes with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *StartRelayPullRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StartRelayPullRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// StartRelayPullResMultiError, or nil if none found.
func (m *StartRelayPullRes) ValidateAll() error {
	return m.validate(true)
}

func (m *StartRelayPullRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ErrorCode

	// no validation rules for Desp

	if len(errors) > 0 {
		return StartRelayPullResMultiError(errors)
	}

	return nil
}

// StartRelayPullResMultiError is an error wrapping multiple validation errors
// returned by StartRelayPullRes.ValidateAll() if the designated constraints
// aren't met.
type StartRelayPullResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StartRelayPullResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StartRelayPullResMultiError) AllErrors() []error { return m }

// StartRelayPullResValidationError is the validation error returned by
// StartRelayPullRes.Validate if the designated constraints aren't met.
type StartRelayPullResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StartRelayPullResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StartRelayPullResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StartRelayPullResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StartRelayPullResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StartRelayPullResValidationError) ErrorName() string {
	return "StartRelayPullResValidationError"
}

// Error satisfies the builtin error interface
func (e StartRelayPullResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStartRelayPullRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StartRelayPullResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StartRelayPullResValidationError{}

// Validate checks the field values on StopRelayPullReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *StopRelayPullReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StopRelayPullReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// StopRelayPullReqMultiError, or nil if none found.
func (m *StopRelayPullReq) ValidateAll() error {
	return m.validate(true)
}

func (m *StopRelayPullReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for StreamName

	if len(errors) > 0 {
		return StopRelayPullReqMultiError(errors)
	}

	return nil
}

// StopRelayPullReqMultiError is an error wrapping multiple validation errors
// returned by StopRelayPullReq.ValidateAll() if the designated constraints
// aren't met.
type StopRelayPullReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StopRelayPullReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StopRelayPullReqMultiError) AllErrors() []error { return m }

// StopRelayPullReqValidationError is the validation error returned by
// StopRelayPullReq.Validate if the designated constraints aren't met.
type StopRelayPullReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StopRelayPullReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StopRelayPullReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StopRelayPullReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StopRelayPullReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StopRelayPullReqValidationError) ErrorName() string { return "StopRelayPullReqValidationError" }

// Error satisfies the builtin error interface
func (e StopRelayPullReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStopRelayPullReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StopRelayPullReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StopRelayPullReqValidationError{}

// Validate checks the field values on StopRelayPullRes with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *StopRelayPullRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StopRelayPullRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// StopRelayPullResMultiError, or nil if none found.
func (m *StopRelayPullRes) ValidateAll() error {
	return m.validate(true)
}

func (m *StopRelayPullRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ErrorCode

	// no validation rules for Desp

	if len(errors) > 0 {
		return StopRelayPullResMultiError(errors)
	}

	return nil
}

// StopRelayPullResMultiError is an error wrapping multiple validation errors
// returned by StopRelayPullRes.ValidateAll() if the designated constraints
// aren't met.
type StopRelayPullResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StopRelayPullResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StopRelayPullResMultiError) AllErrors() []error { return m }

// StopRelayPullResValidationError is the validation error returned by
// StopRelayPullRes.Validate if the designated constraints aren't met.
type StopRelayPullResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StopRelayPullResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StopRelayPullResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StopRelayPullResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StopRelayPullResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StopRelayPullResValidationError) ErrorName() string { return "StopRelayPullResValidationError" }

// Error satisfies the builtin error interface
func (e StopRelayPullResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStopRelayPullRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StopRelayPullResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StopRelayPullResValidationError{}

// Validate checks the field values on KickSessionReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *KickSessionReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on KickSessionReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in KickSessionReqMultiError,
// or nil if none found.
func (m *KickSessionReq) ValidateAll() error {
	return m.validate(true)
}

func (m *KickSessionReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for StreamName

	// no validation rules for SessionId

	if len(errors) > 0 {
		return KickSessionReqMultiError(errors)
	}

	return nil
}

// KickSessionReqMultiError is an error wrapping multiple validation errors
// returned by KickSessionReq.ValidateAll() if the designated constraints
// aren't met.
type KickSessionReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m KickSessionReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m KickSessionReqMultiError) AllErrors() []error { return m }

// KickSessionReqValidationError is the validation error returned by
// KickSessionReq.Validate if the designated constraints aren't met.
type KickSessionReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e KickSessionReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e KickSessionReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e KickSessionReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e KickSessionReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e KickSessionReqValidationError) ErrorName() string { return "KickSessionReqValidationError" }

// Error satisfies the builtin error interface
func (e KickSessionReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sKickSessionReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = KickSessionReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = KickSessionReqValidationError{}

// Validate checks the field values on KickSessionRes with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *KickSessionRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on KickSessionRes with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in KickSessionResMultiError,
// or nil if none found.
func (m *KickSessionRes) ValidateAll() error {
	return m.validate(true)
}

func (m *KickSessionRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ErrorCode

	// no validation rules for Desp

	if len(errors) > 0 {
		return KickSessionResMultiError(errors)
	}

	return nil
}

// KickSessionResMultiError is an error wrapping multiple validation errors
// returned by KickSessionRes.ValidateAll() if the designated constraints
// aren't met.
type KickSessionResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m KickSessionResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m KickSessionResMultiError) AllErrors() []error { return m }

// KickSessionResValidationError is the validation error returned by
// KickSessionRes.Validate if the designated constraints aren't met.
type KickSessionResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e KickSessionResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e KickSessionResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e KickSessionResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e KickSessionResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e KickSessionResValidationError) ErrorName() string { return "KickSessionResValidationError" }

// Error satisfies the builtin error interface
func (e KickSessionResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sKickSessionRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = KickSessionResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = KickSessionResValidationError{}

// Validate checks the field values on StartRtpPubReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *StartRtpPubReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StartRtpPubReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in StartRtpPubReqMultiError,
// or nil if none found.
func (m *StartRtpPubReq) ValidateAll() error {
	return m.validate(true)
}

func (m *StartRtpPubReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for StreamName

	// no validation rules for Port

	// no validation rules for TimeoutMs

	// no validation rules for IsTcpFlag

	// no validation rules for DebugDumpPacket

	if len(errors) > 0 {
		return StartRtpPubReqMultiError(errors)
	}

	return nil
}

// StartRtpPubReqMultiError is an error wrapping multiple validation errors
// returned by StartRtpPubReq.ValidateAll() if the designated constraints
// aren't met.
type StartRtpPubReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StartRtpPubReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StartRtpPubReqMultiError) AllErrors() []error { return m }

// StartRtpPubReqValidationError is the validation error returned by
// StartRtpPubReq.Validate if the designated constraints aren't met.
type StartRtpPubReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StartRtpPubReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StartRtpPubReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StartRtpPubReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StartRtpPubReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StartRtpPubReqValidationError) ErrorName() string { return "StartRtpPubReqValidationError" }

// Error satisfies the builtin error interface
func (e StartRtpPubReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStartRtpPubReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StartRtpPubReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StartRtpPubReqValidationError{}

// Validate checks the field values on StartRtpPubRes with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *StartRtpPubRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StartRtpPubRes with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in StartRtpPubResMultiError,
// or nil if none found.
func (m *StartRtpPubRes) ValidateAll() error {
	return m.validate(true)
}

func (m *StartRtpPubRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ErrorCode

	// no validation rules for Desp

	if len(errors) > 0 {
		return StartRtpPubResMultiError(errors)
	}

	return nil
}

// StartRtpPubResMultiError is an error wrapping multiple validation errors
// returned by StartRtpPubRes.ValidateAll() if the designated constraints
// aren't met.
type StartRtpPubResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StartRtpPubResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StartRtpPubResMultiError) AllErrors() []error { return m }

// StartRtpPubResValidationError is the validation error returned by
// StartRtpPubRes.Validate if the designated constraints aren't met.
type StartRtpPubResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StartRtpPubResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StartRtpPubResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StartRtpPubResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StartRtpPubResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StartRtpPubResValidationError) ErrorName() string { return "StartRtpPubResValidationError" }

// Error satisfies the builtin error interface
func (e StartRtpPubResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStartRtpPubRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StartRtpPubResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StartRtpPubResValidationError{}

// Validate checks the field values on StopRtpPubReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *StopRtpPubReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StopRtpPubReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in StopRtpPubReqMultiError, or
// nil if none found.
func (m *StopRtpPubReq) ValidateAll() error {
	return m.validate(true)
}

func (m *StopRtpPubReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for StreamName

	if len(errors) > 0 {
		return StopRtpPubReqMultiError(errors)
	}

	return nil
}

// StopRtpPubReqMultiError is an error wrapping multiple validation errors
// returned by StopRtpPubReq.ValidateAll() if the designated constraints
// aren't met.
type StopRtpPubReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StopRtpPubReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StopRtpPubReqMultiError) AllErrors() []error { return m }

// StopRtpPubReqValidationError is the validation error returned by
// StopRtpPubReq.Validate if the designated constraints aren't met.
type StopRtpPubReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StopRtpPubReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StopRtpPubReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StopRtpPubReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StopRtpPubReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StopRtpPubReqValidationError) ErrorName() string { return "StopRtpPubReqValidationError" }

// Error satisfies the builtin error interface
func (e StopRtpPubReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStopRtpPubReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StopRtpPubReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StopRtpPubReqValidationError{}

// Validate checks the field values on StopRtpPubRes with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *StopRtpPubRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StopRtpPubRes with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in StopRtpPubResMultiError, or
// nil if none found.
func (m *StopRtpPubRes) ValidateAll() error {
	return m.validate(true)
}

func (m *StopRtpPubRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ErrorCode

	// no validation rules for Desp

	if len(errors) > 0 {
		return StopRtpPubResMultiError(errors)
	}

	return nil
}

// StopRtpPubResMultiError is an error wrapping multiple validation errors
// returned by StopRtpPubRes.ValidateAll() if the designated constraints
// aren't met.
type StopRtpPubResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StopRtpPubResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StopRtpPubResMultiError) AllErrors() []error { return m }

// StopRtpPubResValidationError is the validation error returned by
// StopRtpPubRes.Validate if the designated constraints aren't met.
type StopRtpPubResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StopRtpPubResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StopRtpPubResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StopRtpPubResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StopRtpPubResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StopRtpPubResValidationError) ErrorName() string { return "StopRtpPubResValidationError" }

// Error satisfies the builtin error interface
func (e StopRtpPubResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStopRtpPubRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StopRtpPubResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StopRtpPubResValidationError{}

// Validate checks the field values on AddIpBlacklistReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *AddIpBlacklistReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddIpBlacklistReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AddIpBlacklistReqMultiError, or nil if none found.
func (m *AddIpBlacklistReq) ValidateAll() error {
	return m.validate(true)
}

func (m *AddIpBlacklistReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Ip

	// no validation rules for DurationSec

	if len(errors) > 0 {
		return AddIpBlacklistReqMultiError(errors)
	}

	return nil
}

// AddIpBlacklistReqMultiError is an error wrapping multiple validation errors
// returned by AddIpBlacklistReq.ValidateAll() if the designated constraints
// aren't met.
type AddIpBlacklistReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddIpBlacklistReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddIpBlacklistReqMultiError) AllErrors() []error { return m }

// AddIpBlacklistReqValidationError is the validation error returned by
// AddIpBlacklistReq.Validate if the designated constraints aren't met.
type AddIpBlacklistReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddIpBlacklistReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddIpBlacklistReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddIpBlacklistReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddIpBlacklistReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddIpBlacklistReqValidationError) ErrorName() string {
	return "AddIpBlacklistReqValidationError"
}

// Error satisfies the builtin error interface
func (e AddIpBlacklistReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddIpBlacklistReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddIpBlacklistReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddIpBlacklistReqValidationError{}

// Validate checks the field values on AddIpBlacklistRes with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *AddIpBlacklistRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddIpBlacklistRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AddIpBlacklistResMultiError, or nil if none found.
func (m *AddIpBlacklistRes) ValidateAll() error {
	return m.validate(true)
}

func (m *AddIpBlacklistRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ErrorCode

	// no validation rules for Desp

	if len(errors) > 0 {
		return AddIpBlacklistResMultiError(errors)
	}

	return nil
}

// AddIpBlacklistResMultiError is an error wrapping multiple validation errors
// returned by AddIpBlacklistRes.ValidateAll() if the designated constraints
// aren't met.
type AddIpBlacklistResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddIpBlacklistResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddIpBlacklistResMultiError) AllErrors() []error { return m }

// AddIpBlacklistResValidationError is the validation error returned by
// AddIpBlacklistRes.Validate if the designated constraints aren't met.
type AddIpBlacklistResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddIpBlacklistResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddIpBlacklistResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddIpBlacklistResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddIpBlacklistResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddIpBlacklistResValidationError) ErrorName() string {
	return "AddIpBlacklistResValidationError"
}

// Error satisfies the builtin error interface
func (e AddIpBlacklistResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddIpBlacklistRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddIpBlacklistResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddIpBlacklistResValidationError{}
