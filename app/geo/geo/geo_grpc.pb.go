// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.29.3
// source: geo.proto

package geo

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	Geo_Ping_FullMethodName                = "/geo.Geo/Ping"
	Geo_EncodeGeoHash_FullMethodName       = "/geo.Geo/EncodeGeoHash"
	Geo_DecodeGeoHash_FullMethodName       = "/geo.Geo/DecodeGeoHash"
	Geo_GenerateFenceCells_FullMethodName  = "/geo.Geo/GenerateFenceCells"
	Geo_PointInFence_FullMethodName        = "/geo.Geo/PointInFence"
	Geo_PointInFences_FullMethodName       = "/geo.Geo/PointInFences"
	Geo_Distance_FullMethodName            = "/geo.Geo/Distance"
	Geo_NearbyFences_FullMethodName        = "/geo.Geo/NearbyFences"
	Geo_TransformCoord_FullMethodName      = "/geo.Geo/TransformCoord"
	Geo_BatchTransformCoord_FullMethodName = "/geo.Geo/BatchTransformCoord"
)

// GeoClient is the client API for Geo service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// GEO 相关服务
type GeoClient interface {
	Ping(ctx context.Context, in *Req, opts ...grpc.CallOption) (*Res, error)
	// 计算 geohash
	EncodeGeoHash(ctx context.Context, in *EncodeGeoHashReq, opts ...grpc.CallOption) (*EncodeGeoHashRes, error)
	// 解码 geohash -> 经纬度
	DecodeGeoHash(ctx context.Context, in *DecodeGeoHashReq, opts ...grpc.CallOption) (*DecodeGeoHashRes, error)
	// 一次性生成围栏 cells（小围栏）
	GenerateFenceCells(ctx context.Context, in *GenFenceCellsReq, opts ...grpc.CallOption) (*GenFenceCellsRes, error)
	// 点是否命中电子围栏（单个）
	PointInFence(ctx context.Context, in *PointInFenceReq, opts ...grpc.CallOption) (*PointInFenceRes, error)
	// 点是否命中电子围栏（多个围栏）
	PointInFences(ctx context.Context, in *PointInFencesReq, opts ...grpc.CallOption) (*PointInFencesRes, error)
	// 计算两个点之间的距离（米）
	Distance(ctx context.Context, in *DistanceReq, opts ...grpc.CallOption) (*DistanceRes, error)
	// 获取某点附近多少 km 的围栏（粗过滤）
	NearbyFences(ctx context.Context, in *NearbyFencesReq, opts ...grpc.CallOption) (*NearbyFencesRes, error)
	// 单个坐标转换
	TransformCoord(ctx context.Context, in *TransformCoordReq, opts ...grpc.CallOption) (*TransformCoordRes, error)
	// 批量坐标转换
	BatchTransformCoord(ctx context.Context, in *BatchTransformCoordReq, opts ...grpc.CallOption) (*BatchTransformCoordRes, error)
}

type geoClient struct {
	cc grpc.ClientConnInterface
}

func NewGeoClient(cc grpc.ClientConnInterface) GeoClient {
	return &geoClient{cc}
}

func (c *geoClient) Ping(ctx context.Context, in *Req, opts ...grpc.CallOption) (*Res, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Res)
	err := c.cc.Invoke(ctx, Geo_Ping_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *geoClient) EncodeGeoHash(ctx context.Context, in *EncodeGeoHashReq, opts ...grpc.CallOption) (*EncodeGeoHashRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EncodeGeoHashRes)
	err := c.cc.Invoke(ctx, Geo_EncodeGeoHash_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *geoClient) DecodeGeoHash(ctx context.Context, in *DecodeGeoHashReq, opts ...grpc.CallOption) (*DecodeGeoHashRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DecodeGeoHashRes)
	err := c.cc.Invoke(ctx, Geo_DecodeGeoHash_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *geoClient) GenerateFenceCells(ctx context.Context, in *GenFenceCellsReq, opts ...grpc.CallOption) (*GenFenceCellsRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GenFenceCellsRes)
	err := c.cc.Invoke(ctx, Geo_GenerateFenceCells_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *geoClient) PointInFence(ctx context.Context, in *PointInFenceReq, opts ...grpc.CallOption) (*PointInFenceRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PointInFenceRes)
	err := c.cc.Invoke(ctx, Geo_PointInFence_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *geoClient) PointInFences(ctx context.Context, in *PointInFencesReq, opts ...grpc.CallOption) (*PointInFencesRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PointInFencesRes)
	err := c.cc.Invoke(ctx, Geo_PointInFences_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *geoClient) Distance(ctx context.Context, in *DistanceReq, opts ...grpc.CallOption) (*DistanceRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DistanceRes)
	err := c.cc.Invoke(ctx, Geo_Distance_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *geoClient) NearbyFences(ctx context.Context, in *NearbyFencesReq, opts ...grpc.CallOption) (*NearbyFencesRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(NearbyFencesRes)
	err := c.cc.Invoke(ctx, Geo_NearbyFences_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *geoClient) TransformCoord(ctx context.Context, in *TransformCoordReq, opts ...grpc.CallOption) (*TransformCoordRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TransformCoordRes)
	err := c.cc.Invoke(ctx, Geo_TransformCoord_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *geoClient) BatchTransformCoord(ctx context.Context, in *BatchTransformCoordReq, opts ...grpc.CallOption) (*BatchTransformCoordRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BatchTransformCoordRes)
	err := c.cc.Invoke(ctx, Geo_BatchTransformCoord_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GeoServer is the server API for Geo service.
// All implementations must embed UnimplementedGeoServer
// for forward compatibility.
//
// GEO 相关服务
type GeoServer interface {
	Ping(context.Context, *Req) (*Res, error)
	// 计算 geohash
	EncodeGeoHash(context.Context, *EncodeGeoHashReq) (*EncodeGeoHashRes, error)
	// 解码 geohash -> 经纬度
	DecodeGeoHash(context.Context, *DecodeGeoHashReq) (*DecodeGeoHashRes, error)
	// 一次性生成围栏 cells（小围栏）
	GenerateFenceCells(context.Context, *GenFenceCellsReq) (*GenFenceCellsRes, error)
	// 点是否命中电子围栏（单个）
	PointInFence(context.Context, *PointInFenceReq) (*PointInFenceRes, error)
	// 点是否命中电子围栏（多个围栏）
	PointInFences(context.Context, *PointInFencesReq) (*PointInFencesRes, error)
	// 计算两个点之间的距离（米）
	Distance(context.Context, *DistanceReq) (*DistanceRes, error)
	// 获取某点附近多少 km 的围栏（粗过滤）
	NearbyFences(context.Context, *NearbyFencesReq) (*NearbyFencesRes, error)
	// 单个坐标转换
	TransformCoord(context.Context, *TransformCoordReq) (*TransformCoordRes, error)
	// 批量坐标转换
	BatchTransformCoord(context.Context, *BatchTransformCoordReq) (*BatchTransformCoordRes, error)
	mustEmbedUnimplementedGeoServer()
}

// UnimplementedGeoServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedGeoServer struct{}

func (UnimplementedGeoServer) Ping(context.Context, *Req) (*Res, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Ping not implemented")
}
func (UnimplementedGeoServer) EncodeGeoHash(context.Context, *EncodeGeoHashReq) (*EncodeGeoHashRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EncodeGeoHash not implemented")
}
func (UnimplementedGeoServer) DecodeGeoHash(context.Context, *DecodeGeoHashReq) (*DecodeGeoHashRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DecodeGeoHash not implemented")
}
func (UnimplementedGeoServer) GenerateFenceCells(context.Context, *GenFenceCellsReq) (*GenFenceCellsRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateFenceCells not implemented")
}
func (UnimplementedGeoServer) PointInFence(context.Context, *PointInFenceReq) (*PointInFenceRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PointInFence not implemented")
}
func (UnimplementedGeoServer) PointInFences(context.Context, *PointInFencesReq) (*PointInFencesRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PointInFences not implemented")
}
func (UnimplementedGeoServer) Distance(context.Context, *DistanceReq) (*DistanceRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Distance not implemented")
}
func (UnimplementedGeoServer) NearbyFences(context.Context, *NearbyFencesReq) (*NearbyFencesRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NearbyFences not implemented")
}
func (UnimplementedGeoServer) TransformCoord(context.Context, *TransformCoordReq) (*TransformCoordRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TransformCoord not implemented")
}
func (UnimplementedGeoServer) BatchTransformCoord(context.Context, *BatchTransformCoordReq) (*BatchTransformCoordRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchTransformCoord not implemented")
}
func (UnimplementedGeoServer) mustEmbedUnimplementedGeoServer() {}
func (UnimplementedGeoServer) testEmbeddedByValue()             {}

// UnsafeGeoServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GeoServer will
// result in compilation errors.
type UnsafeGeoServer interface {
	mustEmbedUnimplementedGeoServer()
}

func RegisterGeoServer(s grpc.ServiceRegistrar, srv GeoServer) {
	// If the following call pancis, it indicates UnimplementedGeoServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Geo_ServiceDesc, srv)
}

func _Geo_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Req)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GeoServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Geo_Ping_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GeoServer).Ping(ctx, req.(*Req))
	}
	return interceptor(ctx, in, info, handler)
}

func _Geo_EncodeGeoHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EncodeGeoHashReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GeoServer).EncodeGeoHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Geo_EncodeGeoHash_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GeoServer).EncodeGeoHash(ctx, req.(*EncodeGeoHashReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Geo_DecodeGeoHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DecodeGeoHashReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GeoServer).DecodeGeoHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Geo_DecodeGeoHash_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GeoServer).DecodeGeoHash(ctx, req.(*DecodeGeoHashReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Geo_GenerateFenceCells_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenFenceCellsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GeoServer).GenerateFenceCells(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Geo_GenerateFenceCells_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GeoServer).GenerateFenceCells(ctx, req.(*GenFenceCellsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Geo_PointInFence_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PointInFenceReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GeoServer).PointInFence(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Geo_PointInFence_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GeoServer).PointInFence(ctx, req.(*PointInFenceReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Geo_PointInFences_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PointInFencesReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GeoServer).PointInFences(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Geo_PointInFences_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GeoServer).PointInFences(ctx, req.(*PointInFencesReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Geo_Distance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DistanceReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GeoServer).Distance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Geo_Distance_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GeoServer).Distance(ctx, req.(*DistanceReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Geo_NearbyFences_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NearbyFencesReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GeoServer).NearbyFences(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Geo_NearbyFences_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GeoServer).NearbyFences(ctx, req.(*NearbyFencesReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Geo_TransformCoord_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TransformCoordReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GeoServer).TransformCoord(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Geo_TransformCoord_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GeoServer).TransformCoord(ctx, req.(*TransformCoordReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Geo_BatchTransformCoord_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchTransformCoordReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GeoServer).BatchTransformCoord(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Geo_BatchTransformCoord_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GeoServer).BatchTransformCoord(ctx, req.(*BatchTransformCoordReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Geo_ServiceDesc is the grpc.ServiceDesc for Geo service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Geo_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "geo.Geo",
	HandlerType: (*GeoServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Ping",
			Handler:    _Geo_Ping_Handler,
		},
		{
			MethodName: "EncodeGeoHash",
			Handler:    _Geo_EncodeGeoHash_Handler,
		},
		{
			MethodName: "DecodeGeoHash",
			Handler:    _Geo_DecodeGeoHash_Handler,
		},
		{
			MethodName: "GenerateFenceCells",
			Handler:    _Geo_GenerateFenceCells_Handler,
		},
		{
			MethodName: "PointInFence",
			Handler:    _Geo_PointInFence_Handler,
		},
		{
			MethodName: "PointInFences",
			Handler:    _Geo_PointInFences_Handler,
		},
		{
			MethodName: "Distance",
			Handler:    _Geo_Distance_Handler,
		},
		{
			MethodName: "NearbyFences",
			Handler:    _Geo_NearbyFences_Handler,
		},
		{
			MethodName: "TransformCoord",
			Handler:    _Geo_TransformCoord_Handler,
		},
		{
			MethodName: "BatchTransformCoord",
			Handler:    _Geo_BatchTransformCoord_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "geo.proto",
}
