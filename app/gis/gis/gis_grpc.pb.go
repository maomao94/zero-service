// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.19.4
// source: gis.proto

package gis

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	Gis_Ping_FullMethodName                 = "/gis.Gis/Ping"
	Gis_EncodeGeoHash_FullMethodName        = "/gis.Gis/EncodeGeoHash"
	Gis_DecodeGeoHash_FullMethodName        = "/gis.Gis/DecodeGeoHash"
	Gis_EncodeH3_FullMethodName             = "/gis.Gis/EncodeH3"
	Gis_DecodeH3_FullMethodName             = "/gis.Gis/DecodeH3"
	Gis_GenerateFenceCells_FullMethodName   = "/gis.Gis/GenerateFenceCells"
	Gis_GenerateFenceH3Cells_FullMethodName = "/gis.Gis/GenerateFenceH3Cells"
	Gis_PointsWithinRadius_FullMethodName   = "/gis.Gis/PointsWithinRadius"
	Gis_PointInFence_FullMethodName         = "/gis.Gis/PointInFence"
	Gis_PointInFences_FullMethodName        = "/gis.Gis/PointInFences"
	Gis_Distance_FullMethodName             = "/gis.Gis/Distance"
	Gis_BatchDistance_FullMethodName        = "/gis.Gis/BatchDistance"
	Gis_NearbyFences_FullMethodName         = "/gis.Gis/NearbyFences"
	Gis_TransformCoord_FullMethodName       = "/gis.Gis/TransformCoord"
	Gis_BatchTransformCoord_FullMethodName  = "/gis.Gis/BatchTransformCoord"
	Gis_RoutePoints_FullMethodName          = "/gis.Gis/RoutePoints"
)

// GisClient is the client API for Gis service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// GIS 相关服务
type GisClient interface {
	Ping(ctx context.Context, in *Req, opts ...grpc.CallOption) (*Res, error)
	// 编码 geohash
	EncodeGeoHash(ctx context.Context, in *EncodeGeoHashReq, opts ...grpc.CallOption) (*EncodeGeoHashRes, error)
	// 解码 geohash -> 经纬度
	DecodeGeoHash(ctx context.Context, in *DecodeGeoHashReq, opts ...grpc.CallOption) (*DecodeGeoHashRes, error)
	// 编码 h3
	EncodeH3(ctx context.Context, in *EncodeH3Req, opts ...grpc.CallOption) (*EncodeH3Res, error)
	// 解码 h3
	DecodeH3(ctx context.Context, in *DecodeH3Req, opts ...grpc.CallOption) (*DecodeH3Res, error)
	// 一次性生成围栏 cells（小围栏）
	GenerateFenceCells(ctx context.Context, in *GenFenceCellsReq, opts ...grpc.CallOption) (*GenFenceCellsRes, error)
	// 一次性生成围栏 H3 cells（小围栏）
	GenerateFenceH3Cells(ctx context.Context, in *GenFenceH3CellsReq, opts ...grpc.CallOption) (*GenFenceH3CellsRes, error)
	// 获取半径内的点
	PointsWithinRadius(ctx context.Context, in *PointsWithinRadiusReq, opts ...grpc.CallOption) (*PointsWithinRadiusRes, error)
	// 点是否命中电子围栏（单个）
	PointInFence(ctx context.Context, in *PointInFenceReq, opts ...grpc.CallOption) (*PointInFenceRes, error)
	// 点是否命中电子围栏（多个围栏）
	PointInFences(ctx context.Context, in *PointInFencesReq, opts ...grpc.CallOption) (*PointInFencesRes, error)
	// 计算两个点之间的距离（米）
	Distance(ctx context.Context, in *DistanceReq, opts ...grpc.CallOption) (*DistanceRes, error)
	// 批量计算两点之间的距离（米）
	BatchDistance(ctx context.Context, in *BatchDistanceReq, opts ...grpc.CallOption) (*BatchDistanceRes, error)
	// 获取某点附近多少 km 的围栏（粗过滤）
	NearbyFences(ctx context.Context, in *NearbyFencesReq, opts ...grpc.CallOption) (*NearbyFencesRes, error)
	// 单个坐标转换
	TransformCoord(ctx context.Context, in *TransformCoordReq, opts ...grpc.CallOption) (*TransformCoordRes, error)
	// 批量坐标转换
	BatchTransformCoord(ctx context.Context, in *BatchTransformCoordReq, opts ...grpc.CallOption) (*BatchTransformCoordRes, error)
	// 计算点集合的最优路径
	RoutePoints(ctx context.Context, in *RoutePointsReq, opts ...grpc.CallOption) (*RoutePointsRes, error)
}

type gisClient struct {
	cc grpc.ClientConnInterface
}

func NewGisClient(cc grpc.ClientConnInterface) GisClient {
	return &gisClient{cc}
}

func (c *gisClient) Ping(ctx context.Context, in *Req, opts ...grpc.CallOption) (*Res, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Res)
	err := c.cc.Invoke(ctx, Gis_Ping_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gisClient) EncodeGeoHash(ctx context.Context, in *EncodeGeoHashReq, opts ...grpc.CallOption) (*EncodeGeoHashRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EncodeGeoHashRes)
	err := c.cc.Invoke(ctx, Gis_EncodeGeoHash_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gisClient) DecodeGeoHash(ctx context.Context, in *DecodeGeoHashReq, opts ...grpc.CallOption) (*DecodeGeoHashRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DecodeGeoHashRes)
	err := c.cc.Invoke(ctx, Gis_DecodeGeoHash_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gisClient) EncodeH3(ctx context.Context, in *EncodeH3Req, opts ...grpc.CallOption) (*EncodeH3Res, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EncodeH3Res)
	err := c.cc.Invoke(ctx, Gis_EncodeH3_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gisClient) DecodeH3(ctx context.Context, in *DecodeH3Req, opts ...grpc.CallOption) (*DecodeH3Res, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DecodeH3Res)
	err := c.cc.Invoke(ctx, Gis_DecodeH3_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gisClient) GenerateFenceCells(ctx context.Context, in *GenFenceCellsReq, opts ...grpc.CallOption) (*GenFenceCellsRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GenFenceCellsRes)
	err := c.cc.Invoke(ctx, Gis_GenerateFenceCells_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gisClient) GenerateFenceH3Cells(ctx context.Context, in *GenFenceH3CellsReq, opts ...grpc.CallOption) (*GenFenceH3CellsRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GenFenceH3CellsRes)
	err := c.cc.Invoke(ctx, Gis_GenerateFenceH3Cells_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gisClient) PointsWithinRadius(ctx context.Context, in *PointsWithinRadiusReq, opts ...grpc.CallOption) (*PointsWithinRadiusRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PointsWithinRadiusRes)
	err := c.cc.Invoke(ctx, Gis_PointsWithinRadius_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gisClient) PointInFence(ctx context.Context, in *PointInFenceReq, opts ...grpc.CallOption) (*PointInFenceRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PointInFenceRes)
	err := c.cc.Invoke(ctx, Gis_PointInFence_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gisClient) PointInFences(ctx context.Context, in *PointInFencesReq, opts ...grpc.CallOption) (*PointInFencesRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PointInFencesRes)
	err := c.cc.Invoke(ctx, Gis_PointInFences_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gisClient) Distance(ctx context.Context, in *DistanceReq, opts ...grpc.CallOption) (*DistanceRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DistanceRes)
	err := c.cc.Invoke(ctx, Gis_Distance_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gisClient) BatchDistance(ctx context.Context, in *BatchDistanceReq, opts ...grpc.CallOption) (*BatchDistanceRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BatchDistanceRes)
	err := c.cc.Invoke(ctx, Gis_BatchDistance_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gisClient) NearbyFences(ctx context.Context, in *NearbyFencesReq, opts ...grpc.CallOption) (*NearbyFencesRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(NearbyFencesRes)
	err := c.cc.Invoke(ctx, Gis_NearbyFences_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gisClient) TransformCoord(ctx context.Context, in *TransformCoordReq, opts ...grpc.CallOption) (*TransformCoordRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TransformCoordRes)
	err := c.cc.Invoke(ctx, Gis_TransformCoord_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gisClient) BatchTransformCoord(ctx context.Context, in *BatchTransformCoordReq, opts ...grpc.CallOption) (*BatchTransformCoordRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BatchTransformCoordRes)
	err := c.cc.Invoke(ctx, Gis_BatchTransformCoord_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gisClient) RoutePoints(ctx context.Context, in *RoutePointsReq, opts ...grpc.CallOption) (*RoutePointsRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RoutePointsRes)
	err := c.cc.Invoke(ctx, Gis_RoutePoints_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GisServer is the server API for Gis service.
// All implementations must embed UnimplementedGisServer
// for forward compatibility.
//
// GIS 相关服务
type GisServer interface {
	Ping(context.Context, *Req) (*Res, error)
	// 编码 geohash
	EncodeGeoHash(context.Context, *EncodeGeoHashReq) (*EncodeGeoHashRes, error)
	// 解码 geohash -> 经纬度
	DecodeGeoHash(context.Context, *DecodeGeoHashReq) (*DecodeGeoHashRes, error)
	// 编码 h3
	EncodeH3(context.Context, *EncodeH3Req) (*EncodeH3Res, error)
	// 解码 h3
	DecodeH3(context.Context, *DecodeH3Req) (*DecodeH3Res, error)
	// 一次性生成围栏 cells（小围栏）
	GenerateFenceCells(context.Context, *GenFenceCellsReq) (*GenFenceCellsRes, error)
	// 一次性生成围栏 H3 cells（小围栏）
	GenerateFenceH3Cells(context.Context, *GenFenceH3CellsReq) (*GenFenceH3CellsRes, error)
	// 获取半径内的点
	PointsWithinRadius(context.Context, *PointsWithinRadiusReq) (*PointsWithinRadiusRes, error)
	// 点是否命中电子围栏（单个）
	PointInFence(context.Context, *PointInFenceReq) (*PointInFenceRes, error)
	// 点是否命中电子围栏（多个围栏）
	PointInFences(context.Context, *PointInFencesReq) (*PointInFencesRes, error)
	// 计算两个点之间的距离（米）
	Distance(context.Context, *DistanceReq) (*DistanceRes, error)
	// 批量计算两点之间的距离（米）
	BatchDistance(context.Context, *BatchDistanceReq) (*BatchDistanceRes, error)
	// 获取某点附近多少 km 的围栏（粗过滤）
	NearbyFences(context.Context, *NearbyFencesReq) (*NearbyFencesRes, error)
	// 单个坐标转换
	TransformCoord(context.Context, *TransformCoordReq) (*TransformCoordRes, error)
	// 批量坐标转换
	BatchTransformCoord(context.Context, *BatchTransformCoordReq) (*BatchTransformCoordRes, error)
	// 计算点集合的最优路径
	RoutePoints(context.Context, *RoutePointsReq) (*RoutePointsRes, error)
	mustEmbedUnimplementedGisServer()
}

// UnimplementedGisServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedGisServer struct{}

func (UnimplementedGisServer) Ping(context.Context, *Req) (*Res, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Ping not implemented")
}
func (UnimplementedGisServer) EncodeGeoHash(context.Context, *EncodeGeoHashReq) (*EncodeGeoHashRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EncodeGeoHash not implemented")
}
func (UnimplementedGisServer) DecodeGeoHash(context.Context, *DecodeGeoHashReq) (*DecodeGeoHashRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DecodeGeoHash not implemented")
}
func (UnimplementedGisServer) EncodeH3(context.Context, *EncodeH3Req) (*EncodeH3Res, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EncodeH3 not implemented")
}
func (UnimplementedGisServer) DecodeH3(context.Context, *DecodeH3Req) (*DecodeH3Res, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DecodeH3 not implemented")
}
func (UnimplementedGisServer) GenerateFenceCells(context.Context, *GenFenceCellsReq) (*GenFenceCellsRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateFenceCells not implemented")
}
func (UnimplementedGisServer) GenerateFenceH3Cells(context.Context, *GenFenceH3CellsReq) (*GenFenceH3CellsRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateFenceH3Cells not implemented")
}
func (UnimplementedGisServer) PointsWithinRadius(context.Context, *PointsWithinRadiusReq) (*PointsWithinRadiusRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PointsWithinRadius not implemented")
}
func (UnimplementedGisServer) PointInFence(context.Context, *PointInFenceReq) (*PointInFenceRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PointInFence not implemented")
}
func (UnimplementedGisServer) PointInFences(context.Context, *PointInFencesReq) (*PointInFencesRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PointInFences not implemented")
}
func (UnimplementedGisServer) Distance(context.Context, *DistanceReq) (*DistanceRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Distance not implemented")
}
func (UnimplementedGisServer) BatchDistance(context.Context, *BatchDistanceReq) (*BatchDistanceRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchDistance not implemented")
}
func (UnimplementedGisServer) NearbyFences(context.Context, *NearbyFencesReq) (*NearbyFencesRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NearbyFences not implemented")
}
func (UnimplementedGisServer) TransformCoord(context.Context, *TransformCoordReq) (*TransformCoordRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TransformCoord not implemented")
}
func (UnimplementedGisServer) BatchTransformCoord(context.Context, *BatchTransformCoordReq) (*BatchTransformCoordRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchTransformCoord not implemented")
}
func (UnimplementedGisServer) RoutePoints(context.Context, *RoutePointsReq) (*RoutePointsRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoutePoints not implemented")
}
func (UnimplementedGisServer) mustEmbedUnimplementedGisServer() {}
func (UnimplementedGisServer) testEmbeddedByValue()             {}

// UnsafeGisServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GisServer will
// result in compilation errors.
type UnsafeGisServer interface {
	mustEmbedUnimplementedGisServer()
}

func RegisterGisServer(s grpc.ServiceRegistrar, srv GisServer) {
	// If the following call pancis, it indicates UnimplementedGisServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Gis_ServiceDesc, srv)
}

func _Gis_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Req)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GisServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Gis_Ping_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GisServer).Ping(ctx, req.(*Req))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gis_EncodeGeoHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EncodeGeoHashReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GisServer).EncodeGeoHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Gis_EncodeGeoHash_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GisServer).EncodeGeoHash(ctx, req.(*EncodeGeoHashReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gis_DecodeGeoHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DecodeGeoHashReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GisServer).DecodeGeoHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Gis_DecodeGeoHash_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GisServer).DecodeGeoHash(ctx, req.(*DecodeGeoHashReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gis_EncodeH3_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EncodeH3Req)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GisServer).EncodeH3(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Gis_EncodeH3_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GisServer).EncodeH3(ctx, req.(*EncodeH3Req))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gis_DecodeH3_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DecodeH3Req)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GisServer).DecodeH3(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Gis_DecodeH3_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GisServer).DecodeH3(ctx, req.(*DecodeH3Req))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gis_GenerateFenceCells_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenFenceCellsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GisServer).GenerateFenceCells(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Gis_GenerateFenceCells_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GisServer).GenerateFenceCells(ctx, req.(*GenFenceCellsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gis_GenerateFenceH3Cells_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenFenceH3CellsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GisServer).GenerateFenceH3Cells(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Gis_GenerateFenceH3Cells_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GisServer).GenerateFenceH3Cells(ctx, req.(*GenFenceH3CellsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gis_PointsWithinRadius_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PointsWithinRadiusReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GisServer).PointsWithinRadius(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Gis_PointsWithinRadius_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GisServer).PointsWithinRadius(ctx, req.(*PointsWithinRadiusReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gis_PointInFence_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PointInFenceReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GisServer).PointInFence(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Gis_PointInFence_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GisServer).PointInFence(ctx, req.(*PointInFenceReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gis_PointInFences_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PointInFencesReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GisServer).PointInFences(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Gis_PointInFences_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GisServer).PointInFences(ctx, req.(*PointInFencesReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gis_Distance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DistanceReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GisServer).Distance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Gis_Distance_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GisServer).Distance(ctx, req.(*DistanceReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gis_BatchDistance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchDistanceReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GisServer).BatchDistance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Gis_BatchDistance_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GisServer).BatchDistance(ctx, req.(*BatchDistanceReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gis_NearbyFences_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NearbyFencesReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GisServer).NearbyFences(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Gis_NearbyFences_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GisServer).NearbyFences(ctx, req.(*NearbyFencesReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gis_TransformCoord_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TransformCoordReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GisServer).TransformCoord(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Gis_TransformCoord_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GisServer).TransformCoord(ctx, req.(*TransformCoordReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gis_BatchTransformCoord_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchTransformCoordReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GisServer).BatchTransformCoord(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Gis_BatchTransformCoord_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GisServer).BatchTransformCoord(ctx, req.(*BatchTransformCoordReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gis_RoutePoints_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoutePointsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GisServer).RoutePoints(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Gis_RoutePoints_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GisServer).RoutePoints(ctx, req.(*RoutePointsReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Gis_ServiceDesc is the grpc.ServiceDesc for Gis service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Gis_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "gis.Gis",
	HandlerType: (*GisServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Ping",
			Handler:    _Gis_Ping_Handler,
		},
		{
			MethodName: "EncodeGeoHash",
			Handler:    _Gis_EncodeGeoHash_Handler,
		},
		{
			MethodName: "DecodeGeoHash",
			Handler:    _Gis_DecodeGeoHash_Handler,
		},
		{
			MethodName: "EncodeH3",
			Handler:    _Gis_EncodeH3_Handler,
		},
		{
			MethodName: "DecodeH3",
			Handler:    _Gis_DecodeH3_Handler,
		},
		{
			MethodName: "GenerateFenceCells",
			Handler:    _Gis_GenerateFenceCells_Handler,
		},
		{
			MethodName: "GenerateFenceH3Cells",
			Handler:    _Gis_GenerateFenceH3Cells_Handler,
		},
		{
			MethodName: "PointsWithinRadius",
			Handler:    _Gis_PointsWithinRadius_Handler,
		},
		{
			MethodName: "PointInFence",
			Handler:    _Gis_PointInFence_Handler,
		},
		{
			MethodName: "PointInFences",
			Handler:    _Gis_PointInFences_Handler,
		},
		{
			MethodName: "Distance",
			Handler:    _Gis_Distance_Handler,
		},
		{
			MethodName: "BatchDistance",
			Handler:    _Gis_BatchDistance_Handler,
		},
		{
			MethodName: "NearbyFences",
			Handler:    _Gis_NearbyFences_Handler,
		},
		{
			MethodName: "TransformCoord",
			Handler:    _Gis_TransformCoord_Handler,
		},
		{
			MethodName: "BatchTransformCoord",
			Handler:    _Gis_BatchTransformCoord_Handler,
		},
		{
			MethodName: "RoutePoints",
			Handler:    _Gis_RoutePoints_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "gis.proto",
}
