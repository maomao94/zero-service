// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.29.3
// source: bridgemodbus.proto

package bridgemodbus

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	BridgeModbus_Ping_FullMethodName                       = "/bridgemodbus.BridgeModbus/Ping"
	BridgeModbus_SaveConfig_FullMethodName                 = "/bridgemodbus.BridgeModbus/SaveConfig"
	BridgeModbus_DeleteConfig_FullMethodName               = "/bridgemodbus.BridgeModbus/DeleteConfig"
	BridgeModbus_PageListConfig_FullMethodName             = "/bridgemodbus.BridgeModbus/PageListConfig"
	BridgeModbus_GetConfigByCode_FullMethodName            = "/bridgemodbus.BridgeModbus/GetConfigByCode"
	BridgeModbus_ReadCoils_FullMethodName                  = "/bridgemodbus.BridgeModbus/ReadCoils"
	BridgeModbus_ReadDiscreteInputs_FullMethodName         = "/bridgemodbus.BridgeModbus/ReadDiscreteInputs"
	BridgeModbus_WriteSingleCoil_FullMethodName            = "/bridgemodbus.BridgeModbus/WriteSingleCoil"
	BridgeModbus_WriteMultipleCoils_FullMethodName         = "/bridgemodbus.BridgeModbus/WriteMultipleCoils"
	BridgeModbus_ReadInputRegisters_FullMethodName         = "/bridgemodbus.BridgeModbus/ReadInputRegisters"
	BridgeModbus_ReadHoldingRegisters_FullMethodName       = "/bridgemodbus.BridgeModbus/ReadHoldingRegisters"
	BridgeModbus_WriteSingleRegister_FullMethodName        = "/bridgemodbus.BridgeModbus/WriteSingleRegister"
	BridgeModbus_WriteMultipleRegisters_FullMethodName     = "/bridgemodbus.BridgeModbus/WriteMultipleRegisters"
	BridgeModbus_ReadWriteMultipleRegisters_FullMethodName = "/bridgemodbus.BridgeModbus/ReadWriteMultipleRegisters"
	BridgeModbus_MaskWriteRegister_FullMethodName          = "/bridgemodbus.BridgeModbus/MaskWriteRegister"
	BridgeModbus_ReadFIFOQueue_FullMethodName              = "/bridgemodbus.BridgeModbus/ReadFIFOQueue"
	BridgeModbus_ReadDeviceIdentification_FullMethodName   = "/bridgemodbus.BridgeModbus/ReadDeviceIdentification"
)

// BridgeModbusClient is the client API for BridgeModbus service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Modbus 协议桥接服务
type BridgeModbusClient interface {
	Ping(ctx context.Context, in *Req, opts ...grpc.CallOption) (*Res, error)
	// 保存（新增或更新）配置
	SaveConfig(ctx context.Context, in *SaveConfigReq, opts ...grpc.CallOption) (*SaveConfigRes, error)
	// 删除配置（支持批量）
	DeleteConfig(ctx context.Context, in *DeleteConfigReq, opts ...grpc.CallOption) (*DeleteConfigRes, error)
	// 分页查询配置列表
	PageListConfig(ctx context.Context, in *PageListConfigReq, opts ...grpc.CallOption) (*PageListConfigRes, error)
	// 根据编码查询详情
	GetConfigByCode(ctx context.Context, in *GetConfigByCodeReq, opts ...grpc.CallOption) (*GetConfigByCodeRes, error)
	// 读取线圈状态 (Function Code 0x01)
	ReadCoils(ctx context.Context, in *ReadCoilsReq, opts ...grpc.CallOption) (*ReadCoilsRes, error)
	// 读取离散输入状态 (Function Code 0x02)
	ReadDiscreteInputs(ctx context.Context, in *ReadDiscreteInputsReq, opts ...grpc.CallOption) (*ReadDiscreteInputsRes, error)
	// 写单个线圈 (Function Code 0x05)
	WriteSingleCoil(ctx context.Context, in *WriteSingleCoilReq, opts ...grpc.CallOption) (*WriteSingleCoilRes, error)
	// 写多个线圈 (Function Code 0x0F)
	WriteMultipleCoils(ctx context.Context, in *WriteMultipleCoilsReq, opts ...grpc.CallOption) (*WriteMultipleCoilsRes, error)
	// 读取输入寄存器 (Function Code 0x04)
	ReadInputRegisters(ctx context.Context, in *ReadInputRegistersReq, opts ...grpc.CallOption) (*ReadInputRegistersRes, error)
	// 读取保持寄存器 (Function Code 0x03)
	ReadHoldingRegisters(ctx context.Context, in *ReadHoldingRegistersReq, opts ...grpc.CallOption) (*ReadHoldingRegistersRes, error)
	// 写单个保持寄存器 (Function Code 0x06)
	WriteSingleRegister(ctx context.Context, in *WriteSingleRegisterReq, opts ...grpc.CallOption) (*WriteSingleRegisterRes, error)
	// 写多个保持寄存器 (Function Code 0x10)
	WriteMultipleRegisters(ctx context.Context, in *WriteMultipleRegistersReq, opts ...grpc.CallOption) (*WriteMultipleRegistersRes, error)
	// 读写多个保持寄存器 (Function Code 0x17)
	ReadWriteMultipleRegisters(ctx context.Context, in *ReadWriteMultipleRegistersReq, opts ...grpc.CallOption) (*ReadWriteMultipleRegistersRes, error)
	// 屏蔽写保持寄存器 (Function Code 0x16)
	MaskWriteRegister(ctx context.Context, in *MaskWriteRegisterReq, opts ...grpc.CallOption) (*MaskWriteRegisterRes, error)
	// 读取 FIFO 队列 (Function Code 0x18)
	ReadFIFOQueue(ctx context.Context, in *ReadFIFOQueueReq, opts ...grpc.CallOption) (*ReadFIFOQueueRes, error)
	// 读取设备标识 (Function Code 0x2B / 0x0E)
	ReadDeviceIdentification(ctx context.Context, in *ReadDeviceIdentificationReq, opts ...grpc.CallOption) (*ReadDeviceIdentificationRes, error)
}

type bridgeModbusClient struct {
	cc grpc.ClientConnInterface
}

func NewBridgeModbusClient(cc grpc.ClientConnInterface) BridgeModbusClient {
	return &bridgeModbusClient{cc}
}

func (c *bridgeModbusClient) Ping(ctx context.Context, in *Req, opts ...grpc.CallOption) (*Res, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Res)
	err := c.cc.Invoke(ctx, BridgeModbus_Ping_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bridgeModbusClient) SaveConfig(ctx context.Context, in *SaveConfigReq, opts ...grpc.CallOption) (*SaveConfigRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SaveConfigRes)
	err := c.cc.Invoke(ctx, BridgeModbus_SaveConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bridgeModbusClient) DeleteConfig(ctx context.Context, in *DeleteConfigReq, opts ...grpc.CallOption) (*DeleteConfigRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteConfigRes)
	err := c.cc.Invoke(ctx, BridgeModbus_DeleteConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bridgeModbusClient) PageListConfig(ctx context.Context, in *PageListConfigReq, opts ...grpc.CallOption) (*PageListConfigRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PageListConfigRes)
	err := c.cc.Invoke(ctx, BridgeModbus_PageListConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bridgeModbusClient) GetConfigByCode(ctx context.Context, in *GetConfigByCodeReq, opts ...grpc.CallOption) (*GetConfigByCodeRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetConfigByCodeRes)
	err := c.cc.Invoke(ctx, BridgeModbus_GetConfigByCode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bridgeModbusClient) ReadCoils(ctx context.Context, in *ReadCoilsReq, opts ...grpc.CallOption) (*ReadCoilsRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReadCoilsRes)
	err := c.cc.Invoke(ctx, BridgeModbus_ReadCoils_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bridgeModbusClient) ReadDiscreteInputs(ctx context.Context, in *ReadDiscreteInputsReq, opts ...grpc.CallOption) (*ReadDiscreteInputsRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReadDiscreteInputsRes)
	err := c.cc.Invoke(ctx, BridgeModbus_ReadDiscreteInputs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bridgeModbusClient) WriteSingleCoil(ctx context.Context, in *WriteSingleCoilReq, opts ...grpc.CallOption) (*WriteSingleCoilRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WriteSingleCoilRes)
	err := c.cc.Invoke(ctx, BridgeModbus_WriteSingleCoil_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bridgeModbusClient) WriteMultipleCoils(ctx context.Context, in *WriteMultipleCoilsReq, opts ...grpc.CallOption) (*WriteMultipleCoilsRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WriteMultipleCoilsRes)
	err := c.cc.Invoke(ctx, BridgeModbus_WriteMultipleCoils_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bridgeModbusClient) ReadInputRegisters(ctx context.Context, in *ReadInputRegistersReq, opts ...grpc.CallOption) (*ReadInputRegistersRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReadInputRegistersRes)
	err := c.cc.Invoke(ctx, BridgeModbus_ReadInputRegisters_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bridgeModbusClient) ReadHoldingRegisters(ctx context.Context, in *ReadHoldingRegistersReq, opts ...grpc.CallOption) (*ReadHoldingRegistersRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReadHoldingRegistersRes)
	err := c.cc.Invoke(ctx, BridgeModbus_ReadHoldingRegisters_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bridgeModbusClient) WriteSingleRegister(ctx context.Context, in *WriteSingleRegisterReq, opts ...grpc.CallOption) (*WriteSingleRegisterRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WriteSingleRegisterRes)
	err := c.cc.Invoke(ctx, BridgeModbus_WriteSingleRegister_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bridgeModbusClient) WriteMultipleRegisters(ctx context.Context, in *WriteMultipleRegistersReq, opts ...grpc.CallOption) (*WriteMultipleRegistersRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WriteMultipleRegistersRes)
	err := c.cc.Invoke(ctx, BridgeModbus_WriteMultipleRegisters_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bridgeModbusClient) ReadWriteMultipleRegisters(ctx context.Context, in *ReadWriteMultipleRegistersReq, opts ...grpc.CallOption) (*ReadWriteMultipleRegistersRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReadWriteMultipleRegistersRes)
	err := c.cc.Invoke(ctx, BridgeModbus_ReadWriteMultipleRegisters_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bridgeModbusClient) MaskWriteRegister(ctx context.Context, in *MaskWriteRegisterReq, opts ...grpc.CallOption) (*MaskWriteRegisterRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MaskWriteRegisterRes)
	err := c.cc.Invoke(ctx, BridgeModbus_MaskWriteRegister_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bridgeModbusClient) ReadFIFOQueue(ctx context.Context, in *ReadFIFOQueueReq, opts ...grpc.CallOption) (*ReadFIFOQueueRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReadFIFOQueueRes)
	err := c.cc.Invoke(ctx, BridgeModbus_ReadFIFOQueue_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bridgeModbusClient) ReadDeviceIdentification(ctx context.Context, in *ReadDeviceIdentificationReq, opts ...grpc.CallOption) (*ReadDeviceIdentificationRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReadDeviceIdentificationRes)
	err := c.cc.Invoke(ctx, BridgeModbus_ReadDeviceIdentification_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BridgeModbusServer is the server API for BridgeModbus service.
// All implementations must embed UnimplementedBridgeModbusServer
// for forward compatibility.
//
// Modbus 协议桥接服务
type BridgeModbusServer interface {
	Ping(context.Context, *Req) (*Res, error)
	// 保存（新增或更新）配置
	SaveConfig(context.Context, *SaveConfigReq) (*SaveConfigRes, error)
	// 删除配置（支持批量）
	DeleteConfig(context.Context, *DeleteConfigReq) (*DeleteConfigRes, error)
	// 分页查询配置列表
	PageListConfig(context.Context, *PageListConfigReq) (*PageListConfigRes, error)
	// 根据编码查询详情
	GetConfigByCode(context.Context, *GetConfigByCodeReq) (*GetConfigByCodeRes, error)
	// 读取线圈状态 (Function Code 0x01)
	ReadCoils(context.Context, *ReadCoilsReq) (*ReadCoilsRes, error)
	// 读取离散输入状态 (Function Code 0x02)
	ReadDiscreteInputs(context.Context, *ReadDiscreteInputsReq) (*ReadDiscreteInputsRes, error)
	// 写单个线圈 (Function Code 0x05)
	WriteSingleCoil(context.Context, *WriteSingleCoilReq) (*WriteSingleCoilRes, error)
	// 写多个线圈 (Function Code 0x0F)
	WriteMultipleCoils(context.Context, *WriteMultipleCoilsReq) (*WriteMultipleCoilsRes, error)
	// 读取输入寄存器 (Function Code 0x04)
	ReadInputRegisters(context.Context, *ReadInputRegistersReq) (*ReadInputRegistersRes, error)
	// 读取保持寄存器 (Function Code 0x03)
	ReadHoldingRegisters(context.Context, *ReadHoldingRegistersReq) (*ReadHoldingRegistersRes, error)
	// 写单个保持寄存器 (Function Code 0x06)
	WriteSingleRegister(context.Context, *WriteSingleRegisterReq) (*WriteSingleRegisterRes, error)
	// 写多个保持寄存器 (Function Code 0x10)
	WriteMultipleRegisters(context.Context, *WriteMultipleRegistersReq) (*WriteMultipleRegistersRes, error)
	// 读写多个保持寄存器 (Function Code 0x17)
	ReadWriteMultipleRegisters(context.Context, *ReadWriteMultipleRegistersReq) (*ReadWriteMultipleRegistersRes, error)
	// 屏蔽写保持寄存器 (Function Code 0x16)
	MaskWriteRegister(context.Context, *MaskWriteRegisterReq) (*MaskWriteRegisterRes, error)
	// 读取 FIFO 队列 (Function Code 0x18)
	ReadFIFOQueue(context.Context, *ReadFIFOQueueReq) (*ReadFIFOQueueRes, error)
	// 读取设备标识 (Function Code 0x2B / 0x0E)
	ReadDeviceIdentification(context.Context, *ReadDeviceIdentificationReq) (*ReadDeviceIdentificationRes, error)
	mustEmbedUnimplementedBridgeModbusServer()
}

// UnimplementedBridgeModbusServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedBridgeModbusServer struct{}

func (UnimplementedBridgeModbusServer) Ping(context.Context, *Req) (*Res, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Ping not implemented")
}
func (UnimplementedBridgeModbusServer) SaveConfig(context.Context, *SaveConfigReq) (*SaveConfigRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SaveConfig not implemented")
}
func (UnimplementedBridgeModbusServer) DeleteConfig(context.Context, *DeleteConfigReq) (*DeleteConfigRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteConfig not implemented")
}
func (UnimplementedBridgeModbusServer) PageListConfig(context.Context, *PageListConfigReq) (*PageListConfigRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PageListConfig not implemented")
}
func (UnimplementedBridgeModbusServer) GetConfigByCode(context.Context, *GetConfigByCodeReq) (*GetConfigByCodeRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetConfigByCode not implemented")
}
func (UnimplementedBridgeModbusServer) ReadCoils(context.Context, *ReadCoilsReq) (*ReadCoilsRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadCoils not implemented")
}
func (UnimplementedBridgeModbusServer) ReadDiscreteInputs(context.Context, *ReadDiscreteInputsReq) (*ReadDiscreteInputsRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadDiscreteInputs not implemented")
}
func (UnimplementedBridgeModbusServer) WriteSingleCoil(context.Context, *WriteSingleCoilReq) (*WriteSingleCoilRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WriteSingleCoil not implemented")
}
func (UnimplementedBridgeModbusServer) WriteMultipleCoils(context.Context, *WriteMultipleCoilsReq) (*WriteMultipleCoilsRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WriteMultipleCoils not implemented")
}
func (UnimplementedBridgeModbusServer) ReadInputRegisters(context.Context, *ReadInputRegistersReq) (*ReadInputRegistersRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadInputRegisters not implemented")
}
func (UnimplementedBridgeModbusServer) ReadHoldingRegisters(context.Context, *ReadHoldingRegistersReq) (*ReadHoldingRegistersRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadHoldingRegisters not implemented")
}
func (UnimplementedBridgeModbusServer) WriteSingleRegister(context.Context, *WriteSingleRegisterReq) (*WriteSingleRegisterRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WriteSingleRegister not implemented")
}
func (UnimplementedBridgeModbusServer) WriteMultipleRegisters(context.Context, *WriteMultipleRegistersReq) (*WriteMultipleRegistersRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WriteMultipleRegisters not implemented")
}
func (UnimplementedBridgeModbusServer) ReadWriteMultipleRegisters(context.Context, *ReadWriteMultipleRegistersReq) (*ReadWriteMultipleRegistersRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadWriteMultipleRegisters not implemented")
}
func (UnimplementedBridgeModbusServer) MaskWriteRegister(context.Context, *MaskWriteRegisterReq) (*MaskWriteRegisterRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MaskWriteRegister not implemented")
}
func (UnimplementedBridgeModbusServer) ReadFIFOQueue(context.Context, *ReadFIFOQueueReq) (*ReadFIFOQueueRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadFIFOQueue not implemented")
}
func (UnimplementedBridgeModbusServer) ReadDeviceIdentification(context.Context, *ReadDeviceIdentificationReq) (*ReadDeviceIdentificationRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadDeviceIdentification not implemented")
}
func (UnimplementedBridgeModbusServer) mustEmbedUnimplementedBridgeModbusServer() {}
func (UnimplementedBridgeModbusServer) testEmbeddedByValue()                      {}

// UnsafeBridgeModbusServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BridgeModbusServer will
// result in compilation errors.
type UnsafeBridgeModbusServer interface {
	mustEmbedUnimplementedBridgeModbusServer()
}

func RegisterBridgeModbusServer(s grpc.ServiceRegistrar, srv BridgeModbusServer) {
	// If the following call pancis, it indicates UnimplementedBridgeModbusServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&BridgeModbus_ServiceDesc, srv)
}

func _BridgeModbus_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Req)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BridgeModbusServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BridgeModbus_Ping_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BridgeModbusServer).Ping(ctx, req.(*Req))
	}
	return interceptor(ctx, in, info, handler)
}

func _BridgeModbus_SaveConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SaveConfigReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BridgeModbusServer).SaveConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BridgeModbus_SaveConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BridgeModbusServer).SaveConfig(ctx, req.(*SaveConfigReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _BridgeModbus_DeleteConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteConfigReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BridgeModbusServer).DeleteConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BridgeModbus_DeleteConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BridgeModbusServer).DeleteConfig(ctx, req.(*DeleteConfigReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _BridgeModbus_PageListConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PageListConfigReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BridgeModbusServer).PageListConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BridgeModbus_PageListConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BridgeModbusServer).PageListConfig(ctx, req.(*PageListConfigReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _BridgeModbus_GetConfigByCode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetConfigByCodeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BridgeModbusServer).GetConfigByCode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BridgeModbus_GetConfigByCode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BridgeModbusServer).GetConfigByCode(ctx, req.(*GetConfigByCodeReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _BridgeModbus_ReadCoils_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadCoilsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BridgeModbusServer).ReadCoils(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BridgeModbus_ReadCoils_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BridgeModbusServer).ReadCoils(ctx, req.(*ReadCoilsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _BridgeModbus_ReadDiscreteInputs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadDiscreteInputsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BridgeModbusServer).ReadDiscreteInputs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BridgeModbus_ReadDiscreteInputs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BridgeModbusServer).ReadDiscreteInputs(ctx, req.(*ReadDiscreteInputsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _BridgeModbus_WriteSingleCoil_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WriteSingleCoilReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BridgeModbusServer).WriteSingleCoil(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BridgeModbus_WriteSingleCoil_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BridgeModbusServer).WriteSingleCoil(ctx, req.(*WriteSingleCoilReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _BridgeModbus_WriteMultipleCoils_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WriteMultipleCoilsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BridgeModbusServer).WriteMultipleCoils(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BridgeModbus_WriteMultipleCoils_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BridgeModbusServer).WriteMultipleCoils(ctx, req.(*WriteMultipleCoilsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _BridgeModbus_ReadInputRegisters_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadInputRegistersReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BridgeModbusServer).ReadInputRegisters(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BridgeModbus_ReadInputRegisters_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BridgeModbusServer).ReadInputRegisters(ctx, req.(*ReadInputRegistersReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _BridgeModbus_ReadHoldingRegisters_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadHoldingRegistersReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BridgeModbusServer).ReadHoldingRegisters(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BridgeModbus_ReadHoldingRegisters_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BridgeModbusServer).ReadHoldingRegisters(ctx, req.(*ReadHoldingRegistersReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _BridgeModbus_WriteSingleRegister_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WriteSingleRegisterReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BridgeModbusServer).WriteSingleRegister(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BridgeModbus_WriteSingleRegister_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BridgeModbusServer).WriteSingleRegister(ctx, req.(*WriteSingleRegisterReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _BridgeModbus_WriteMultipleRegisters_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WriteMultipleRegistersReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BridgeModbusServer).WriteMultipleRegisters(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BridgeModbus_WriteMultipleRegisters_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BridgeModbusServer).WriteMultipleRegisters(ctx, req.(*WriteMultipleRegistersReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _BridgeModbus_ReadWriteMultipleRegisters_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadWriteMultipleRegistersReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BridgeModbusServer).ReadWriteMultipleRegisters(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BridgeModbus_ReadWriteMultipleRegisters_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BridgeModbusServer).ReadWriteMultipleRegisters(ctx, req.(*ReadWriteMultipleRegistersReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _BridgeModbus_MaskWriteRegister_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MaskWriteRegisterReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BridgeModbusServer).MaskWriteRegister(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BridgeModbus_MaskWriteRegister_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BridgeModbusServer).MaskWriteRegister(ctx, req.(*MaskWriteRegisterReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _BridgeModbus_ReadFIFOQueue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadFIFOQueueReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BridgeModbusServer).ReadFIFOQueue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BridgeModbus_ReadFIFOQueue_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BridgeModbusServer).ReadFIFOQueue(ctx, req.(*ReadFIFOQueueReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _BridgeModbus_ReadDeviceIdentification_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadDeviceIdentificationReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BridgeModbusServer).ReadDeviceIdentification(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BridgeModbus_ReadDeviceIdentification_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BridgeModbusServer).ReadDeviceIdentification(ctx, req.(*ReadDeviceIdentificationReq))
	}
	return interceptor(ctx, in, info, handler)
}

// BridgeModbus_ServiceDesc is the grpc.ServiceDesc for BridgeModbus service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BridgeModbus_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "bridgemodbus.BridgeModbus",
	HandlerType: (*BridgeModbusServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Ping",
			Handler:    _BridgeModbus_Ping_Handler,
		},
		{
			MethodName: "SaveConfig",
			Handler:    _BridgeModbus_SaveConfig_Handler,
		},
		{
			MethodName: "DeleteConfig",
			Handler:    _BridgeModbus_DeleteConfig_Handler,
		},
		{
			MethodName: "PageListConfig",
			Handler:    _BridgeModbus_PageListConfig_Handler,
		},
		{
			MethodName: "GetConfigByCode",
			Handler:    _BridgeModbus_GetConfigByCode_Handler,
		},
		{
			MethodName: "ReadCoils",
			Handler:    _BridgeModbus_ReadCoils_Handler,
		},
		{
			MethodName: "ReadDiscreteInputs",
			Handler:    _BridgeModbus_ReadDiscreteInputs_Handler,
		},
		{
			MethodName: "WriteSingleCoil",
			Handler:    _BridgeModbus_WriteSingleCoil_Handler,
		},
		{
			MethodName: "WriteMultipleCoils",
			Handler:    _BridgeModbus_WriteMultipleCoils_Handler,
		},
		{
			MethodName: "ReadInputRegisters",
			Handler:    _BridgeModbus_ReadInputRegisters_Handler,
		},
		{
			MethodName: "ReadHoldingRegisters",
			Handler:    _BridgeModbus_ReadHoldingRegisters_Handler,
		},
		{
			MethodName: "WriteSingleRegister",
			Handler:    _BridgeModbus_WriteSingleRegister_Handler,
		},
		{
			MethodName: "WriteMultipleRegisters",
			Handler:    _BridgeModbus_WriteMultipleRegisters_Handler,
		},
		{
			MethodName: "ReadWriteMultipleRegisters",
			Handler:    _BridgeModbus_ReadWriteMultipleRegisters_Handler,
		},
		{
			MethodName: "MaskWriteRegister",
			Handler:    _BridgeModbus_MaskWriteRegister_Handler,
		},
		{
			MethodName: "ReadFIFOQueue",
			Handler:    _BridgeModbus_ReadFIFOQueue_Handler,
		},
		{
			MethodName: "ReadDeviceIdentification",
			Handler:    _BridgeModbus_ReadDeviceIdentification_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "bridgemodbus.proto",
}
