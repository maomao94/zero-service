// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: trigger.proto

package trigger

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on PbTaskInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PbTaskInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PbTaskInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PbTaskInfoMultiError, or
// nil if none found.
func (m *PbTaskInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *PbTaskInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Queue

	// no validation rules for Type

	// no validation rules for Payload

	// no validation rules for State

	// no validation rules for MaxRetry

	// no validation rules for Retried

	// no validation rules for LastErr

	// no validation rules for LastFailedAt

	// no validation rules for Timeout

	// no validation rules for Deadline

	// no validation rules for Group

	// no validation rules for NextProcessAt

	// no validation rules for IsOrphaned

	// no validation rules for Retention

	// no validation rules for CompletedAt

	// no validation rules for Result

	if len(errors) > 0 {
		return PbTaskInfoMultiError(errors)
	}

	return nil
}

// PbTaskInfoMultiError is an error wrapping multiple validation errors
// returned by PbTaskInfo.ValidateAll() if the designated constraints aren't met.
type PbTaskInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PbTaskInfoMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PbTaskInfoMultiError) AllErrors() []error { return m }

// PbTaskInfoValidationError is the validation error returned by
// PbTaskInfo.Validate if the designated constraints aren't met.
type PbTaskInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PbTaskInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PbTaskInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PbTaskInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PbTaskInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PbTaskInfoValidationError) ErrorName() string { return "PbTaskInfoValidationError" }

// Error satisfies the builtin error interface
func (e PbTaskInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPbTaskInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PbTaskInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PbTaskInfoValidationError{}

// Validate checks the field values on PbDailyStats with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PbDailyStats) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PbDailyStats with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PbDailyStatsMultiError, or
// nil if none found.
func (m *PbDailyStats) ValidateAll() error {
	return m.validate(true)
}

func (m *PbDailyStats) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Queue

	// no validation rules for Processed

	// no validation rules for Failed

	// no validation rules for Date

	if len(errors) > 0 {
		return PbDailyStatsMultiError(errors)
	}

	return nil
}

// PbDailyStatsMultiError is an error wrapping multiple validation errors
// returned by PbDailyStats.ValidateAll() if the designated constraints aren't met.
type PbDailyStatsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PbDailyStatsMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PbDailyStatsMultiError) AllErrors() []error { return m }

// PbDailyStatsValidationError is the validation error returned by
// PbDailyStats.Validate if the designated constraints aren't met.
type PbDailyStatsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PbDailyStatsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PbDailyStatsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PbDailyStatsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PbDailyStatsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PbDailyStatsValidationError) ErrorName() string { return "PbDailyStatsValidationError" }

// Error satisfies the builtin error interface
func (e PbDailyStatsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPbDailyStats.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PbDailyStatsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PbDailyStatsValidationError{}

// Validate checks the field values on PbQueueInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PbQueueInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PbQueueInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PbQueueInfoMultiError, or
// nil if none found.
func (m *PbQueueInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *PbQueueInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Queue

	// no validation rules for MemoryUsage

	// no validation rules for Latency

	// no validation rules for Size

	// no validation rules for Groups

	// no validation rules for Pending

	// no validation rules for Active

	// no validation rules for Scheduled

	// no validation rules for Retry

	// no validation rules for Archived

	// no validation rules for Completed

	// no validation rules for Aggregating

	// no validation rules for Processed

	// no validation rules for Failed

	// no validation rules for ProcessedTotal

	// no validation rules for FailedTotal

	// no validation rules for Paused

	// no validation rules for Timestamp

	if len(errors) > 0 {
		return PbQueueInfoMultiError(errors)
	}

	return nil
}

// PbQueueInfoMultiError is an error wrapping multiple validation errors
// returned by PbQueueInfo.ValidateAll() if the designated constraints aren't met.
type PbQueueInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PbQueueInfoMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PbQueueInfoMultiError) AllErrors() []error { return m }

// PbQueueInfoValidationError is the validation error returned by
// PbQueueInfo.Validate if the designated constraints aren't met.
type PbQueueInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PbQueueInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PbQueueInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PbQueueInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PbQueueInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PbQueueInfoValidationError) ErrorName() string { return "PbQueueInfoValidationError" }

// Error satisfies the builtin error interface
func (e PbQueueInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPbQueueInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PbQueueInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PbQueueInfoValidationError{}

// Validate checks the field values on Req with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Req) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Req with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ReqMultiError, or nil if none found.
func (m *Req) ValidateAll() error {
	return m.validate(true)
}

func (m *Req) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Ping

	if len(errors) > 0 {
		return ReqMultiError(errors)
	}

	return nil
}

// ReqMultiError is an error wrapping multiple validation errors returned by
// Req.ValidateAll() if the designated constraints aren't met.
type ReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReqMultiError) AllErrors() []error { return m }

// ReqValidationError is the validation error returned by Req.Validate if the
// designated constraints aren't met.
type ReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReqValidationError) ErrorName() string { return "ReqValidationError" }

// Error satisfies the builtin error interface
func (e ReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReqValidationError{}

// Validate checks the field values on Res with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Res) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Res with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ResMultiError, or nil if none found.
func (m *Res) ValidateAll() error {
	return m.validate(true)
}

func (m *Res) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Pong

	if len(errors) > 0 {
		return ResMultiError(errors)
	}

	return nil
}

// ResMultiError is an error wrapping multiple validation errors returned by
// Res.ValidateAll() if the designated constraints aren't met.
type ResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResMultiError) AllErrors() []error { return m }

// ResValidationError is the validation error returned by Res.Validate if the
// designated constraints aren't met.
type ResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResValidationError) ErrorName() string { return "ResValidationError" }

// Error satisfies the builtin error interface
func (e ResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResValidationError{}

// Validate checks the field values on SendTriggerReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SendTriggerReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SendTriggerReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SendTriggerReqMultiError,
// or nil if none found.
func (m *SendTriggerReq) ValidateAll() error {
	return m.validate(true)
}

func (m *SendTriggerReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCurrentUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SendTriggerReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SendTriggerReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrentUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SendTriggerReqValidationError{
				field:  "CurrentUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ProcessIn

	// no validation rules for TriggerTime

	// no validation rules for Url

	// no validation rules for MaxRetry

	// no validation rules for MsgId

	// no validation rules for Body

	if len(errors) > 0 {
		return SendTriggerReqMultiError(errors)
	}

	return nil
}

// SendTriggerReqMultiError is an error wrapping multiple validation errors
// returned by SendTriggerReq.ValidateAll() if the designated constraints
// aren't met.
type SendTriggerReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SendTriggerReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SendTriggerReqMultiError) AllErrors() []error { return m }

// SendTriggerReqValidationError is the validation error returned by
// SendTriggerReq.Validate if the designated constraints aren't met.
type SendTriggerReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SendTriggerReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SendTriggerReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SendTriggerReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SendTriggerReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SendTriggerReqValidationError) ErrorName() string { return "SendTriggerReqValidationError" }

// Error satisfies the builtin error interface
func (e SendTriggerReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSendTriggerReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SendTriggerReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SendTriggerReqValidationError{}

// Validate checks the field values on SendTriggerRes with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SendTriggerRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SendTriggerRes with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SendTriggerResMultiError,
// or nil if none found.
func (m *SendTriggerRes) ValidateAll() error {
	return m.validate(true)
}

func (m *SendTriggerRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TraceId

	// no validation rules for Queue

	// no validation rules for Id

	if len(errors) > 0 {
		return SendTriggerResMultiError(errors)
	}

	return nil
}

// SendTriggerResMultiError is an error wrapping multiple validation errors
// returned by SendTriggerRes.ValidateAll() if the designated constraints
// aren't met.
type SendTriggerResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SendTriggerResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SendTriggerResMultiError) AllErrors() []error { return m }

// SendTriggerResValidationError is the validation error returned by
// SendTriggerRes.Validate if the designated constraints aren't met.
type SendTriggerResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SendTriggerResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SendTriggerResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SendTriggerResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SendTriggerResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SendTriggerResValidationError) ErrorName() string { return "SendTriggerResValidationError" }

// Error satisfies the builtin error interface
func (e SendTriggerResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSendTriggerRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SendTriggerResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SendTriggerResValidationError{}

// Validate checks the field values on SendProtoTriggerReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SendProtoTriggerReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SendProtoTriggerReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SendProtoTriggerReqMultiError, or nil if none found.
func (m *SendProtoTriggerReq) ValidateAll() error {
	return m.validate(true)
}

func (m *SendProtoTriggerReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCurrentUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SendProtoTriggerReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SendProtoTriggerReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrentUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SendProtoTriggerReqValidationError{
				field:  "CurrentUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ProcessIn

	// no validation rules for TriggerTime

	// no validation rules for MaxRetry

	// no validation rules for MsgId

	// no validation rules for GrpcServer

	// no validation rules for Method

	// no validation rules for Payload

	// no validation rules for RequestTimeout

	if len(errors) > 0 {
		return SendProtoTriggerReqMultiError(errors)
	}

	return nil
}

// SendProtoTriggerReqMultiError is an error wrapping multiple validation
// errors returned by SendProtoTriggerReq.ValidateAll() if the designated
// constraints aren't met.
type SendProtoTriggerReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SendProtoTriggerReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SendProtoTriggerReqMultiError) AllErrors() []error { return m }

// SendProtoTriggerReqValidationError is the validation error returned by
// SendProtoTriggerReq.Validate if the designated constraints aren't met.
type SendProtoTriggerReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SendProtoTriggerReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SendProtoTriggerReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SendProtoTriggerReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SendProtoTriggerReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SendProtoTriggerReqValidationError) ErrorName() string {
	return "SendProtoTriggerReqValidationError"
}

// Error satisfies the builtin error interface
func (e SendProtoTriggerReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSendProtoTriggerReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SendProtoTriggerReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SendProtoTriggerReqValidationError{}

// Validate checks the field values on SendProtoTriggerRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SendProtoTriggerRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SendProtoTriggerRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SendProtoTriggerResMultiError, or nil if none found.
func (m *SendProtoTriggerRes) ValidateAll() error {
	return m.validate(true)
}

func (m *SendProtoTriggerRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TraceId

	// no validation rules for Queue

	// no validation rules for Id

	if len(errors) > 0 {
		return SendProtoTriggerResMultiError(errors)
	}

	return nil
}

// SendProtoTriggerResMultiError is an error wrapping multiple validation
// errors returned by SendProtoTriggerRes.ValidateAll() if the designated
// constraints aren't met.
type SendProtoTriggerResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SendProtoTriggerResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SendProtoTriggerResMultiError) AllErrors() []error { return m }

// SendProtoTriggerResValidationError is the validation error returned by
// SendProtoTriggerRes.Validate if the designated constraints aren't met.
type SendProtoTriggerResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SendProtoTriggerResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SendProtoTriggerResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SendProtoTriggerResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SendProtoTriggerResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SendProtoTriggerResValidationError) ErrorName() string {
	return "SendProtoTriggerResValidationError"
}

// Error satisfies the builtin error interface
func (e SendProtoTriggerResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSendProtoTriggerRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SendProtoTriggerResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SendProtoTriggerResValidationError{}

// Validate checks the field values on QueuesReq with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *QueuesReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueuesReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in QueuesReqMultiError, or nil
// if none found.
func (m *QueuesReq) ValidateAll() error {
	return m.validate(true)
}

func (m *QueuesReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCurrentUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, QueuesReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, QueuesReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrentUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return QueuesReqValidationError{
				field:  "CurrentUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return QueuesReqMultiError(errors)
	}

	return nil
}

// QueuesReqMultiError is an error wrapping multiple validation errors returned
// by QueuesReq.ValidateAll() if the designated constraints aren't met.
type QueuesReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueuesReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueuesReqMultiError) AllErrors() []error { return m }

// QueuesReqValidationError is the validation error returned by
// QueuesReq.Validate if the designated constraints aren't met.
type QueuesReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueuesReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueuesReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueuesReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueuesReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueuesReqValidationError) ErrorName() string { return "QueuesReqValidationError" }

// Error satisfies the builtin error interface
func (e QueuesReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueuesReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueuesReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueuesReqValidationError{}

// Validate checks the field values on QueuesRes with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *QueuesRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueuesRes with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in QueuesResMultiError, or nil
// if none found.
func (m *QueuesRes) ValidateAll() error {
	return m.validate(true)
}

func (m *QueuesRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return QueuesResMultiError(errors)
	}

	return nil
}

// QueuesResMultiError is an error wrapping multiple validation errors returned
// by QueuesRes.ValidateAll() if the designated constraints aren't met.
type QueuesResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueuesResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueuesResMultiError) AllErrors() []error { return m }

// QueuesResValidationError is the validation error returned by
// QueuesRes.Validate if the designated constraints aren't met.
type QueuesResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueuesResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueuesResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueuesResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueuesResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueuesResValidationError) ErrorName() string { return "QueuesResValidationError" }

// Error satisfies the builtin error interface
func (e QueuesResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueuesRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueuesResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueuesResValidationError{}

// Validate checks the field values on GetQueueInfoReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetQueueInfoReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetQueueInfoReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetQueueInfoReqMultiError, or nil if none found.
func (m *GetQueueInfoReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetQueueInfoReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCurrentUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetQueueInfoReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetQueueInfoReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrentUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetQueueInfoReqValidationError{
				field:  "CurrentUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if utf8.RuneCountInString(m.GetQueue()) < 1 {
		err := GetQueueInfoReqValidationError{
			field:  "Queue",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetQueueInfoReqMultiError(errors)
	}

	return nil
}

// GetQueueInfoReqMultiError is an error wrapping multiple validation errors
// returned by GetQueueInfoReq.ValidateAll() if the designated constraints
// aren't met.
type GetQueueInfoReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetQueueInfoReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetQueueInfoReqMultiError) AllErrors() []error { return m }

// GetQueueInfoReqValidationError is the validation error returned by
// GetQueueInfoReq.Validate if the designated constraints aren't met.
type GetQueueInfoReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetQueueInfoReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetQueueInfoReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetQueueInfoReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetQueueInfoReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetQueueInfoReqValidationError) ErrorName() string { return "GetQueueInfoReqValidationError" }

// Error satisfies the builtin error interface
func (e GetQueueInfoReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetQueueInfoReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetQueueInfoReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetQueueInfoReqValidationError{}

// Validate checks the field values on GetQueueInfoRes with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetQueueInfoRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetQueueInfoRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetQueueInfoResMultiError, or nil if none found.
func (m *GetQueueInfoRes) ValidateAll() error {
	return m.validate(true)
}

func (m *GetQueueInfoRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetQueueInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetQueueInfoResValidationError{
					field:  "QueueInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetQueueInfoResValidationError{
					field:  "QueueInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetQueueInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetQueueInfoResValidationError{
				field:  "QueueInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetQueueInfoResMultiError(errors)
	}

	return nil
}

// GetQueueInfoResMultiError is an error wrapping multiple validation errors
// returned by GetQueueInfoRes.ValidateAll() if the designated constraints
// aren't met.
type GetQueueInfoResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetQueueInfoResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetQueueInfoResMultiError) AllErrors() []error { return m }

// GetQueueInfoResValidationError is the validation error returned by
// GetQueueInfoRes.Validate if the designated constraints aren't met.
type GetQueueInfoResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetQueueInfoResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetQueueInfoResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetQueueInfoResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetQueueInfoResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetQueueInfoResValidationError) ErrorName() string { return "GetQueueInfoResValidationError" }

// Error satisfies the builtin error interface
func (e GetQueueInfoResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetQueueInfoRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetQueueInfoResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetQueueInfoResValidationError{}

// Validate checks the field values on ArchiveTaskReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ArchiveTaskReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ArchiveTaskReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ArchiveTaskReqMultiError,
// or nil if none found.
func (m *ArchiveTaskReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ArchiveTaskReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCurrentUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ArchiveTaskReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ArchiveTaskReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrentUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ArchiveTaskReqValidationError{
				field:  "CurrentUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if utf8.RuneCountInString(m.GetQueue()) < 1 {
		err := ArchiveTaskReqValidationError{
			field:  "Queue",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetId()) < 1 {
		err := ArchiveTaskReqValidationError{
			field:  "Id",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ArchiveTaskReqMultiError(errors)
	}

	return nil
}

// ArchiveTaskReqMultiError is an error wrapping multiple validation errors
// returned by ArchiveTaskReq.ValidateAll() if the designated constraints
// aren't met.
type ArchiveTaskReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ArchiveTaskReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ArchiveTaskReqMultiError) AllErrors() []error { return m }

// ArchiveTaskReqValidationError is the validation error returned by
// ArchiveTaskReq.Validate if the designated constraints aren't met.
type ArchiveTaskReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ArchiveTaskReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ArchiveTaskReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ArchiveTaskReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ArchiveTaskReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ArchiveTaskReqValidationError) ErrorName() string { return "ArchiveTaskReqValidationError" }

// Error satisfies the builtin error interface
func (e ArchiveTaskReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sArchiveTaskReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ArchiveTaskReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ArchiveTaskReqValidationError{}

// Validate checks the field values on ArchiveTaskRes with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ArchiveTaskRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ArchiveTaskRes with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ArchiveTaskResMultiError,
// or nil if none found.
func (m *ArchiveTaskRes) ValidateAll() error {
	return m.validate(true)
}

func (m *ArchiveTaskRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ArchiveTaskResMultiError(errors)
	}

	return nil
}

// ArchiveTaskResMultiError is an error wrapping multiple validation errors
// returned by ArchiveTaskRes.ValidateAll() if the designated constraints
// aren't met.
type ArchiveTaskResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ArchiveTaskResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ArchiveTaskResMultiError) AllErrors() []error { return m }

// ArchiveTaskResValidationError is the validation error returned by
// ArchiveTaskRes.Validate if the designated constraints aren't met.
type ArchiveTaskResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ArchiveTaskResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ArchiveTaskResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ArchiveTaskResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ArchiveTaskResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ArchiveTaskResValidationError) ErrorName() string { return "ArchiveTaskResValidationError" }

// Error satisfies the builtin error interface
func (e ArchiveTaskResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sArchiveTaskRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ArchiveTaskResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ArchiveTaskResValidationError{}

// Validate checks the field values on DeleteTaskReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DeleteTaskReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteTaskReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DeleteTaskReqMultiError, or
// nil if none found.
func (m *DeleteTaskReq) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteTaskReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCurrentUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteTaskReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteTaskReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrentUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteTaskReqValidationError{
				field:  "CurrentUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if utf8.RuneCountInString(m.GetQueue()) < 1 {
		err := DeleteTaskReqValidationError{
			field:  "Queue",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetId()) < 1 {
		err := DeleteTaskReqValidationError{
			field:  "Id",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteTaskReqMultiError(errors)
	}

	return nil
}

// DeleteTaskReqMultiError is an error wrapping multiple validation errors
// returned by DeleteTaskReq.ValidateAll() if the designated constraints
// aren't met.
type DeleteTaskReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteTaskReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteTaskReqMultiError) AllErrors() []error { return m }

// DeleteTaskReqValidationError is the validation error returned by
// DeleteTaskReq.Validate if the designated constraints aren't met.
type DeleteTaskReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteTaskReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteTaskReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteTaskReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteTaskReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteTaskReqValidationError) ErrorName() string { return "DeleteTaskReqValidationError" }

// Error satisfies the builtin error interface
func (e DeleteTaskReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteTaskReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteTaskReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteTaskReqValidationError{}

// Validate checks the field values on DeleteTaskRes with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DeleteTaskRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteTaskRes with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DeleteTaskResMultiError, or
// nil if none found.
func (m *DeleteTaskRes) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteTaskRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DeleteTaskResMultiError(errors)
	}

	return nil
}

// DeleteTaskResMultiError is an error wrapping multiple validation errors
// returned by DeleteTaskRes.ValidateAll() if the designated constraints
// aren't met.
type DeleteTaskResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteTaskResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteTaskResMultiError) AllErrors() []error { return m }

// DeleteTaskResValidationError is the validation error returned by
// DeleteTaskRes.Validate if the designated constraints aren't met.
type DeleteTaskResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteTaskResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteTaskResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteTaskResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteTaskResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteTaskResValidationError) ErrorName() string { return "DeleteTaskResValidationError" }

// Error satisfies the builtin error interface
func (e DeleteTaskResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteTaskRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteTaskResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteTaskResValidationError{}

// Validate checks the field values on GetTaskInfoReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetTaskInfoReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTaskInfoReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetTaskInfoReqMultiError,
// or nil if none found.
func (m *GetTaskInfoReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTaskInfoReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCurrentUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetTaskInfoReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetTaskInfoReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrentUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetTaskInfoReqValidationError{
				field:  "CurrentUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if utf8.RuneCountInString(m.GetQueue()) < 1 {
		err := GetTaskInfoReqValidationError{
			field:  "Queue",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetId()) < 1 {
		err := GetTaskInfoReqValidationError{
			field:  "Id",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetTaskInfoReqMultiError(errors)
	}

	return nil
}

// GetTaskInfoReqMultiError is an error wrapping multiple validation errors
// returned by GetTaskInfoReq.ValidateAll() if the designated constraints
// aren't met.
type GetTaskInfoReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTaskInfoReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTaskInfoReqMultiError) AllErrors() []error { return m }

// GetTaskInfoReqValidationError is the validation error returned by
// GetTaskInfoReq.Validate if the designated constraints aren't met.
type GetTaskInfoReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTaskInfoReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTaskInfoReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTaskInfoReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTaskInfoReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTaskInfoReqValidationError) ErrorName() string { return "GetTaskInfoReqValidationError" }

// Error satisfies the builtin error interface
func (e GetTaskInfoReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTaskInfoReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTaskInfoReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTaskInfoReqValidationError{}

// Validate checks the field values on GetTaskInfoRes with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetTaskInfoRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTaskInfoRes with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetTaskInfoResMultiError,
// or nil if none found.
func (m *GetTaskInfoRes) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTaskInfoRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTaskInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetTaskInfoResValidationError{
					field:  "TaskInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetTaskInfoResValidationError{
					field:  "TaskInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTaskInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetTaskInfoResValidationError{
				field:  "TaskInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetTaskInfoResMultiError(errors)
	}

	return nil
}

// GetTaskInfoResMultiError is an error wrapping multiple validation errors
// returned by GetTaskInfoRes.ValidateAll() if the designated constraints
// aren't met.
type GetTaskInfoResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTaskInfoResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTaskInfoResMultiError) AllErrors() []error { return m }

// GetTaskInfoResValidationError is the validation error returned by
// GetTaskInfoRes.Validate if the designated constraints aren't met.
type GetTaskInfoResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTaskInfoResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTaskInfoResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTaskInfoResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTaskInfoResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTaskInfoResValidationError) ErrorName() string { return "GetTaskInfoResValidationError" }

// Error satisfies the builtin error interface
func (e GetTaskInfoResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTaskInfoRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTaskInfoResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTaskInfoResValidationError{}

// Validate checks the field values on DeleteAllCompletedTasksReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteAllCompletedTasksReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteAllCompletedTasksReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteAllCompletedTasksReqMultiError, or nil if none found.
func (m *DeleteAllCompletedTasksReq) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteAllCompletedTasksReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCurrentUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteAllCompletedTasksReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteAllCompletedTasksReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrentUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteAllCompletedTasksReqValidationError{
				field:  "CurrentUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if utf8.RuneCountInString(m.GetQueue()) < 1 {
		err := DeleteAllCompletedTasksReqValidationError{
			field:  "Queue",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteAllCompletedTasksReqMultiError(errors)
	}

	return nil
}

// DeleteAllCompletedTasksReqMultiError is an error wrapping multiple
// validation errors returned by DeleteAllCompletedTasksReq.ValidateAll() if
// the designated constraints aren't met.
type DeleteAllCompletedTasksReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteAllCompletedTasksReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteAllCompletedTasksReqMultiError) AllErrors() []error { return m }

// DeleteAllCompletedTasksReqValidationError is the validation error returned
// by DeleteAllCompletedTasksReq.Validate if the designated constraints aren't met.
type DeleteAllCompletedTasksReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteAllCompletedTasksReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteAllCompletedTasksReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteAllCompletedTasksReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteAllCompletedTasksReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteAllCompletedTasksReqValidationError) ErrorName() string {
	return "DeleteAllCompletedTasksReqValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteAllCompletedTasksReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteAllCompletedTasksReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteAllCompletedTasksReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteAllCompletedTasksReqValidationError{}

// Validate checks the field values on DeleteAllCompletedTasksRes with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteAllCompletedTasksRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteAllCompletedTasksRes with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteAllCompletedTasksResMultiError, or nil if none found.
func (m *DeleteAllCompletedTasksRes) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteAllCompletedTasksRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Count

	if len(errors) > 0 {
		return DeleteAllCompletedTasksResMultiError(errors)
	}

	return nil
}

// DeleteAllCompletedTasksResMultiError is an error wrapping multiple
// validation errors returned by DeleteAllCompletedTasksRes.ValidateAll() if
// the designated constraints aren't met.
type DeleteAllCompletedTasksResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteAllCompletedTasksResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteAllCompletedTasksResMultiError) AllErrors() []error { return m }

// DeleteAllCompletedTasksResValidationError is the validation error returned
// by DeleteAllCompletedTasksRes.Validate if the designated constraints aren't met.
type DeleteAllCompletedTasksResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteAllCompletedTasksResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteAllCompletedTasksResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteAllCompletedTasksResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteAllCompletedTasksResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteAllCompletedTasksResValidationError) ErrorName() string {
	return "DeleteAllCompletedTasksResValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteAllCompletedTasksResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteAllCompletedTasksRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteAllCompletedTasksResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteAllCompletedTasksResValidationError{}

// Validate checks the field values on DeleteAllArchivedTasksReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteAllArchivedTasksReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteAllArchivedTasksReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteAllArchivedTasksReqMultiError, or nil if none found.
func (m *DeleteAllArchivedTasksReq) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteAllArchivedTasksReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCurrentUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteAllArchivedTasksReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteAllArchivedTasksReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrentUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteAllArchivedTasksReqValidationError{
				field:  "CurrentUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if utf8.RuneCountInString(m.GetQueue()) < 1 {
		err := DeleteAllArchivedTasksReqValidationError{
			field:  "Queue",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteAllArchivedTasksReqMultiError(errors)
	}

	return nil
}

// DeleteAllArchivedTasksReqMultiError is an error wrapping multiple validation
// errors returned by DeleteAllArchivedTasksReq.ValidateAll() if the
// designated constraints aren't met.
type DeleteAllArchivedTasksReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteAllArchivedTasksReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteAllArchivedTasksReqMultiError) AllErrors() []error { return m }

// DeleteAllArchivedTasksReqValidationError is the validation error returned by
// DeleteAllArchivedTasksReq.Validate if the designated constraints aren't met.
type DeleteAllArchivedTasksReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteAllArchivedTasksReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteAllArchivedTasksReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteAllArchivedTasksReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteAllArchivedTasksReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteAllArchivedTasksReqValidationError) ErrorName() string {
	return "DeleteAllArchivedTasksReqValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteAllArchivedTasksReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteAllArchivedTasksReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteAllArchivedTasksReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteAllArchivedTasksReqValidationError{}

// Validate checks the field values on DeleteAllArchivedTasksRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteAllArchivedTasksRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteAllArchivedTasksRes with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteAllArchivedTasksResMultiError, or nil if none found.
func (m *DeleteAllArchivedTasksRes) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteAllArchivedTasksRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Count

	if len(errors) > 0 {
		return DeleteAllArchivedTasksResMultiError(errors)
	}

	return nil
}

// DeleteAllArchivedTasksResMultiError is an error wrapping multiple validation
// errors returned by DeleteAllArchivedTasksRes.ValidateAll() if the
// designated constraints aren't met.
type DeleteAllArchivedTasksResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteAllArchivedTasksResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteAllArchivedTasksResMultiError) AllErrors() []error { return m }

// DeleteAllArchivedTasksResValidationError is the validation error returned by
// DeleteAllArchivedTasksRes.Validate if the designated constraints aren't met.
type DeleteAllArchivedTasksResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteAllArchivedTasksResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteAllArchivedTasksResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteAllArchivedTasksResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteAllArchivedTasksResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteAllArchivedTasksResValidationError) ErrorName() string {
	return "DeleteAllArchivedTasksResValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteAllArchivedTasksResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteAllArchivedTasksRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteAllArchivedTasksResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteAllArchivedTasksResValidationError{}

// Validate checks the field values on HistoricalStatsReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *HistoricalStatsReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HistoricalStatsReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HistoricalStatsReqMultiError, or nil if none found.
func (m *HistoricalStatsReq) ValidateAll() error {
	return m.validate(true)
}

func (m *HistoricalStatsReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCurrentUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HistoricalStatsReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HistoricalStatsReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrentUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HistoricalStatsReqValidationError{
				field:  "CurrentUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if utf8.RuneCountInString(m.GetQueue()) < 1 {
		err := HistoricalStatsReqValidationError{
			field:  "Queue",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetN(); val < 1 || val > 90 {
		err := HistoricalStatsReqValidationError{
			field:  "N",
			reason: "value must be inside range [1, 90]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return HistoricalStatsReqMultiError(errors)
	}

	return nil
}

// HistoricalStatsReqMultiError is an error wrapping multiple validation errors
// returned by HistoricalStatsReq.ValidateAll() if the designated constraints
// aren't met.
type HistoricalStatsReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HistoricalStatsReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HistoricalStatsReqMultiError) AllErrors() []error { return m }

// HistoricalStatsReqValidationError is the validation error returned by
// HistoricalStatsReq.Validate if the designated constraints aren't met.
type HistoricalStatsReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HistoricalStatsReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HistoricalStatsReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HistoricalStatsReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HistoricalStatsReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HistoricalStatsReqValidationError) ErrorName() string {
	return "HistoricalStatsReqValidationError"
}

// Error satisfies the builtin error interface
func (e HistoricalStatsReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHistoricalStatsReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HistoricalStatsReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HistoricalStatsReqValidationError{}

// Validate checks the field values on HistoricalStatsRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *HistoricalStatsRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HistoricalStatsRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HistoricalStatsResMultiError, or nil if none found.
func (m *HistoricalStatsRes) ValidateAll() error {
	return m.validate(true)
}

func (m *HistoricalStatsRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetDailyStat() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, HistoricalStatsResValidationError{
						field:  fmt.Sprintf("DailyStat[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, HistoricalStatsResValidationError{
						field:  fmt.Sprintf("DailyStat[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return HistoricalStatsResValidationError{
					field:  fmt.Sprintf("DailyStat[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return HistoricalStatsResMultiError(errors)
	}

	return nil
}

// HistoricalStatsResMultiError is an error wrapping multiple validation errors
// returned by HistoricalStatsRes.ValidateAll() if the designated constraints
// aren't met.
type HistoricalStatsResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HistoricalStatsResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HistoricalStatsResMultiError) AllErrors() []error { return m }

// HistoricalStatsResValidationError is the validation error returned by
// HistoricalStatsRes.Validate if the designated constraints aren't met.
type HistoricalStatsResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HistoricalStatsResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HistoricalStatsResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HistoricalStatsResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HistoricalStatsResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HistoricalStatsResValidationError) ErrorName() string {
	return "HistoricalStatsResValidationError"
}

// Error satisfies the builtin error interface
func (e HistoricalStatsResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHistoricalStatsRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HistoricalStatsResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HistoricalStatsResValidationError{}

// Validate checks the field values on ListActiveTasksReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListActiveTasksReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListActiveTasksReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListActiveTasksReqMultiError, or nil if none found.
func (m *ListActiveTasksReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListActiveTasksReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCurrentUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListActiveTasksReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListActiveTasksReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrentUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListActiveTasksReqValidationError{
				field:  "CurrentUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetPageSize() < 0 {
		err := ListActiveTasksReqValidationError{
			field:  "PageSize",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetPageNum() < 0 {
		err := ListActiveTasksReqValidationError{
			field:  "PageNum",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetQueue()) < 1 {
		err := ListActiveTasksReqValidationError{
			field:  "Queue",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListActiveTasksReqMultiError(errors)
	}

	return nil
}

// ListActiveTasksReqMultiError is an error wrapping multiple validation errors
// returned by ListActiveTasksReq.ValidateAll() if the designated constraints
// aren't met.
type ListActiveTasksReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListActiveTasksReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListActiveTasksReqMultiError) AllErrors() []error { return m }

// ListActiveTasksReqValidationError is the validation error returned by
// ListActiveTasksReq.Validate if the designated constraints aren't met.
type ListActiveTasksReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListActiveTasksReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListActiveTasksReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListActiveTasksReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListActiveTasksReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListActiveTasksReqValidationError) ErrorName() string {
	return "ListActiveTasksReqValidationError"
}

// Error satisfies the builtin error interface
func (e ListActiveTasksReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListActiveTasksReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListActiveTasksReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListActiveTasksReqValidationError{}

// Validate checks the field values on ListActiveTasksRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListActiveTasksRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListActiveTasksRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListActiveTasksResMultiError, or nil if none found.
func (m *ListActiveTasksRes) ValidateAll() error {
	return m.validate(true)
}

func (m *ListActiveTasksRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetQueueInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListActiveTasksResValidationError{
					field:  "QueueInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListActiveTasksResValidationError{
					field:  "QueueInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetQueueInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListActiveTasksResValidationError{
				field:  "QueueInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetTasksInfo() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListActiveTasksResValidationError{
						field:  fmt.Sprintf("TasksInfo[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListActiveTasksResValidationError{
						field:  fmt.Sprintf("TasksInfo[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListActiveTasksResValidationError{
					field:  fmt.Sprintf("TasksInfo[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListActiveTasksResMultiError(errors)
	}

	return nil
}

// ListActiveTasksResMultiError is an error wrapping multiple validation errors
// returned by ListActiveTasksRes.ValidateAll() if the designated constraints
// aren't met.
type ListActiveTasksResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListActiveTasksResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListActiveTasksResMultiError) AllErrors() []error { return m }

// ListActiveTasksResValidationError is the validation error returned by
// ListActiveTasksRes.Validate if the designated constraints aren't met.
type ListActiveTasksResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListActiveTasksResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListActiveTasksResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListActiveTasksResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListActiveTasksResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListActiveTasksResValidationError) ErrorName() string {
	return "ListActiveTasksResValidationError"
}

// Error satisfies the builtin error interface
func (e ListActiveTasksResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListActiveTasksRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListActiveTasksResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListActiveTasksResValidationError{}

// Validate checks the field values on ListPendingTasksReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListPendingTasksReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListPendingTasksReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListPendingTasksReqMultiError, or nil if none found.
func (m *ListPendingTasksReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListPendingTasksReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCurrentUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListPendingTasksReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListPendingTasksReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrentUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListPendingTasksReqValidationError{
				field:  "CurrentUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetPageSize() < 0 {
		err := ListPendingTasksReqValidationError{
			field:  "PageSize",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetPageNum() < 0 {
		err := ListPendingTasksReqValidationError{
			field:  "PageNum",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetQueue()) < 1 {
		err := ListPendingTasksReqValidationError{
			field:  "Queue",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListPendingTasksReqMultiError(errors)
	}

	return nil
}

// ListPendingTasksReqMultiError is an error wrapping multiple validation
// errors returned by ListPendingTasksReq.ValidateAll() if the designated
// constraints aren't met.
type ListPendingTasksReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListPendingTasksReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListPendingTasksReqMultiError) AllErrors() []error { return m }

// ListPendingTasksReqValidationError is the validation error returned by
// ListPendingTasksReq.Validate if the designated constraints aren't met.
type ListPendingTasksReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListPendingTasksReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListPendingTasksReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListPendingTasksReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListPendingTasksReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListPendingTasksReqValidationError) ErrorName() string {
	return "ListPendingTasksReqValidationError"
}

// Error satisfies the builtin error interface
func (e ListPendingTasksReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListPendingTasksReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListPendingTasksReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListPendingTasksReqValidationError{}

// Validate checks the field values on ListPendingTasksRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListPendingTasksRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListPendingTasksRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListPendingTasksResMultiError, or nil if none found.
func (m *ListPendingTasksRes) ValidateAll() error {
	return m.validate(true)
}

func (m *ListPendingTasksRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetQueueInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListPendingTasksResValidationError{
					field:  "QueueInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListPendingTasksResValidationError{
					field:  "QueueInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetQueueInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListPendingTasksResValidationError{
				field:  "QueueInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetTasksInfo() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListPendingTasksResValidationError{
						field:  fmt.Sprintf("TasksInfo[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListPendingTasksResValidationError{
						field:  fmt.Sprintf("TasksInfo[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListPendingTasksResValidationError{
					field:  fmt.Sprintf("TasksInfo[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListPendingTasksResMultiError(errors)
	}

	return nil
}

// ListPendingTasksResMultiError is an error wrapping multiple validation
// errors returned by ListPendingTasksRes.ValidateAll() if the designated
// constraints aren't met.
type ListPendingTasksResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListPendingTasksResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListPendingTasksResMultiError) AllErrors() []error { return m }

// ListPendingTasksResValidationError is the validation error returned by
// ListPendingTasksRes.Validate if the designated constraints aren't met.
type ListPendingTasksResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListPendingTasksResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListPendingTasksResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListPendingTasksResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListPendingTasksResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListPendingTasksResValidationError) ErrorName() string {
	return "ListPendingTasksResValidationError"
}

// Error satisfies the builtin error interface
func (e ListPendingTasksResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListPendingTasksRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListPendingTasksResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListPendingTasksResValidationError{}

// Validate checks the field values on ListAggregatingTasksReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListAggregatingTasksReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListAggregatingTasksReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListAggregatingTasksReqMultiError, or nil if none found.
func (m *ListAggregatingTasksReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListAggregatingTasksReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCurrentUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListAggregatingTasksReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListAggregatingTasksReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrentUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListAggregatingTasksReqValidationError{
				field:  "CurrentUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetPageSize() < 0 {
		err := ListAggregatingTasksReqValidationError{
			field:  "PageSize",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetPageNum() < 0 {
		err := ListAggregatingTasksReqValidationError{
			field:  "PageNum",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetQueue()) < 1 {
		err := ListAggregatingTasksReqValidationError{
			field:  "Queue",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetGroup()) < 1 {
		err := ListAggregatingTasksReqValidationError{
			field:  "Group",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListAggregatingTasksReqMultiError(errors)
	}

	return nil
}

// ListAggregatingTasksReqMultiError is an error wrapping multiple validation
// errors returned by ListAggregatingTasksReq.ValidateAll() if the designated
// constraints aren't met.
type ListAggregatingTasksReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListAggregatingTasksReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListAggregatingTasksReqMultiError) AllErrors() []error { return m }

// ListAggregatingTasksReqValidationError is the validation error returned by
// ListAggregatingTasksReq.Validate if the designated constraints aren't met.
type ListAggregatingTasksReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListAggregatingTasksReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListAggregatingTasksReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListAggregatingTasksReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListAggregatingTasksReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListAggregatingTasksReqValidationError) ErrorName() string {
	return "ListAggregatingTasksReqValidationError"
}

// Error satisfies the builtin error interface
func (e ListAggregatingTasksReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListAggregatingTasksReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListAggregatingTasksReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListAggregatingTasksReqValidationError{}

// Validate checks the field values on ListAggregatingTasksRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListAggregatingTasksRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListAggregatingTasksRes with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListAggregatingTasksResMultiError, or nil if none found.
func (m *ListAggregatingTasksRes) ValidateAll() error {
	return m.validate(true)
}

func (m *ListAggregatingTasksRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetQueueInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListAggregatingTasksResValidationError{
					field:  "QueueInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListAggregatingTasksResValidationError{
					field:  "QueueInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetQueueInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListAggregatingTasksResValidationError{
				field:  "QueueInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetTasksInfo() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListAggregatingTasksResValidationError{
						field:  fmt.Sprintf("TasksInfo[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListAggregatingTasksResValidationError{
						field:  fmt.Sprintf("TasksInfo[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListAggregatingTasksResValidationError{
					field:  fmt.Sprintf("TasksInfo[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListAggregatingTasksResMultiError(errors)
	}

	return nil
}

// ListAggregatingTasksResMultiError is an error wrapping multiple validation
// errors returned by ListAggregatingTasksRes.ValidateAll() if the designated
// constraints aren't met.
type ListAggregatingTasksResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListAggregatingTasksResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListAggregatingTasksResMultiError) AllErrors() []error { return m }

// ListAggregatingTasksResValidationError is the validation error returned by
// ListAggregatingTasksRes.Validate if the designated constraints aren't met.
type ListAggregatingTasksResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListAggregatingTasksResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListAggregatingTasksResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListAggregatingTasksResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListAggregatingTasksResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListAggregatingTasksResValidationError) ErrorName() string {
	return "ListAggregatingTasksResValidationError"
}

// Error satisfies the builtin error interface
func (e ListAggregatingTasksResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListAggregatingTasksRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListAggregatingTasksResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListAggregatingTasksResValidationError{}

// Validate checks the field values on ListScheduledTasksReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListScheduledTasksReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListScheduledTasksReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListScheduledTasksReqMultiError, or nil if none found.
func (m *ListScheduledTasksReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListScheduledTasksReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCurrentUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListScheduledTasksReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListScheduledTasksReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrentUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListScheduledTasksReqValidationError{
				field:  "CurrentUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetPageSize() < 0 {
		err := ListScheduledTasksReqValidationError{
			field:  "PageSize",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetPageNum() < 0 {
		err := ListScheduledTasksReqValidationError{
			field:  "PageNum",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetQueue()) < 1 {
		err := ListScheduledTasksReqValidationError{
			field:  "Queue",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListScheduledTasksReqMultiError(errors)
	}

	return nil
}

// ListScheduledTasksReqMultiError is an error wrapping multiple validation
// errors returned by ListScheduledTasksReq.ValidateAll() if the designated
// constraints aren't met.
type ListScheduledTasksReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListScheduledTasksReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListScheduledTasksReqMultiError) AllErrors() []error { return m }

// ListScheduledTasksReqValidationError is the validation error returned by
// ListScheduledTasksReq.Validate if the designated constraints aren't met.
type ListScheduledTasksReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListScheduledTasksReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListScheduledTasksReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListScheduledTasksReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListScheduledTasksReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListScheduledTasksReqValidationError) ErrorName() string {
	return "ListScheduledTasksReqValidationError"
}

// Error satisfies the builtin error interface
func (e ListScheduledTasksReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListScheduledTasksReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListScheduledTasksReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListScheduledTasksReqValidationError{}

// Validate checks the field values on ListScheduledTasksRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListScheduledTasksRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListScheduledTasksRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListScheduledTasksResMultiError, or nil if none found.
func (m *ListScheduledTasksRes) ValidateAll() error {
	return m.validate(true)
}

func (m *ListScheduledTasksRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetQueueInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListScheduledTasksResValidationError{
					field:  "QueueInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListScheduledTasksResValidationError{
					field:  "QueueInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetQueueInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListScheduledTasksResValidationError{
				field:  "QueueInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetTasksInfo() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListScheduledTasksResValidationError{
						field:  fmt.Sprintf("TasksInfo[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListScheduledTasksResValidationError{
						field:  fmt.Sprintf("TasksInfo[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListScheduledTasksResValidationError{
					field:  fmt.Sprintf("TasksInfo[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListScheduledTasksResMultiError(errors)
	}

	return nil
}

// ListScheduledTasksResMultiError is an error wrapping multiple validation
// errors returned by ListScheduledTasksRes.ValidateAll() if the designated
// constraints aren't met.
type ListScheduledTasksResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListScheduledTasksResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListScheduledTasksResMultiError) AllErrors() []error { return m }

// ListScheduledTasksResValidationError is the validation error returned by
// ListScheduledTasksRes.Validate if the designated constraints aren't met.
type ListScheduledTasksResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListScheduledTasksResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListScheduledTasksResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListScheduledTasksResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListScheduledTasksResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListScheduledTasksResValidationError) ErrorName() string {
	return "ListScheduledTasksResValidationError"
}

// Error satisfies the builtin error interface
func (e ListScheduledTasksResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListScheduledTasksRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListScheduledTasksResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListScheduledTasksResValidationError{}

// Validate checks the field values on ListRetryTasksReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListRetryTasksReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListRetryTasksReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListRetryTasksReqMultiError, or nil if none found.
func (m *ListRetryTasksReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListRetryTasksReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCurrentUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListRetryTasksReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListRetryTasksReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrentUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListRetryTasksReqValidationError{
				field:  "CurrentUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetPageSize() < 0 {
		err := ListRetryTasksReqValidationError{
			field:  "PageSize",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetPageNum() < 0 {
		err := ListRetryTasksReqValidationError{
			field:  "PageNum",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetQueue()) < 1 {
		err := ListRetryTasksReqValidationError{
			field:  "Queue",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListRetryTasksReqMultiError(errors)
	}

	return nil
}

// ListRetryTasksReqMultiError is an error wrapping multiple validation errors
// returned by ListRetryTasksReq.ValidateAll() if the designated constraints
// aren't met.
type ListRetryTasksReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListRetryTasksReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListRetryTasksReqMultiError) AllErrors() []error { return m }

// ListRetryTasksReqValidationError is the validation error returned by
// ListRetryTasksReq.Validate if the designated constraints aren't met.
type ListRetryTasksReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListRetryTasksReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListRetryTasksReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListRetryTasksReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListRetryTasksReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListRetryTasksReqValidationError) ErrorName() string {
	return "ListRetryTasksReqValidationError"
}

// Error satisfies the builtin error interface
func (e ListRetryTasksReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListRetryTasksReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListRetryTasksReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListRetryTasksReqValidationError{}

// Validate checks the field values on ListRetryTasksRes with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListRetryTasksRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListRetryTasksRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListRetryTasksResMultiError, or nil if none found.
func (m *ListRetryTasksRes) ValidateAll() error {
	return m.validate(true)
}

func (m *ListRetryTasksRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetQueueInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListRetryTasksResValidationError{
					field:  "QueueInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListRetryTasksResValidationError{
					field:  "QueueInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetQueueInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListRetryTasksResValidationError{
				field:  "QueueInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetTasksInfo() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListRetryTasksResValidationError{
						field:  fmt.Sprintf("TasksInfo[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListRetryTasksResValidationError{
						field:  fmt.Sprintf("TasksInfo[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListRetryTasksResValidationError{
					field:  fmt.Sprintf("TasksInfo[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListRetryTasksResMultiError(errors)
	}

	return nil
}

// ListRetryTasksResMultiError is an error wrapping multiple validation errors
// returned by ListRetryTasksRes.ValidateAll() if the designated constraints
// aren't met.
type ListRetryTasksResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListRetryTasksResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListRetryTasksResMultiError) AllErrors() []error { return m }

// ListRetryTasksResValidationError is the validation error returned by
// ListRetryTasksRes.Validate if the designated constraints aren't met.
type ListRetryTasksResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListRetryTasksResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListRetryTasksResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListRetryTasksResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListRetryTasksResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListRetryTasksResValidationError) ErrorName() string {
	return "ListRetryTasksResValidationError"
}

// Error satisfies the builtin error interface
func (e ListRetryTasksResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListRetryTasksRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListRetryTasksResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListRetryTasksResValidationError{}

// Validate checks the field values on ListArchivedTasksReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListArchivedTasksReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListArchivedTasksReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListArchivedTasksReqMultiError, or nil if none found.
func (m *ListArchivedTasksReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListArchivedTasksReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCurrentUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListArchivedTasksReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListArchivedTasksReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrentUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListArchivedTasksReqValidationError{
				field:  "CurrentUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetPageSize() < 0 {
		err := ListArchivedTasksReqValidationError{
			field:  "PageSize",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetPageNum() < 0 {
		err := ListArchivedTasksReqValidationError{
			field:  "PageNum",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetQueue()) < 1 {
		err := ListArchivedTasksReqValidationError{
			field:  "Queue",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListArchivedTasksReqMultiError(errors)
	}

	return nil
}

// ListArchivedTasksReqMultiError is an error wrapping multiple validation
// errors returned by ListArchivedTasksReq.ValidateAll() if the designated
// constraints aren't met.
type ListArchivedTasksReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListArchivedTasksReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListArchivedTasksReqMultiError) AllErrors() []error { return m }

// ListArchivedTasksReqValidationError is the validation error returned by
// ListArchivedTasksReq.Validate if the designated constraints aren't met.
type ListArchivedTasksReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListArchivedTasksReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListArchivedTasksReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListArchivedTasksReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListArchivedTasksReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListArchivedTasksReqValidationError) ErrorName() string {
	return "ListArchivedTasksReqValidationError"
}

// Error satisfies the builtin error interface
func (e ListArchivedTasksReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListArchivedTasksReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListArchivedTasksReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListArchivedTasksReqValidationError{}

// Validate checks the field values on ListArchivedTasksRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListArchivedTasksRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListArchivedTasksRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListArchivedTasksResMultiError, or nil if none found.
func (m *ListArchivedTasksRes) ValidateAll() error {
	return m.validate(true)
}

func (m *ListArchivedTasksRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetQueueInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListArchivedTasksResValidationError{
					field:  "QueueInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListArchivedTasksResValidationError{
					field:  "QueueInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetQueueInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListArchivedTasksResValidationError{
				field:  "QueueInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetTasksInfo() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListArchivedTasksResValidationError{
						field:  fmt.Sprintf("TasksInfo[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListArchivedTasksResValidationError{
						field:  fmt.Sprintf("TasksInfo[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListArchivedTasksResValidationError{
					field:  fmt.Sprintf("TasksInfo[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListArchivedTasksResMultiError(errors)
	}

	return nil
}

// ListArchivedTasksResMultiError is an error wrapping multiple validation
// errors returned by ListArchivedTasksRes.ValidateAll() if the designated
// constraints aren't met.
type ListArchivedTasksResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListArchivedTasksResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListArchivedTasksResMultiError) AllErrors() []error { return m }

// ListArchivedTasksResValidationError is the validation error returned by
// ListArchivedTasksRes.Validate if the designated constraints aren't met.
type ListArchivedTasksResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListArchivedTasksResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListArchivedTasksResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListArchivedTasksResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListArchivedTasksResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListArchivedTasksResValidationError) ErrorName() string {
	return "ListArchivedTasksResValidationError"
}

// Error satisfies the builtin error interface
func (e ListArchivedTasksResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListArchivedTasksRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListArchivedTasksResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListArchivedTasksResValidationError{}

// Validate checks the field values on ListCompletedTasksReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListCompletedTasksReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListCompletedTasksReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListCompletedTasksReqMultiError, or nil if none found.
func (m *ListCompletedTasksReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListCompletedTasksReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCurrentUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListCompletedTasksReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListCompletedTasksReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrentUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListCompletedTasksReqValidationError{
				field:  "CurrentUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetPageSize() < 0 {
		err := ListCompletedTasksReqValidationError{
			field:  "PageSize",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetPageNum() < 0 {
		err := ListCompletedTasksReqValidationError{
			field:  "PageNum",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetQueue()) < 1 {
		err := ListCompletedTasksReqValidationError{
			field:  "Queue",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListCompletedTasksReqMultiError(errors)
	}

	return nil
}

// ListCompletedTasksReqMultiError is an error wrapping multiple validation
// errors returned by ListCompletedTasksReq.ValidateAll() if the designated
// constraints aren't met.
type ListCompletedTasksReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCompletedTasksReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCompletedTasksReqMultiError) AllErrors() []error { return m }

// ListCompletedTasksReqValidationError is the validation error returned by
// ListCompletedTasksReq.Validate if the designated constraints aren't met.
type ListCompletedTasksReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCompletedTasksReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCompletedTasksReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCompletedTasksReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCompletedTasksReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCompletedTasksReqValidationError) ErrorName() string {
	return "ListCompletedTasksReqValidationError"
}

// Error satisfies the builtin error interface
func (e ListCompletedTasksReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCompletedTasksReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCompletedTasksReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCompletedTasksReqValidationError{}

// Validate checks the field values on ListCompletedTasksRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListCompletedTasksRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListCompletedTasksRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListCompletedTasksResMultiError, or nil if none found.
func (m *ListCompletedTasksRes) ValidateAll() error {
	return m.validate(true)
}

func (m *ListCompletedTasksRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetQueueInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListCompletedTasksResValidationError{
					field:  "QueueInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListCompletedTasksResValidationError{
					field:  "QueueInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetQueueInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListCompletedTasksResValidationError{
				field:  "QueueInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetTasksInfo() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListCompletedTasksResValidationError{
						field:  fmt.Sprintf("TasksInfo[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListCompletedTasksResValidationError{
						field:  fmt.Sprintf("TasksInfo[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListCompletedTasksResValidationError{
					field:  fmt.Sprintf("TasksInfo[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListCompletedTasksResMultiError(errors)
	}

	return nil
}

// ListCompletedTasksResMultiError is an error wrapping multiple validation
// errors returned by ListCompletedTasksRes.ValidateAll() if the designated
// constraints aren't met.
type ListCompletedTasksResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCompletedTasksResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCompletedTasksResMultiError) AllErrors() []error { return m }

// ListCompletedTasksResValidationError is the validation error returned by
// ListCompletedTasksRes.Validate if the designated constraints aren't met.
type ListCompletedTasksResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCompletedTasksResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCompletedTasksResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCompletedTasksResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCompletedTasksResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCompletedTasksResValidationError) ErrorName() string {
	return "ListCompletedTasksResValidationError"
}

// Error satisfies the builtin error interface
func (e ListCompletedTasksResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCompletedTasksRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCompletedTasksResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCompletedTasksResValidationError{}

// Validate checks the field values on RunTaskReq with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RunTaskReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RunTaskReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RunTaskReqMultiError, or
// nil if none found.
func (m *RunTaskReq) ValidateAll() error {
	return m.validate(true)
}

func (m *RunTaskReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCurrentUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RunTaskReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RunTaskReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrentUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RunTaskReqValidationError{
				field:  "CurrentUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if utf8.RuneCountInString(m.GetQueue()) < 1 {
		err := RunTaskReqValidationError{
			field:  "Queue",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetId()) < 1 {
		err := RunTaskReqValidationError{
			field:  "Id",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return RunTaskReqMultiError(errors)
	}

	return nil
}

// RunTaskReqMultiError is an error wrapping multiple validation errors
// returned by RunTaskReq.ValidateAll() if the designated constraints aren't met.
type RunTaskReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RunTaskReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RunTaskReqMultiError) AllErrors() []error { return m }

// RunTaskReqValidationError is the validation error returned by
// RunTaskReq.Validate if the designated constraints aren't met.
type RunTaskReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RunTaskReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RunTaskReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RunTaskReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RunTaskReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RunTaskReqValidationError) ErrorName() string { return "RunTaskReqValidationError" }

// Error satisfies the builtin error interface
func (e RunTaskReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRunTaskReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RunTaskReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RunTaskReqValidationError{}

// Validate checks the field values on RunTaskRes with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RunTaskRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RunTaskRes with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RunTaskResMultiError, or
// nil if none found.
func (m *RunTaskRes) ValidateAll() error {
	return m.validate(true)
}

func (m *RunTaskRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return RunTaskResMultiError(errors)
	}

	return nil
}

// RunTaskResMultiError is an error wrapping multiple validation errors
// returned by RunTaskRes.ValidateAll() if the designated constraints aren't met.
type RunTaskResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RunTaskResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RunTaskResMultiError) AllErrors() []error { return m }

// RunTaskResValidationError is the validation error returned by
// RunTaskRes.Validate if the designated constraints aren't met.
type RunTaskResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RunTaskResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RunTaskResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RunTaskResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RunTaskResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RunTaskResValidationError) ErrorName() string { return "RunTaskResValidationError" }

// Error satisfies the builtin error interface
func (e RunTaskResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRunTaskRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RunTaskResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RunTaskResValidationError{}

// Validate checks the field values on CalcPlanTaskDateReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CalcPlanTaskDateReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CalcPlanTaskDateReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CalcPlanTaskDateReqMultiError, or nil if none found.
func (m *CalcPlanTaskDateReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CalcPlanTaskDateReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCurrentUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CalcPlanTaskDateReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CalcPlanTaskDateReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrentUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CalcPlanTaskDateReqValidationError{
				field:  "CurrentUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for StartTime

	// no validation rules for EndTime

	if m.GetRule() == nil {
		err := CalcPlanTaskDateReqValidationError{
			field:  "Rule",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetRule()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CalcPlanTaskDateReqValidationError{
					field:  "Rule",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CalcPlanTaskDateReqValidationError{
					field:  "Rule",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRule()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CalcPlanTaskDateReqValidationError{
				field:  "Rule",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetExcludeDates() {
		_, _ = idx, item

		if utf8.RuneCountInString(item) < 1 {
			err := CalcPlanTaskDateReqValidationError{
				field:  fmt.Sprintf("ExcludeDates[%v]", idx),
				reason: "value length must be at least 1 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return CalcPlanTaskDateReqMultiError(errors)
	}

	return nil
}

// CalcPlanTaskDateReqMultiError is an error wrapping multiple validation
// errors returned by CalcPlanTaskDateReq.ValidateAll() if the designated
// constraints aren't met.
type CalcPlanTaskDateReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CalcPlanTaskDateReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CalcPlanTaskDateReqMultiError) AllErrors() []error { return m }

// CalcPlanTaskDateReqValidationError is the validation error returned by
// CalcPlanTaskDateReq.Validate if the designated constraints aren't met.
type CalcPlanTaskDateReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CalcPlanTaskDateReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CalcPlanTaskDateReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CalcPlanTaskDateReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CalcPlanTaskDateReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CalcPlanTaskDateReqValidationError) ErrorName() string {
	return "CalcPlanTaskDateReqValidationError"
}

// Error satisfies the builtin error interface
func (e CalcPlanTaskDateReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCalcPlanTaskDateReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CalcPlanTaskDateReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CalcPlanTaskDateReqValidationError{}

// Validate checks the field values on CalcPlanTaskDateRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CalcPlanTaskDateRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CalcPlanTaskDateRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CalcPlanTaskDateResMultiError, or nil if none found.
func (m *CalcPlanTaskDateRes) ValidateAll() error {
	return m.validate(true)
}

func (m *CalcPlanTaskDateRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return CalcPlanTaskDateResMultiError(errors)
	}

	return nil
}

// CalcPlanTaskDateResMultiError is an error wrapping multiple validation
// errors returned by CalcPlanTaskDateRes.ValidateAll() if the designated
// constraints aren't met.
type CalcPlanTaskDateResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CalcPlanTaskDateResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CalcPlanTaskDateResMultiError) AllErrors() []error { return m }

// CalcPlanTaskDateResValidationError is the validation error returned by
// CalcPlanTaskDateRes.Validate if the designated constraints aren't met.
type CalcPlanTaskDateResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CalcPlanTaskDateResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CalcPlanTaskDateResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CalcPlanTaskDateResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CalcPlanTaskDateResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CalcPlanTaskDateResValidationError) ErrorName() string {
	return "CalcPlanTaskDateResValidationError"
}

// Error satisfies the builtin error interface
func (e CalcPlanTaskDateResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCalcPlanTaskDateRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CalcPlanTaskDateResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CalcPlanTaskDateResValidationError{}

// Validate checks the field values on CreatePlanTaskReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CreatePlanTaskReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreatePlanTaskReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreatePlanTaskReqMultiError, or nil if none found.
func (m *CreatePlanTaskReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CreatePlanTaskReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCurrentUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreatePlanTaskReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreatePlanTaskReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrentUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreatePlanTaskReqValidationError{
				field:  "CurrentUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if utf8.RuneCountInString(m.GetDeptCode()) < 1 {
		err := CreatePlanTaskReqValidationError{
			field:  "DeptCode",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetPlanId()) < 1 {
		err := CreatePlanTaskReqValidationError{
			field:  "PlanId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetPlanName()) < 1 {
		err := CreatePlanTaskReqValidationError{
			field:  "PlanName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetType()) < 1 {
		err := CreatePlanTaskReqValidationError{
			field:  "Type",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for GroupId

	if utf8.RuneCountInString(m.GetDescription()) > 200 {
		err := CreatePlanTaskReqValidationError{
			field:  "Description",
			reason: "value length must be at most 200 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for StartTime

	// no validation rules for EndTime

	if m.GetRule() == nil {
		err := CreatePlanTaskReqValidationError{
			field:  "Rule",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetRule()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreatePlanTaskReqValidationError{
					field:  "Rule",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreatePlanTaskReqValidationError{
					field:  "Rule",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRule()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreatePlanTaskReqValidationError{
				field:  "Rule",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetExcludeDates() {
		_, _ = idx, item

		if utf8.RuneCountInString(item) < 1 {
			err := CreatePlanTaskReqValidationError{
				field:  fmt.Sprintf("ExcludeDates[%v]", idx),
				reason: "value length must be at least 1 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.GetIntervalTime() < 0 {
		err := CreatePlanTaskReqValidationError{
			field:  "IntervalTime",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetIntervalType(); val < 0 || val > 2 {
		err := CreatePlanTaskReqValidationError{
			field:  "IntervalType",
			reason: "value must be inside range [0, 2]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetExecItems()) < 1 {
		err := CreatePlanTaskReqValidationError{
			field:  "ExecItems",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetExecItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreatePlanTaskReqValidationError{
						field:  fmt.Sprintf("ExecItems[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreatePlanTaskReqValidationError{
						field:  fmt.Sprintf("ExecItems[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreatePlanTaskReqValidationError{
					field:  fmt.Sprintf("ExecItems[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for BatchNumPrefix

	// no validation rules for Ext1

	// no validation rules for Ext2

	// no validation rules for Ext3

	// no validation rules for Ext4

	// no validation rules for Ext5

	if len(errors) > 0 {
		return CreatePlanTaskReqMultiError(errors)
	}

	return nil
}

// CreatePlanTaskReqMultiError is an error wrapping multiple validation errors
// returned by CreatePlanTaskReq.ValidateAll() if the designated constraints
// aren't met.
type CreatePlanTaskReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreatePlanTaskReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreatePlanTaskReqMultiError) AllErrors() []error { return m }

// CreatePlanTaskReqValidationError is the validation error returned by
// CreatePlanTaskReq.Validate if the designated constraints aren't met.
type CreatePlanTaskReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreatePlanTaskReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreatePlanTaskReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreatePlanTaskReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreatePlanTaskReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreatePlanTaskReqValidationError) ErrorName() string {
	return "CreatePlanTaskReqValidationError"
}

// Error satisfies the builtin error interface
func (e CreatePlanTaskReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreatePlanTaskReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreatePlanTaskReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreatePlanTaskReqValidationError{}

// Validate checks the field values on PbPlanRule with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PbPlanRule) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PbPlanRule with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PbPlanRuleMultiError, or
// nil if none found.
func (m *PbPlanRule) ValidateAll() error {
	return m.validate(true)
}

func (m *PbPlanRule) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if val := m.GetFreq(); val < 0 || val > 5 {
		err := PbPlanRuleValidationError{
			field:  "Freq",
			reason: "value must be inside range [0, 5]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetMonth() {
		_, _ = idx, item

		if val := item; val < 1 || val > 12 {
			err := PbPlanRuleValidationError{
				field:  fmt.Sprintf("Month[%v]", idx),
				reason: "value must be inside range [1, 12]",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	for idx, item := range m.GetDay() {
		_, _ = idx, item

		if val := item; val < -31 || val > 31 {
			err := PbPlanRuleValidationError{
				field:  fmt.Sprintf("Day[%v]", idx),
				reason: "value must be inside range [-31, 31]",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if _, ok := _PbPlanRule_Day_NotInLookup[item]; ok {
			err := PbPlanRuleValidationError{
				field:  fmt.Sprintf("Day[%v]", idx),
				reason: "value must not be in list [0]",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	for idx, item := range m.GetWeek() {
		_, _ = idx, item

		if val := item; val < 1 || val > 7 {
			err := PbPlanRuleValidationError{
				field:  fmt.Sprintf("Week[%v]", idx),
				reason: "value must be inside range [1, 7]",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(m.GetHours()) < 1 {
		err := PbPlanRuleValidationError{
			field:  "Hours",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetHours() {
		_, _ = idx, item

		if val := item; val < 0 || val > 23 {
			err := PbPlanRuleValidationError{
				field:  fmt.Sprintf("Hours[%v]", idx),
				reason: "value must be inside range [0, 23]",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(m.GetMinutes()) < 1 {
		err := PbPlanRuleValidationError{
			field:  "Minutes",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetMinutes() {
		_, _ = idx, item

		if val := item; val < 0 || val > 59 {
			err := PbPlanRuleValidationError{
				field:  fmt.Sprintf("Minutes[%v]", idx),
				reason: "value must be inside range [0, 59]",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return PbPlanRuleMultiError(errors)
	}

	return nil
}

// PbPlanRuleMultiError is an error wrapping multiple validation errors
// returned by PbPlanRule.ValidateAll() if the designated constraints aren't met.
type PbPlanRuleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PbPlanRuleMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PbPlanRuleMultiError) AllErrors() []error { return m }

// PbPlanRuleValidationError is the validation error returned by
// PbPlanRule.Validate if the designated constraints aren't met.
type PbPlanRuleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PbPlanRuleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PbPlanRuleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PbPlanRuleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PbPlanRuleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PbPlanRuleValidationError) ErrorName() string { return "PbPlanRuleValidationError" }

// Error satisfies the builtin error interface
func (e PbPlanRuleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPbPlanRule.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PbPlanRuleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PbPlanRuleValidationError{}

var _PbPlanRule_Day_NotInLookup = map[int32]struct{}{
	0: {},
}

// Validate checks the field values on CreatePlanExecItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreatePlanExecItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreatePlanExecItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreatePlanExecItemMultiError, or nil if none found.
func (m *CreatePlanExecItem) ValidateAll() error {
	return m.validate(true)
}

func (m *CreatePlanExecItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetItemId()) < 1 {
		err := CreatePlanExecItemValidationError{
			field:  "ItemId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ItemType

	// no validation rules for ItemName

	// no validation rules for PointId

	// no validation rules for Payload

	// no validation rules for RequestTimeout

	// no validation rules for Ext1

	// no validation rules for Ext2

	// no validation rules for Ext3

	// no validation rules for Ext4

	// no validation rules for Ext5

	if len(errors) > 0 {
		return CreatePlanExecItemMultiError(errors)
	}

	return nil
}

// CreatePlanExecItemMultiError is an error wrapping multiple validation errors
// returned by CreatePlanExecItem.ValidateAll() if the designated constraints
// aren't met.
type CreatePlanExecItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreatePlanExecItemMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreatePlanExecItemMultiError) AllErrors() []error { return m }

// CreatePlanExecItemValidationError is the validation error returned by
// CreatePlanExecItem.Validate if the designated constraints aren't met.
type CreatePlanExecItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreatePlanExecItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreatePlanExecItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreatePlanExecItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreatePlanExecItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreatePlanExecItemValidationError) ErrorName() string {
	return "CreatePlanExecItemValidationError"
}

// Error satisfies the builtin error interface
func (e CreatePlanExecItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreatePlanExecItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreatePlanExecItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreatePlanExecItemValidationError{}

// Validate checks the field values on CreatePlanTaskRes with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CreatePlanTaskRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreatePlanTaskRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreatePlanTaskResMultiError, or nil if none found.
func (m *CreatePlanTaskRes) ValidateAll() error {
	return m.validate(true)
}

func (m *CreatePlanTaskRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for PlanId

	// no validation rules for BatchCnt

	// no validation rules for ExecCnt

	if len(errors) > 0 {
		return CreatePlanTaskResMultiError(errors)
	}

	return nil
}

// CreatePlanTaskResMultiError is an error wrapping multiple validation errors
// returned by CreatePlanTaskRes.ValidateAll() if the designated constraints
// aren't met.
type CreatePlanTaskResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreatePlanTaskResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreatePlanTaskResMultiError) AllErrors() []error { return m }

// CreatePlanTaskResValidationError is the validation error returned by
// CreatePlanTaskRes.Validate if the designated constraints aren't met.
type CreatePlanTaskResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreatePlanTaskResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreatePlanTaskResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreatePlanTaskResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreatePlanTaskResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreatePlanTaskResValidationError) ErrorName() string {
	return "CreatePlanTaskResValidationError"
}

// Error satisfies the builtin error interface
func (e CreatePlanTaskResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreatePlanTaskRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreatePlanTaskResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreatePlanTaskResValidationError{}

// Validate checks the field values on PausePlanReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PausePlanReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PausePlanReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PausePlanReqMultiError, or
// nil if none found.
func (m *PausePlanReq) ValidateAll() error {
	return m.validate(true)
}

func (m *PausePlanReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCurrentUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PausePlanReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PausePlanReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrentUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PausePlanReqValidationError{
				field:  "CurrentUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Id

	// no validation rules for PlanId

	if utf8.RuneCountInString(m.GetReason()) > 200 {
		err := PausePlanReqValidationError{
			field:  "Reason",
			reason: "value length must be at most 200 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return PausePlanReqMultiError(errors)
	}

	return nil
}

// PausePlanReqMultiError is an error wrapping multiple validation errors
// returned by PausePlanReq.ValidateAll() if the designated constraints aren't met.
type PausePlanReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PausePlanReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PausePlanReqMultiError) AllErrors() []error { return m }

// PausePlanReqValidationError is the validation error returned by
// PausePlanReq.Validate if the designated constraints aren't met.
type PausePlanReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PausePlanReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PausePlanReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PausePlanReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PausePlanReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PausePlanReqValidationError) ErrorName() string { return "PausePlanReqValidationError" }

// Error satisfies the builtin error interface
func (e PausePlanReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPausePlanReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PausePlanReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PausePlanReqValidationError{}

// Validate checks the field values on PausePlanRes with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PausePlanRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PausePlanRes with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PausePlanResMultiError, or
// nil if none found.
func (m *PausePlanRes) ValidateAll() error {
	return m.validate(true)
}

func (m *PausePlanRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return PausePlanResMultiError(errors)
	}

	return nil
}

// PausePlanResMultiError is an error wrapping multiple validation errors
// returned by PausePlanRes.ValidateAll() if the designated constraints aren't met.
type PausePlanResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PausePlanResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PausePlanResMultiError) AllErrors() []error { return m }

// PausePlanResValidationError is the validation error returned by
// PausePlanRes.Validate if the designated constraints aren't met.
type PausePlanResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PausePlanResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PausePlanResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PausePlanResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PausePlanResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PausePlanResValidationError) ErrorName() string { return "PausePlanResValidationError" }

// Error satisfies the builtin error interface
func (e PausePlanResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPausePlanRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PausePlanResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PausePlanResValidationError{}

// Validate checks the field values on TerminatePlanReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *TerminatePlanReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TerminatePlanReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TerminatePlanReqMultiError, or nil if none found.
func (m *TerminatePlanReq) ValidateAll() error {
	return m.validate(true)
}

func (m *TerminatePlanReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCurrentUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TerminatePlanReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TerminatePlanReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrentUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TerminatePlanReqValidationError{
				field:  "CurrentUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Id

	// no validation rules for PlanId

	if utf8.RuneCountInString(m.GetReason()) > 200 {
		err := TerminatePlanReqValidationError{
			field:  "Reason",
			reason: "value length must be at most 200 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return TerminatePlanReqMultiError(errors)
	}

	return nil
}

// TerminatePlanReqMultiError is an error wrapping multiple validation errors
// returned by TerminatePlanReq.ValidateAll() if the designated constraints
// aren't met.
type TerminatePlanReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TerminatePlanReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TerminatePlanReqMultiError) AllErrors() []error { return m }

// TerminatePlanReqValidationError is the validation error returned by
// TerminatePlanReq.Validate if the designated constraints aren't met.
type TerminatePlanReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TerminatePlanReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TerminatePlanReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TerminatePlanReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TerminatePlanReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TerminatePlanReqValidationError) ErrorName() string { return "TerminatePlanReqValidationError" }

// Error satisfies the builtin error interface
func (e TerminatePlanReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTerminatePlanReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TerminatePlanReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TerminatePlanReqValidationError{}

// Validate checks the field values on TerminatePlanRes with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *TerminatePlanRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TerminatePlanRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TerminatePlanResMultiError, or nil if none found.
func (m *TerminatePlanRes) ValidateAll() error {
	return m.validate(true)
}

func (m *TerminatePlanRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return TerminatePlanResMultiError(errors)
	}

	return nil
}

// TerminatePlanResMultiError is an error wrapping multiple validation errors
// returned by TerminatePlanRes.ValidateAll() if the designated constraints
// aren't met.
type TerminatePlanResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TerminatePlanResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TerminatePlanResMultiError) AllErrors() []error { return m }

// TerminatePlanResValidationError is the validation error returned by
// TerminatePlanRes.Validate if the designated constraints aren't met.
type TerminatePlanResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TerminatePlanResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TerminatePlanResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TerminatePlanResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TerminatePlanResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TerminatePlanResValidationError) ErrorName() string { return "TerminatePlanResValidationError" }

// Error satisfies the builtin error interface
func (e TerminatePlanResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTerminatePlanRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TerminatePlanResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TerminatePlanResValidationError{}

// Validate checks the field values on ResumePlanReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ResumePlanReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ResumePlanReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ResumePlanReqMultiError, or
// nil if none found.
func (m *ResumePlanReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ResumePlanReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCurrentUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ResumePlanReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ResumePlanReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrentUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ResumePlanReqValidationError{
				field:  "CurrentUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Id

	// no validation rules for PlanId

	if len(errors) > 0 {
		return ResumePlanReqMultiError(errors)
	}

	return nil
}

// ResumePlanReqMultiError is an error wrapping multiple validation errors
// returned by ResumePlanReq.ValidateAll() if the designated constraints
// aren't met.
type ResumePlanReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResumePlanReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResumePlanReqMultiError) AllErrors() []error { return m }

// ResumePlanReqValidationError is the validation error returned by
// ResumePlanReq.Validate if the designated constraints aren't met.
type ResumePlanReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResumePlanReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResumePlanReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResumePlanReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResumePlanReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResumePlanReqValidationError) ErrorName() string { return "ResumePlanReqValidationError" }

// Error satisfies the builtin error interface
func (e ResumePlanReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResumePlanReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResumePlanReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResumePlanReqValidationError{}

// Validate checks the field values on ResumePlanRes with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ResumePlanRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ResumePlanRes with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ResumePlanResMultiError, or
// nil if none found.
func (m *ResumePlanRes) ValidateAll() error {
	return m.validate(true)
}

func (m *ResumePlanRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ResumePlanResMultiError(errors)
	}

	return nil
}

// ResumePlanResMultiError is an error wrapping multiple validation errors
// returned by ResumePlanRes.ValidateAll() if the designated constraints
// aren't met.
type ResumePlanResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResumePlanResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResumePlanResMultiError) AllErrors() []error { return m }

// ResumePlanResValidationError is the validation error returned by
// ResumePlanRes.Validate if the designated constraints aren't met.
type ResumePlanResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResumePlanResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResumePlanResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResumePlanResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResumePlanResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResumePlanResValidationError) ErrorName() string { return "ResumePlanResValidationError" }

// Error satisfies the builtin error interface
func (e ResumePlanResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResumePlanRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResumePlanResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResumePlanResValidationError{}

// Validate checks the field values on PausePlanBatchReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *PausePlanBatchReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PausePlanBatchReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PausePlanBatchReqMultiError, or nil if none found.
func (m *PausePlanBatchReq) ValidateAll() error {
	return m.validate(true)
}

func (m *PausePlanBatchReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCurrentUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PausePlanBatchReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PausePlanBatchReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrentUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PausePlanBatchReqValidationError{
				field:  "CurrentUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Id

	// no validation rules for BatchId

	if utf8.RuneCountInString(m.GetReason()) > 200 {
		err := PausePlanBatchReqValidationError{
			field:  "Reason",
			reason: "value length must be at most 200 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return PausePlanBatchReqMultiError(errors)
	}

	return nil
}

// PausePlanBatchReqMultiError is an error wrapping multiple validation errors
// returned by PausePlanBatchReq.ValidateAll() if the designated constraints
// aren't met.
type PausePlanBatchReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PausePlanBatchReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PausePlanBatchReqMultiError) AllErrors() []error { return m }

// PausePlanBatchReqValidationError is the validation error returned by
// PausePlanBatchReq.Validate if the designated constraints aren't met.
type PausePlanBatchReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PausePlanBatchReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PausePlanBatchReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PausePlanBatchReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PausePlanBatchReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PausePlanBatchReqValidationError) ErrorName() string {
	return "PausePlanBatchReqValidationError"
}

// Error satisfies the builtin error interface
func (e PausePlanBatchReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPausePlanBatchReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PausePlanBatchReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PausePlanBatchReqValidationError{}

// Validate checks the field values on PausePlanBatchRes with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *PausePlanBatchRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PausePlanBatchRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PausePlanBatchResMultiError, or nil if none found.
func (m *PausePlanBatchRes) ValidateAll() error {
	return m.validate(true)
}

func (m *PausePlanBatchRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return PausePlanBatchResMultiError(errors)
	}

	return nil
}

// PausePlanBatchResMultiError is an error wrapping multiple validation errors
// returned by PausePlanBatchRes.ValidateAll() if the designated constraints
// aren't met.
type PausePlanBatchResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PausePlanBatchResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PausePlanBatchResMultiError) AllErrors() []error { return m }

// PausePlanBatchResValidationError is the validation error returned by
// PausePlanBatchRes.Validate if the designated constraints aren't met.
type PausePlanBatchResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PausePlanBatchResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PausePlanBatchResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PausePlanBatchResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PausePlanBatchResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PausePlanBatchResValidationError) ErrorName() string {
	return "PausePlanBatchResValidationError"
}

// Error satisfies the builtin error interface
func (e PausePlanBatchResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPausePlanBatchRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PausePlanBatchResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PausePlanBatchResValidationError{}

// Validate checks the field values on TerminatePlanBatchReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TerminatePlanBatchReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TerminatePlanBatchReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TerminatePlanBatchReqMultiError, or nil if none found.
func (m *TerminatePlanBatchReq) ValidateAll() error {
	return m.validate(true)
}

func (m *TerminatePlanBatchReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCurrentUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TerminatePlanBatchReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TerminatePlanBatchReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrentUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TerminatePlanBatchReqValidationError{
				field:  "CurrentUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Id

	// no validation rules for BatchId

	if utf8.RuneCountInString(m.GetReason()) > 200 {
		err := TerminatePlanBatchReqValidationError{
			field:  "Reason",
			reason: "value length must be at most 200 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return TerminatePlanBatchReqMultiError(errors)
	}

	return nil
}

// TerminatePlanBatchReqMultiError is an error wrapping multiple validation
// errors returned by TerminatePlanBatchReq.ValidateAll() if the designated
// constraints aren't met.
type TerminatePlanBatchReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TerminatePlanBatchReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TerminatePlanBatchReqMultiError) AllErrors() []error { return m }

// TerminatePlanBatchReqValidationError is the validation error returned by
// TerminatePlanBatchReq.Validate if the designated constraints aren't met.
type TerminatePlanBatchReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TerminatePlanBatchReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TerminatePlanBatchReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TerminatePlanBatchReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TerminatePlanBatchReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TerminatePlanBatchReqValidationError) ErrorName() string {
	return "TerminatePlanBatchReqValidationError"
}

// Error satisfies the builtin error interface
func (e TerminatePlanBatchReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTerminatePlanBatchReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TerminatePlanBatchReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TerminatePlanBatchReqValidationError{}

// Validate checks the field values on TerminatePlanBatchRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TerminatePlanBatchRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TerminatePlanBatchRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TerminatePlanBatchResMultiError, or nil if none found.
func (m *TerminatePlanBatchRes) ValidateAll() error {
	return m.validate(true)
}

func (m *TerminatePlanBatchRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return TerminatePlanBatchResMultiError(errors)
	}

	return nil
}

// TerminatePlanBatchResMultiError is an error wrapping multiple validation
// errors returned by TerminatePlanBatchRes.ValidateAll() if the designated
// constraints aren't met.
type TerminatePlanBatchResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TerminatePlanBatchResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TerminatePlanBatchResMultiError) AllErrors() []error { return m }

// TerminatePlanBatchResValidationError is the validation error returned by
// TerminatePlanBatchRes.Validate if the designated constraints aren't met.
type TerminatePlanBatchResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TerminatePlanBatchResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TerminatePlanBatchResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TerminatePlanBatchResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TerminatePlanBatchResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TerminatePlanBatchResValidationError) ErrorName() string {
	return "TerminatePlanBatchResValidationError"
}

// Error satisfies the builtin error interface
func (e TerminatePlanBatchResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTerminatePlanBatchRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TerminatePlanBatchResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TerminatePlanBatchResValidationError{}

// Validate checks the field values on ResumePlanBatchReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ResumePlanBatchReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ResumePlanBatchReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ResumePlanBatchReqMultiError, or nil if none found.
func (m *ResumePlanBatchReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ResumePlanBatchReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCurrentUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ResumePlanBatchReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ResumePlanBatchReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrentUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ResumePlanBatchReqValidationError{
				field:  "CurrentUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Id

	// no validation rules for BatchId

	if len(errors) > 0 {
		return ResumePlanBatchReqMultiError(errors)
	}

	return nil
}

// ResumePlanBatchReqMultiError is an error wrapping multiple validation errors
// returned by ResumePlanBatchReq.ValidateAll() if the designated constraints
// aren't met.
type ResumePlanBatchReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResumePlanBatchReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResumePlanBatchReqMultiError) AllErrors() []error { return m }

// ResumePlanBatchReqValidationError is the validation error returned by
// ResumePlanBatchReq.Validate if the designated constraints aren't met.
type ResumePlanBatchReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResumePlanBatchReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResumePlanBatchReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResumePlanBatchReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResumePlanBatchReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResumePlanBatchReqValidationError) ErrorName() string {
	return "ResumePlanBatchReqValidationError"
}

// Error satisfies the builtin error interface
func (e ResumePlanBatchReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResumePlanBatchReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResumePlanBatchReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResumePlanBatchReqValidationError{}

// Validate checks the field values on ResumePlanBatchRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ResumePlanBatchRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ResumePlanBatchRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ResumePlanBatchResMultiError, or nil if none found.
func (m *ResumePlanBatchRes) ValidateAll() error {
	return m.validate(true)
}

func (m *ResumePlanBatchRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ResumePlanBatchResMultiError(errors)
	}

	return nil
}

// ResumePlanBatchResMultiError is an error wrapping multiple validation errors
// returned by ResumePlanBatchRes.ValidateAll() if the designated constraints
// aren't met.
type ResumePlanBatchResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResumePlanBatchResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResumePlanBatchResMultiError) AllErrors() []error { return m }

// ResumePlanBatchResValidationError is the validation error returned by
// ResumePlanBatchRes.Validate if the designated constraints aren't met.
type ResumePlanBatchResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResumePlanBatchResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResumePlanBatchResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResumePlanBatchResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResumePlanBatchResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResumePlanBatchResValidationError) ErrorName() string {
	return "ResumePlanBatchResValidationError"
}

// Error satisfies the builtin error interface
func (e ResumePlanBatchResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResumePlanBatchRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResumePlanBatchResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResumePlanBatchResValidationError{}

// Validate checks the field values on PausePlanExecItemReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PausePlanExecItemReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PausePlanExecItemReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PausePlanExecItemReqMultiError, or nil if none found.
func (m *PausePlanExecItemReq) ValidateAll() error {
	return m.validate(true)
}

func (m *PausePlanExecItemReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCurrentUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PausePlanExecItemReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PausePlanExecItemReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrentUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PausePlanExecItemReqValidationError{
				field:  "CurrentUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Id

	// no validation rules for ExecId

	if utf8.RuneCountInString(m.GetReason()) > 200 {
		err := PausePlanExecItemReqValidationError{
			field:  "Reason",
			reason: "value length must be at most 200 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return PausePlanExecItemReqMultiError(errors)
	}

	return nil
}

// PausePlanExecItemReqMultiError is an error wrapping multiple validation
// errors returned by PausePlanExecItemReq.ValidateAll() if the designated
// constraints aren't met.
type PausePlanExecItemReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PausePlanExecItemReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PausePlanExecItemReqMultiError) AllErrors() []error { return m }

// PausePlanExecItemReqValidationError is the validation error returned by
// PausePlanExecItemReq.Validate if the designated constraints aren't met.
type PausePlanExecItemReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PausePlanExecItemReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PausePlanExecItemReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PausePlanExecItemReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PausePlanExecItemReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PausePlanExecItemReqValidationError) ErrorName() string {
	return "PausePlanExecItemReqValidationError"
}

// Error satisfies the builtin error interface
func (e PausePlanExecItemReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPausePlanExecItemReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PausePlanExecItemReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PausePlanExecItemReqValidationError{}

// Validate checks the field values on PausePlanExecItemRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PausePlanExecItemRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PausePlanExecItemRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PausePlanExecItemResMultiError, or nil if none found.
func (m *PausePlanExecItemRes) ValidateAll() error {
	return m.validate(true)
}

func (m *PausePlanExecItemRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return PausePlanExecItemResMultiError(errors)
	}

	return nil
}

// PausePlanExecItemResMultiError is an error wrapping multiple validation
// errors returned by PausePlanExecItemRes.ValidateAll() if the designated
// constraints aren't met.
type PausePlanExecItemResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PausePlanExecItemResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PausePlanExecItemResMultiError) AllErrors() []error { return m }

// PausePlanExecItemResValidationError is the validation error returned by
// PausePlanExecItemRes.Validate if the designated constraints aren't met.
type PausePlanExecItemResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PausePlanExecItemResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PausePlanExecItemResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PausePlanExecItemResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PausePlanExecItemResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PausePlanExecItemResValidationError) ErrorName() string {
	return "PausePlanExecItemResValidationError"
}

// Error satisfies the builtin error interface
func (e PausePlanExecItemResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPausePlanExecItemRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PausePlanExecItemResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PausePlanExecItemResValidationError{}

// Validate checks the field values on TerminatePlanExecItemReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TerminatePlanExecItemReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TerminatePlanExecItemReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TerminatePlanExecItemReqMultiError, or nil if none found.
func (m *TerminatePlanExecItemReq) ValidateAll() error {
	return m.validate(true)
}

func (m *TerminatePlanExecItemReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCurrentUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TerminatePlanExecItemReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TerminatePlanExecItemReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrentUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TerminatePlanExecItemReqValidationError{
				field:  "CurrentUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Id

	// no validation rules for ExecId

	if utf8.RuneCountInString(m.GetReason()) > 200 {
		err := TerminatePlanExecItemReqValidationError{
			field:  "Reason",
			reason: "value length must be at most 200 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return TerminatePlanExecItemReqMultiError(errors)
	}

	return nil
}

// TerminatePlanExecItemReqMultiError is an error wrapping multiple validation
// errors returned by TerminatePlanExecItemReq.ValidateAll() if the designated
// constraints aren't met.
type TerminatePlanExecItemReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TerminatePlanExecItemReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TerminatePlanExecItemReqMultiError) AllErrors() []error { return m }

// TerminatePlanExecItemReqValidationError is the validation error returned by
// TerminatePlanExecItemReq.Validate if the designated constraints aren't met.
type TerminatePlanExecItemReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TerminatePlanExecItemReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TerminatePlanExecItemReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TerminatePlanExecItemReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TerminatePlanExecItemReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TerminatePlanExecItemReqValidationError) ErrorName() string {
	return "TerminatePlanExecItemReqValidationError"
}

// Error satisfies the builtin error interface
func (e TerminatePlanExecItemReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTerminatePlanExecItemReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TerminatePlanExecItemReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TerminatePlanExecItemReqValidationError{}

// Validate checks the field values on TerminatePlanExecItemRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TerminatePlanExecItemRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TerminatePlanExecItemRes with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TerminatePlanExecItemResMultiError, or nil if none found.
func (m *TerminatePlanExecItemRes) ValidateAll() error {
	return m.validate(true)
}

func (m *TerminatePlanExecItemRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return TerminatePlanExecItemResMultiError(errors)
	}

	return nil
}

// TerminatePlanExecItemResMultiError is an error wrapping multiple validation
// errors returned by TerminatePlanExecItemRes.ValidateAll() if the designated
// constraints aren't met.
type TerminatePlanExecItemResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TerminatePlanExecItemResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TerminatePlanExecItemResMultiError) AllErrors() []error { return m }

// TerminatePlanExecItemResValidationError is the validation error returned by
// TerminatePlanExecItemRes.Validate if the designated constraints aren't met.
type TerminatePlanExecItemResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TerminatePlanExecItemResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TerminatePlanExecItemResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TerminatePlanExecItemResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TerminatePlanExecItemResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TerminatePlanExecItemResValidationError) ErrorName() string {
	return "TerminatePlanExecItemResValidationError"
}

// Error satisfies the builtin error interface
func (e TerminatePlanExecItemResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTerminatePlanExecItemRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TerminatePlanExecItemResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TerminatePlanExecItemResValidationError{}

// Validate checks the field values on ResumePlanExecItemReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ResumePlanExecItemReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ResumePlanExecItemReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ResumePlanExecItemReqMultiError, or nil if none found.
func (m *ResumePlanExecItemReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ResumePlanExecItemReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCurrentUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ResumePlanExecItemReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ResumePlanExecItemReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrentUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ResumePlanExecItemReqValidationError{
				field:  "CurrentUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Id

	// no validation rules for ExecId

	if len(errors) > 0 {
		return ResumePlanExecItemReqMultiError(errors)
	}

	return nil
}

// ResumePlanExecItemReqMultiError is an error wrapping multiple validation
// errors returned by ResumePlanExecItemReq.ValidateAll() if the designated
// constraints aren't met.
type ResumePlanExecItemReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResumePlanExecItemReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResumePlanExecItemReqMultiError) AllErrors() []error { return m }

// ResumePlanExecItemReqValidationError is the validation error returned by
// ResumePlanExecItemReq.Validate if the designated constraints aren't met.
type ResumePlanExecItemReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResumePlanExecItemReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResumePlanExecItemReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResumePlanExecItemReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResumePlanExecItemReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResumePlanExecItemReqValidationError) ErrorName() string {
	return "ResumePlanExecItemReqValidationError"
}

// Error satisfies the builtin error interface
func (e ResumePlanExecItemReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResumePlanExecItemReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResumePlanExecItemReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResumePlanExecItemReqValidationError{}

// Validate checks the field values on ResumePlanExecItemRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ResumePlanExecItemRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ResumePlanExecItemRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ResumePlanExecItemResMultiError, or nil if none found.
func (m *ResumePlanExecItemRes) ValidateAll() error {
	return m.validate(true)
}

func (m *ResumePlanExecItemRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ResumePlanExecItemResMultiError(errors)
	}

	return nil
}

// ResumePlanExecItemResMultiError is an error wrapping multiple validation
// errors returned by ResumePlanExecItemRes.ValidateAll() if the designated
// constraints aren't met.
type ResumePlanExecItemResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResumePlanExecItemResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResumePlanExecItemResMultiError) AllErrors() []error { return m }

// ResumePlanExecItemResValidationError is the validation error returned by
// ResumePlanExecItemRes.Validate if the designated constraints aren't met.
type ResumePlanExecItemResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResumePlanExecItemResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResumePlanExecItemResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResumePlanExecItemResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResumePlanExecItemResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResumePlanExecItemResValidationError) ErrorName() string {
	return "ResumePlanExecItemResValidationError"
}

// Error satisfies the builtin error interface
func (e ResumePlanExecItemResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResumePlanExecItemRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResumePlanExecItemResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResumePlanExecItemResValidationError{}

// Validate checks the field values on RunPlanExecItemReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RunPlanExecItemReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RunPlanExecItemReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RunPlanExecItemReqMultiError, or nil if none found.
func (m *RunPlanExecItemReq) ValidateAll() error {
	return m.validate(true)
}

func (m *RunPlanExecItemReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCurrentUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RunPlanExecItemReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RunPlanExecItemReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrentUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RunPlanExecItemReqValidationError{
				field:  "CurrentUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Id

	// no validation rules for ExecId

	if len(errors) > 0 {
		return RunPlanExecItemReqMultiError(errors)
	}

	return nil
}

// RunPlanExecItemReqMultiError is an error wrapping multiple validation errors
// returned by RunPlanExecItemReq.ValidateAll() if the designated constraints
// aren't met.
type RunPlanExecItemReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RunPlanExecItemReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RunPlanExecItemReqMultiError) AllErrors() []error { return m }

// RunPlanExecItemReqValidationError is the validation error returned by
// RunPlanExecItemReq.Validate if the designated constraints aren't met.
type RunPlanExecItemReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RunPlanExecItemReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RunPlanExecItemReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RunPlanExecItemReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RunPlanExecItemReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RunPlanExecItemReqValidationError) ErrorName() string {
	return "RunPlanExecItemReqValidationError"
}

// Error satisfies the builtin error interface
func (e RunPlanExecItemReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRunPlanExecItemReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RunPlanExecItemReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RunPlanExecItemReqValidationError{}

// Validate checks the field values on RunPlanExecItemRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RunPlanExecItemRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RunPlanExecItemRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RunPlanExecItemResMultiError, or nil if none found.
func (m *RunPlanExecItemRes) ValidateAll() error {
	return m.validate(true)
}

func (m *RunPlanExecItemRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return RunPlanExecItemResMultiError(errors)
	}

	return nil
}

// RunPlanExecItemResMultiError is an error wrapping multiple validation errors
// returned by RunPlanExecItemRes.ValidateAll() if the designated constraints
// aren't met.
type RunPlanExecItemResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RunPlanExecItemResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RunPlanExecItemResMultiError) AllErrors() []error { return m }

// RunPlanExecItemResValidationError is the validation error returned by
// RunPlanExecItemRes.Validate if the designated constraints aren't met.
type RunPlanExecItemResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RunPlanExecItemResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RunPlanExecItemResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RunPlanExecItemResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RunPlanExecItemResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RunPlanExecItemResValidationError) ErrorName() string {
	return "RunPlanExecItemResValidationError"
}

// Error satisfies the builtin error interface
func (e RunPlanExecItemResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRunPlanExecItemRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RunPlanExecItemResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RunPlanExecItemResValidationError{}

// Validate checks the field values on GetPlanReq with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetPlanReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetPlanReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetPlanReqMultiError, or
// nil if none found.
func (m *GetPlanReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetPlanReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCurrentUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetPlanReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetPlanReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrentUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetPlanReqValidationError{
				field:  "CurrentUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Id

	// no validation rules for PlanId

	if len(errors) > 0 {
		return GetPlanReqMultiError(errors)
	}

	return nil
}

// GetPlanReqMultiError is an error wrapping multiple validation errors
// returned by GetPlanReq.ValidateAll() if the designated constraints aren't met.
type GetPlanReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetPlanReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetPlanReqMultiError) AllErrors() []error { return m }

// GetPlanReqValidationError is the validation error returned by
// GetPlanReq.Validate if the designated constraints aren't met.
type GetPlanReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetPlanReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetPlanReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetPlanReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetPlanReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetPlanReqValidationError) ErrorName() string { return "GetPlanReqValidationError" }

// Error satisfies the builtin error interface
func (e GetPlanReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetPlanReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetPlanReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetPlanReqValidationError{}

// Validate checks the field values on GetPlanRes with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetPlanRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetPlanRes with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetPlanResMultiError, or
// nil if none found.
func (m *GetPlanRes) ValidateAll() error {
	return m.validate(true)
}

func (m *GetPlanRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPlan()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetPlanResValidationError{
					field:  "Plan",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetPlanResValidationError{
					field:  "Plan",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPlan()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetPlanResValidationError{
				field:  "Plan",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetPlanResMultiError(errors)
	}

	return nil
}

// GetPlanResMultiError is an error wrapping multiple validation errors
// returned by GetPlanRes.ValidateAll() if the designated constraints aren't met.
type GetPlanResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetPlanResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetPlanResMultiError) AllErrors() []error { return m }

// GetPlanResValidationError is the validation error returned by
// GetPlanRes.Validate if the designated constraints aren't met.
type GetPlanResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetPlanResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetPlanResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetPlanResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetPlanResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetPlanResValidationError) ErrorName() string { return "GetPlanResValidationError" }

// Error satisfies the builtin error interface
func (e GetPlanResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetPlanRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetPlanResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetPlanResValidationError{}

// Validate checks the field values on PbPlan with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PbPlan) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PbPlan with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in PbPlanMultiError, or nil if none found.
func (m *PbPlan) ValidateAll() error {
	return m.validate(true)
}

func (m *PbPlan) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CreateTime

	// no validation rules for UpdateTime

	// no validation rules for CreateUser

	// no validation rules for UpdateUser

	// no validation rules for DeptCode

	// no validation rules for Id

	// no validation rules for PlanId

	// no validation rules for PlanName

	// no validation rules for Type

	// no validation rules for GroupId

	// no validation rules for Description

	// no validation rules for StartTime

	// no validation rules for EndTime

	if all {
		switch v := interface{}(m.GetRule()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PbPlanValidationError{
					field:  "Rule",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PbPlanValidationError{
					field:  "Rule",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRule()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PbPlanValidationError{
				field:  "Rule",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Status

	// no validation rules for TerminatedReason

	// no validation rules for PausedTime

	// no validation rules for PausedReason

	// no validation rules for Progress

	// no validation rules for Ext1

	// no validation rules for Ext2

	// no validation rules for Ext3

	// no validation rules for Ext4

	// no validation rules for Ext5

	if len(errors) > 0 {
		return PbPlanMultiError(errors)
	}

	return nil
}

// PbPlanMultiError is an error wrapping multiple validation errors returned by
// PbPlan.ValidateAll() if the designated constraints aren't met.
type PbPlanMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PbPlanMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PbPlanMultiError) AllErrors() []error { return m }

// PbPlanValidationError is the validation error returned by PbPlan.Validate if
// the designated constraints aren't met.
type PbPlanValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PbPlanValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PbPlanValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PbPlanValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PbPlanValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PbPlanValidationError) ErrorName() string { return "PbPlanValidationError" }

// Error satisfies the builtin error interface
func (e PbPlanValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPbPlan.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PbPlanValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PbPlanValidationError{}

// Validate checks the field values on ListPlansReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ListPlansReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListPlansReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ListPlansReqMultiError, or
// nil if none found.
func (m *ListPlansReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListPlansReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCurrentUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListPlansReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListPlansReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrentUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListPlansReqValidationError{
				field:  "CurrentUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetPageSize() < 0 {
		err := ListPlansReqValidationError{
			field:  "PageSize",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetPageNum() < 0 {
		err := ListPlansReqValidationError{
			field:  "PageNum",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for PlanId

	// no validation rules for PlanName

	// no validation rules for Type

	if len(errors) > 0 {
		return ListPlansReqMultiError(errors)
	}

	return nil
}

// ListPlansReqMultiError is an error wrapping multiple validation errors
// returned by ListPlansReq.ValidateAll() if the designated constraints aren't met.
type ListPlansReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListPlansReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListPlansReqMultiError) AllErrors() []error { return m }

// ListPlansReqValidationError is the validation error returned by
// ListPlansReq.Validate if the designated constraints aren't met.
type ListPlansReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListPlansReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListPlansReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListPlansReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListPlansReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListPlansReqValidationError) ErrorName() string { return "ListPlansReqValidationError" }

// Error satisfies the builtin error interface
func (e ListPlansReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListPlansReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListPlansReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListPlansReqValidationError{}

// Validate checks the field values on ListPlansRes with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ListPlansRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListPlansRes with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ListPlansResMultiError, or
// nil if none found.
func (m *ListPlansRes) ValidateAll() error {
	return m.validate(true)
}

func (m *ListPlansRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetPlans() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListPlansResValidationError{
						field:  fmt.Sprintf("Plans[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListPlansResValidationError{
						field:  fmt.Sprintf("Plans[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListPlansResValidationError{
					field:  fmt.Sprintf("Plans[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Total

	if len(errors) > 0 {
		return ListPlansResMultiError(errors)
	}

	return nil
}

// ListPlansResMultiError is an error wrapping multiple validation errors
// returned by ListPlansRes.ValidateAll() if the designated constraints aren't met.
type ListPlansResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListPlansResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListPlansResMultiError) AllErrors() []error { return m }

// ListPlansResValidationError is the validation error returned by
// ListPlansRes.Validate if the designated constraints aren't met.
type ListPlansResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListPlansResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListPlansResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListPlansResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListPlansResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListPlansResValidationError) ErrorName() string { return "ListPlansResValidationError" }

// Error satisfies the builtin error interface
func (e ListPlansResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListPlansRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListPlansResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListPlansResValidationError{}

// Validate checks the field values on GetPlanBatchReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetPlanBatchReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetPlanBatchReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetPlanBatchReqMultiError, or nil if none found.
func (m *GetPlanBatchReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetPlanBatchReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCurrentUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetPlanBatchReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetPlanBatchReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrentUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetPlanBatchReqValidationError{
				field:  "CurrentUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Id

	// no validation rules for BatchId

	if len(errors) > 0 {
		return GetPlanBatchReqMultiError(errors)
	}

	return nil
}

// GetPlanBatchReqMultiError is an error wrapping multiple validation errors
// returned by GetPlanBatchReq.ValidateAll() if the designated constraints
// aren't met.
type GetPlanBatchReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetPlanBatchReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetPlanBatchReqMultiError) AllErrors() []error { return m }

// GetPlanBatchReqValidationError is the validation error returned by
// GetPlanBatchReq.Validate if the designated constraints aren't met.
type GetPlanBatchReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetPlanBatchReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetPlanBatchReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetPlanBatchReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetPlanBatchReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetPlanBatchReqValidationError) ErrorName() string { return "GetPlanBatchReqValidationError" }

// Error satisfies the builtin error interface
func (e GetPlanBatchReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetPlanBatchReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetPlanBatchReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetPlanBatchReqValidationError{}

// Validate checks the field values on GetPlanBatchRes with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetPlanBatchRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetPlanBatchRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetPlanBatchResMultiError, or nil if none found.
func (m *GetPlanBatchRes) ValidateAll() error {
	return m.validate(true)
}

func (m *GetPlanBatchRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPlanBatch()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetPlanBatchResValidationError{
					field:  "PlanBatch",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetPlanBatchResValidationError{
					field:  "PlanBatch",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPlanBatch()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetPlanBatchResValidationError{
				field:  "PlanBatch",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetPlanBatchResMultiError(errors)
	}

	return nil
}

// GetPlanBatchResMultiError is an error wrapping multiple validation errors
// returned by GetPlanBatchRes.ValidateAll() if the designated constraints
// aren't met.
type GetPlanBatchResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetPlanBatchResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetPlanBatchResMultiError) AllErrors() []error { return m }

// GetPlanBatchResValidationError is the validation error returned by
// GetPlanBatchRes.Validate if the designated constraints aren't met.
type GetPlanBatchResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetPlanBatchResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetPlanBatchResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetPlanBatchResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetPlanBatchResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetPlanBatchResValidationError) ErrorName() string { return "GetPlanBatchResValidationError" }

// Error satisfies the builtin error interface
func (e GetPlanBatchResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetPlanBatchRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetPlanBatchResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetPlanBatchResValidationError{}

// Validate checks the field values on ListPlanBatchesReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListPlanBatchesReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListPlanBatchesReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListPlanBatchesReqMultiError, or nil if none found.
func (m *ListPlanBatchesReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListPlanBatchesReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCurrentUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListPlanBatchesReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListPlanBatchesReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrentUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListPlanBatchesReqValidationError{
				field:  "CurrentUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetPageSize() < 0 {
		err := ListPlanBatchesReqValidationError{
			field:  "PageSize",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetPageNum() < 0 {
		err := ListPlanBatchesReqValidationError{
			field:  "PageNum",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for PlanPk

	// no validation rules for PlanId

	// no validation rules for BatchId

	if len(errors) > 0 {
		return ListPlanBatchesReqMultiError(errors)
	}

	return nil
}

// ListPlanBatchesReqMultiError is an error wrapping multiple validation errors
// returned by ListPlanBatchesReq.ValidateAll() if the designated constraints
// aren't met.
type ListPlanBatchesReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListPlanBatchesReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListPlanBatchesReqMultiError) AllErrors() []error { return m }

// ListPlanBatchesReqValidationError is the validation error returned by
// ListPlanBatchesReq.Validate if the designated constraints aren't met.
type ListPlanBatchesReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListPlanBatchesReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListPlanBatchesReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListPlanBatchesReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListPlanBatchesReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListPlanBatchesReqValidationError) ErrorName() string {
	return "ListPlanBatchesReqValidationError"
}

// Error satisfies the builtin error interface
func (e ListPlanBatchesReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListPlanBatchesReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListPlanBatchesReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListPlanBatchesReqValidationError{}

// Validate checks the field values on ListPlanBatchesRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListPlanBatchesRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListPlanBatchesRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListPlanBatchesResMultiError, or nil if none found.
func (m *ListPlanBatchesRes) ValidateAll() error {
	return m.validate(true)
}

func (m *ListPlanBatchesRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetPlanBatches() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListPlanBatchesResValidationError{
						field:  fmt.Sprintf("PlanBatches[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListPlanBatchesResValidationError{
						field:  fmt.Sprintf("PlanBatches[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListPlanBatchesResValidationError{
					field:  fmt.Sprintf("PlanBatches[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Total

	if len(errors) > 0 {
		return ListPlanBatchesResMultiError(errors)
	}

	return nil
}

// ListPlanBatchesResMultiError is an error wrapping multiple validation errors
// returned by ListPlanBatchesRes.ValidateAll() if the designated constraints
// aren't met.
type ListPlanBatchesResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListPlanBatchesResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListPlanBatchesResMultiError) AllErrors() []error { return m }

// ListPlanBatchesResValidationError is the validation error returned by
// ListPlanBatchesRes.Validate if the designated constraints aren't met.
type ListPlanBatchesResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListPlanBatchesResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListPlanBatchesResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListPlanBatchesResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListPlanBatchesResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListPlanBatchesResValidationError) ErrorName() string {
	return "ListPlanBatchesResValidationError"
}

// Error satisfies the builtin error interface
func (e ListPlanBatchesResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListPlanBatchesRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListPlanBatchesResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListPlanBatchesResValidationError{}

// Validate checks the field values on GetPlanExecItemReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetPlanExecItemReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetPlanExecItemReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetPlanExecItemReqMultiError, or nil if none found.
func (m *GetPlanExecItemReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetPlanExecItemReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCurrentUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetPlanExecItemReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetPlanExecItemReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrentUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetPlanExecItemReqValidationError{
				field:  "CurrentUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Id

	// no validation rules for ExecId

	if len(errors) > 0 {
		return GetPlanExecItemReqMultiError(errors)
	}

	return nil
}

// GetPlanExecItemReqMultiError is an error wrapping multiple validation errors
// returned by GetPlanExecItemReq.ValidateAll() if the designated constraints
// aren't met.
type GetPlanExecItemReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetPlanExecItemReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetPlanExecItemReqMultiError) AllErrors() []error { return m }

// GetPlanExecItemReqValidationError is the validation error returned by
// GetPlanExecItemReq.Validate if the designated constraints aren't met.
type GetPlanExecItemReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetPlanExecItemReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetPlanExecItemReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetPlanExecItemReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetPlanExecItemReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetPlanExecItemReqValidationError) ErrorName() string {
	return "GetPlanExecItemReqValidationError"
}

// Error satisfies the builtin error interface
func (e GetPlanExecItemReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetPlanExecItemReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetPlanExecItemReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetPlanExecItemReqValidationError{}

// Validate checks the field values on GetPlanExecItemRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetPlanExecItemRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetPlanExecItemRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetPlanExecItemResMultiError, or nil if none found.
func (m *GetPlanExecItemRes) ValidateAll() error {
	return m.validate(true)
}

func (m *GetPlanExecItemRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetPlanExecItem() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetPlanExecItemResValidationError{
						field:  fmt.Sprintf("PlanExecItem[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetPlanExecItemResValidationError{
						field:  fmt.Sprintf("PlanExecItem[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetPlanExecItemResValidationError{
					field:  fmt.Sprintf("PlanExecItem[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetPlanExecItemResMultiError(errors)
	}

	return nil
}

// GetPlanExecItemResMultiError is an error wrapping multiple validation errors
// returned by GetPlanExecItemRes.ValidateAll() if the designated constraints
// aren't met.
type GetPlanExecItemResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetPlanExecItemResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetPlanExecItemResMultiError) AllErrors() []error { return m }

// GetPlanExecItemResValidationError is the validation error returned by
// GetPlanExecItemRes.Validate if the designated constraints aren't met.
type GetPlanExecItemResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetPlanExecItemResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetPlanExecItemResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetPlanExecItemResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetPlanExecItemResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetPlanExecItemResValidationError) ErrorName() string {
	return "GetPlanExecItemResValidationError"
}

// Error satisfies the builtin error interface
func (e GetPlanExecItemResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetPlanExecItemRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetPlanExecItemResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetPlanExecItemResValidationError{}

// Validate checks the field values on PbPlanExecItem with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PbPlanExecItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PbPlanExecItem with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PbPlanExecItemMultiError,
// or nil if none found.
func (m *PbPlanExecItem) ValidateAll() error {
	return m.validate(true)
}

func (m *PbPlanExecItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CreateTime

	// no validation rules for UpdateTime

	// no validation rules for CreateUser

	// no validation rules for UpdateUser

	// no validation rules for DeptCode

	// no validation rules for Id

	// no validation rules for PlanPk

	// no validation rules for PlanId

	// no validation rules for BatchPk

	// no validation rules for BatchId

	// no validation rules for ExecId

	// no validation rules for ItemId

	// no validation rules for ItemType

	// no validation rules for ItemName

	// no validation rules for ItemRowId

	// no validation rules for PointId

	// no validation rules for Payload

	// no validation rules for RequestTimeout

	// no validation rules for PlanTriggerTime

	// no validation rules for NextTriggerTime

	// no validation rules for LastTriggerTime

	// no validation rules for TriggerCount

	// no validation rules for Status

	// no validation rules for LastResult

	// no validation rules for LastMessage

	// no validation rules for LastReason

	// no validation rules for TerminatedReason

	// no validation rules for PausedTime

	// no validation rules for PausedReason

	// no validation rules for Ext1

	// no validation rules for Ext2

	// no validation rules for Ext3

	// no validation rules for Ext4

	// no validation rules for Ext5

	if len(errors) > 0 {
		return PbPlanExecItemMultiError(errors)
	}

	return nil
}

// PbPlanExecItemMultiError is an error wrapping multiple validation errors
// returned by PbPlanExecItem.ValidateAll() if the designated constraints
// aren't met.
type PbPlanExecItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PbPlanExecItemMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PbPlanExecItemMultiError) AllErrors() []error { return m }

// PbPlanExecItemValidationError is the validation error returned by
// PbPlanExecItem.Validate if the designated constraints aren't met.
type PbPlanExecItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PbPlanExecItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PbPlanExecItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PbPlanExecItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PbPlanExecItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PbPlanExecItemValidationError) ErrorName() string { return "PbPlanExecItemValidationError" }

// Error satisfies the builtin error interface
func (e PbPlanExecItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPbPlanExecItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PbPlanExecItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PbPlanExecItemValidationError{}

// Validate checks the field values on ListPlanExecItemsReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListPlanExecItemsReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListPlanExecItemsReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListPlanExecItemsReqMultiError, or nil if none found.
func (m *ListPlanExecItemsReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListPlanExecItemsReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCurrentUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListPlanExecItemsReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListPlanExecItemsReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrentUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListPlanExecItemsReqValidationError{
				field:  "CurrentUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetPageSize() < 0 {
		err := ListPlanExecItemsReqValidationError{
			field:  "PageSize",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetPageNum() < 0 {
		err := ListPlanExecItemsReqValidationError{
			field:  "PageNum",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetId() < 0 {
		err := ListPlanExecItemsReqValidationError{
			field:  "Id",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ExecId

	// no validation rules for PlanId

	// no validation rules for BatchId

	// no validation rules for ItemId

	// no validation rules for ItemName

	if len(errors) > 0 {
		return ListPlanExecItemsReqMultiError(errors)
	}

	return nil
}

// ListPlanExecItemsReqMultiError is an error wrapping multiple validation
// errors returned by ListPlanExecItemsReq.ValidateAll() if the designated
// constraints aren't met.
type ListPlanExecItemsReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListPlanExecItemsReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListPlanExecItemsReqMultiError) AllErrors() []error { return m }

// ListPlanExecItemsReqValidationError is the validation error returned by
// ListPlanExecItemsReq.Validate if the designated constraints aren't met.
type ListPlanExecItemsReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListPlanExecItemsReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListPlanExecItemsReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListPlanExecItemsReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListPlanExecItemsReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListPlanExecItemsReqValidationError) ErrorName() string {
	return "ListPlanExecItemsReqValidationError"
}

// Error satisfies the builtin error interface
func (e ListPlanExecItemsReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListPlanExecItemsReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListPlanExecItemsReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListPlanExecItemsReqValidationError{}

// Validate checks the field values on ListPlanExecItemsRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListPlanExecItemsRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListPlanExecItemsRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListPlanExecItemsResMultiError, or nil if none found.
func (m *ListPlanExecItemsRes) ValidateAll() error {
	return m.validate(true)
}

func (m *ListPlanExecItemsRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetPlanExecItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListPlanExecItemsResValidationError{
						field:  fmt.Sprintf("PlanExecItems[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListPlanExecItemsResValidationError{
						field:  fmt.Sprintf("PlanExecItems[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListPlanExecItemsResValidationError{
					field:  fmt.Sprintf("PlanExecItems[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Total

	if len(errors) > 0 {
		return ListPlanExecItemsResMultiError(errors)
	}

	return nil
}

// ListPlanExecItemsResMultiError is an error wrapping multiple validation
// errors returned by ListPlanExecItemsRes.ValidateAll() if the designated
// constraints aren't met.
type ListPlanExecItemsResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListPlanExecItemsResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListPlanExecItemsResMultiError) AllErrors() []error { return m }

// ListPlanExecItemsResValidationError is the validation error returned by
// ListPlanExecItemsRes.Validate if the designated constraints aren't met.
type ListPlanExecItemsResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListPlanExecItemsResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListPlanExecItemsResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListPlanExecItemsResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListPlanExecItemsResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListPlanExecItemsResValidationError) ErrorName() string {
	return "ListPlanExecItemsResValidationError"
}

// Error satisfies the builtin error interface
func (e ListPlanExecItemsResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListPlanExecItemsRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListPlanExecItemsResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListPlanExecItemsResValidationError{}

// Validate checks the field values on GetPlanExecLogReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetPlanExecLogReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetPlanExecLogReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetPlanExecLogReqMultiError, or nil if none found.
func (m *GetPlanExecLogReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetPlanExecLogReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCurrentUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetPlanExecLogReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetPlanExecLogReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrentUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetPlanExecLogReqValidationError{
				field:  "CurrentUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetId() < 1 {
		err := GetPlanExecLogReqValidationError{
			field:  "Id",
			reason: "value must be greater than or equal to 1",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetPlanExecLogReqMultiError(errors)
	}

	return nil
}

// GetPlanExecLogReqMultiError is an error wrapping multiple validation errors
// returned by GetPlanExecLogReq.ValidateAll() if the designated constraints
// aren't met.
type GetPlanExecLogReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetPlanExecLogReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetPlanExecLogReqMultiError) AllErrors() []error { return m }

// GetPlanExecLogReqValidationError is the validation error returned by
// GetPlanExecLogReq.Validate if the designated constraints aren't met.
type GetPlanExecLogReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetPlanExecLogReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetPlanExecLogReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetPlanExecLogReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetPlanExecLogReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetPlanExecLogReqValidationError) ErrorName() string {
	return "GetPlanExecLogReqValidationError"
}

// Error satisfies the builtin error interface
func (e GetPlanExecLogReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetPlanExecLogReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetPlanExecLogReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetPlanExecLogReqValidationError{}

// Validate checks the field values on GetPlanExecLogRes with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetPlanExecLogRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetPlanExecLogRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetPlanExecLogResMultiError, or nil if none found.
func (m *GetPlanExecLogRes) ValidateAll() error {
	return m.validate(true)
}

func (m *GetPlanExecLogRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPlanExecLog()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetPlanExecLogResValidationError{
					field:  "PlanExecLog",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetPlanExecLogResValidationError{
					field:  "PlanExecLog",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPlanExecLog()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetPlanExecLogResValidationError{
				field:  "PlanExecLog",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetPlanExecLogResMultiError(errors)
	}

	return nil
}

// GetPlanExecLogResMultiError is an error wrapping multiple validation errors
// returned by GetPlanExecLogRes.ValidateAll() if the designated constraints
// aren't met.
type GetPlanExecLogResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetPlanExecLogResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetPlanExecLogResMultiError) AllErrors() []error { return m }

// GetPlanExecLogResValidationError is the validation error returned by
// GetPlanExecLogRes.Validate if the designated constraints aren't met.
type GetPlanExecLogResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetPlanExecLogResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetPlanExecLogResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetPlanExecLogResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetPlanExecLogResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetPlanExecLogResValidationError) ErrorName() string {
	return "GetPlanExecLogResValidationError"
}

// Error satisfies the builtin error interface
func (e GetPlanExecLogResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetPlanExecLogRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetPlanExecLogResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetPlanExecLogResValidationError{}

// Validate checks the field values on ListPlanExecLogsReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListPlanExecLogsReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListPlanExecLogsReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListPlanExecLogsReqMultiError, or nil if none found.
func (m *ListPlanExecLogsReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListPlanExecLogsReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCurrentUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListPlanExecLogsReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListPlanExecLogsReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrentUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListPlanExecLogsReqValidationError{
				field:  "CurrentUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetPageSize() < 0 {
		err := ListPlanExecLogsReqValidationError{
			field:  "PageSize",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetPageNum() < 0 {
		err := ListPlanExecLogsReqValidationError{
			field:  "PageNum",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for PlanId

	// no validation rules for BatchId

	// no validation rules for ItemId

	// no validation rules for ExecId

	// no validation rules for StartTime

	// no validation rules for EndTime

	if len(errors) > 0 {
		return ListPlanExecLogsReqMultiError(errors)
	}

	return nil
}

// ListPlanExecLogsReqMultiError is an error wrapping multiple validation
// errors returned by ListPlanExecLogsReq.ValidateAll() if the designated
// constraints aren't met.
type ListPlanExecLogsReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListPlanExecLogsReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListPlanExecLogsReqMultiError) AllErrors() []error { return m }

// ListPlanExecLogsReqValidationError is the validation error returned by
// ListPlanExecLogsReq.Validate if the designated constraints aren't met.
type ListPlanExecLogsReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListPlanExecLogsReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListPlanExecLogsReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListPlanExecLogsReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListPlanExecLogsReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListPlanExecLogsReqValidationError) ErrorName() string {
	return "ListPlanExecLogsReqValidationError"
}

// Error satisfies the builtin error interface
func (e ListPlanExecLogsReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListPlanExecLogsReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListPlanExecLogsReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListPlanExecLogsReqValidationError{}

// Validate checks the field values on ListPlanExecLogsRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListPlanExecLogsRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListPlanExecLogsRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListPlanExecLogsResMultiError, or nil if none found.
func (m *ListPlanExecLogsRes) ValidateAll() error {
	return m.validate(true)
}

func (m *ListPlanExecLogsRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetPlanExecLogs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListPlanExecLogsResValidationError{
						field:  fmt.Sprintf("PlanExecLogs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListPlanExecLogsResValidationError{
						field:  fmt.Sprintf("PlanExecLogs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListPlanExecLogsResValidationError{
					field:  fmt.Sprintf("PlanExecLogs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Total

	if len(errors) > 0 {
		return ListPlanExecLogsResMultiError(errors)
	}

	return nil
}

// ListPlanExecLogsResMultiError is an error wrapping multiple validation
// errors returned by ListPlanExecLogsRes.ValidateAll() if the designated
// constraints aren't met.
type ListPlanExecLogsResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListPlanExecLogsResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListPlanExecLogsResMultiError) AllErrors() []error { return m }

// ListPlanExecLogsResValidationError is the validation error returned by
// ListPlanExecLogsRes.Validate if the designated constraints aren't met.
type ListPlanExecLogsResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListPlanExecLogsResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListPlanExecLogsResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListPlanExecLogsResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListPlanExecLogsResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListPlanExecLogsResValidationError) ErrorName() string {
	return "ListPlanExecLogsResValidationError"
}

// Error satisfies the builtin error interface
func (e ListPlanExecLogsResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListPlanExecLogsRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListPlanExecLogsResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListPlanExecLogsResValidationError{}

// Validate checks the field values on PbPlanExecLog with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PbPlanExecLog) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PbPlanExecLog with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PbPlanExecLogMultiError, or
// nil if none found.
func (m *PbPlanExecLog) ValidateAll() error {
	return m.validate(true)
}

func (m *PbPlanExecLog) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CreateTime

	// no validation rules for UpdateTime

	// no validation rules for CreateUser

	// no validation rules for UpdateUser

	// no validation rules for DeptCode

	// no validation rules for Id

	// no validation rules for PlanPk

	// no validation rules for PlanId

	// no validation rules for PlanName

	// no validation rules for BatchPk

	// no validation rules for BatchId

	// no validation rules for ItemPk

	// no validation rules for ExecId

	// no validation rules for ItemId

	// no validation rules for ItemType

	// no validation rules for ItemName

	// no validation rules for PointId

	// no validation rules for TriggerTime

	// no validation rules for ExecResult

	// no validation rules for Message

	if len(errors) > 0 {
		return PbPlanExecLogMultiError(errors)
	}

	return nil
}

// PbPlanExecLogMultiError is an error wrapping multiple validation errors
// returned by PbPlanExecLog.ValidateAll() if the designated constraints
// aren't met.
type PbPlanExecLogMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PbPlanExecLogMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PbPlanExecLogMultiError) AllErrors() []error { return m }

// PbPlanExecLogValidationError is the validation error returned by
// PbPlanExecLog.Validate if the designated constraints aren't met.
type PbPlanExecLogValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PbPlanExecLogValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PbPlanExecLogValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PbPlanExecLogValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PbPlanExecLogValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PbPlanExecLogValidationError) ErrorName() string { return "PbPlanExecLogValidationError" }

// Error satisfies the builtin error interface
func (e PbPlanExecLogValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPbPlanExecLog.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PbPlanExecLogValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PbPlanExecLogValidationError{}

// Validate checks the field values on PbPlanBatch with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PbPlanBatch) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PbPlanBatch with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PbPlanBatchMultiError, or
// nil if none found.
func (m *PbPlanBatch) ValidateAll() error {
	return m.validate(true)
}

func (m *PbPlanBatch) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CreateTime

	// no validation rules for UpdateTime

	// no validation rules for CreateUser

	// no validation rules for UpdateUser

	// no validation rules for DeptCode

	// no validation rules for Id

	// no validation rules for PlanPk

	// no validation rules for PlanId

	// no validation rules for BatchId

	// no validation rules for BatchName

	// no validation rules for BatchNum

	// no validation rules for Status

	// no validation rules for PlanTriggerTime

	// no validation rules for TerminatedReason

	// no validation rules for PausedTime

	// no validation rules for PausedReason

	// no validation rules for FinishedTime

	// no validation rules for StatusCountMap

	// no validation rules for ExecCnt

	// no validation rules for Ext1

	// no validation rules for Ext2

	// no validation rules for Ext3

	// no validation rules for Ext4

	// no validation rules for Ext5

	if len(errors) > 0 {
		return PbPlanBatchMultiError(errors)
	}

	return nil
}

// PbPlanBatchMultiError is an error wrapping multiple validation errors
// returned by PbPlanBatch.ValidateAll() if the designated constraints aren't met.
type PbPlanBatchMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PbPlanBatchMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PbPlanBatchMultiError) AllErrors() []error { return m }

// PbPlanBatchValidationError is the validation error returned by
// PbPlanBatch.Validate if the designated constraints aren't met.
type PbPlanBatchValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PbPlanBatchValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PbPlanBatchValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PbPlanBatchValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PbPlanBatchValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PbPlanBatchValidationError) ErrorName() string { return "PbPlanBatchValidationError" }

// Error satisfies the builtin error interface
func (e PbPlanBatchValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPbPlanBatch.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PbPlanBatchValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PbPlanBatchValidationError{}

// Validate checks the field values on CallbackPlanExecItemReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CallbackPlanExecItemReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CallbackPlanExecItemReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CallbackPlanExecItemReqMultiError, or nil if none found.
func (m *CallbackPlanExecItemReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CallbackPlanExecItemReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCurrentUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CallbackPlanExecItemReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CallbackPlanExecItemReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrentUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CallbackPlanExecItemReqValidationError{
				field:  "CurrentUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Id

	// no validation rules for ExecId

	if _, ok := _CallbackPlanExecItemReq_ExecResult_InLookup[m.GetExecResult()]; !ok {
		err := CallbackPlanExecItemReqValidationError{
			field:  "ExecResult",
			reason: "value must be in list [completed terminated failed delayed ongoing]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetMessage()) > 1000 {
		err := CallbackPlanExecItemReqValidationError{
			field:  "Message",
			reason: "value length must be at most 1000 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetReason()) > 1000 {
		err := CallbackPlanExecItemReqValidationError{
			field:  "Reason",
			reason: "value length must be at most 1000 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetDelayConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CallbackPlanExecItemReqValidationError{
					field:  "DelayConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CallbackPlanExecItemReqValidationError{
					field:  "DelayConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDelayConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CallbackPlanExecItemReqValidationError{
				field:  "DelayConfig",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CallbackPlanExecItemReqMultiError(errors)
	}

	return nil
}

// CallbackPlanExecItemReqMultiError is an error wrapping multiple validation
// errors returned by CallbackPlanExecItemReq.ValidateAll() if the designated
// constraints aren't met.
type CallbackPlanExecItemReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CallbackPlanExecItemReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CallbackPlanExecItemReqMultiError) AllErrors() []error { return m }

// CallbackPlanExecItemReqValidationError is the validation error returned by
// CallbackPlanExecItemReq.Validate if the designated constraints aren't met.
type CallbackPlanExecItemReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CallbackPlanExecItemReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CallbackPlanExecItemReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CallbackPlanExecItemReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CallbackPlanExecItemReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CallbackPlanExecItemReqValidationError) ErrorName() string {
	return "CallbackPlanExecItemReqValidationError"
}

// Error satisfies the builtin error interface
func (e CallbackPlanExecItemReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCallbackPlanExecItemReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CallbackPlanExecItemReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CallbackPlanExecItemReqValidationError{}

var _CallbackPlanExecItemReq_ExecResult_InLookup = map[string]struct{}{
	"completed":  {},
	"terminated": {},
	"failed":     {},
	"delayed":    {},
	"ongoing":    {},
}

// Validate checks the field values on PbDelayConfig with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PbDelayConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PbDelayConfig with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PbDelayConfigMultiError, or
// nil if none found.
func (m *PbDelayConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *PbDelayConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for NextTriggerTime

	if utf8.RuneCountInString(m.GetDelayReason()) > 1000 {
		err := PbDelayConfigValidationError{
			field:  "DelayReason",
			reason: "value length must be at most 1000 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return PbDelayConfigMultiError(errors)
	}

	return nil
}

// PbDelayConfigMultiError is an error wrapping multiple validation errors
// returned by PbDelayConfig.ValidateAll() if the designated constraints
// aren't met.
type PbDelayConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PbDelayConfigMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PbDelayConfigMultiError) AllErrors() []error { return m }

// PbDelayConfigValidationError is the validation error returned by
// PbDelayConfig.Validate if the designated constraints aren't met.
type PbDelayConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PbDelayConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PbDelayConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PbDelayConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PbDelayConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PbDelayConfigValidationError) ErrorName() string { return "PbDelayConfigValidationError" }

// Error satisfies the builtin error interface
func (e PbDelayConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPbDelayConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PbDelayConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PbDelayConfigValidationError{}

// Validate checks the field values on CallbackPlanExecItemRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CallbackPlanExecItemRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CallbackPlanExecItemRes with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CallbackPlanExecItemResMultiError, or nil if none found.
func (m *CallbackPlanExecItemRes) ValidateAll() error {
	return m.validate(true)
}

func (m *CallbackPlanExecItemRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return CallbackPlanExecItemResMultiError(errors)
	}

	return nil
}

// CallbackPlanExecItemResMultiError is an error wrapping multiple validation
// errors returned by CallbackPlanExecItemRes.ValidateAll() if the designated
// constraints aren't met.
type CallbackPlanExecItemResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CallbackPlanExecItemResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CallbackPlanExecItemResMultiError) AllErrors() []error { return m }

// CallbackPlanExecItemResValidationError is the validation error returned by
// CallbackPlanExecItemRes.Validate if the designated constraints aren't met.
type CallbackPlanExecItemResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CallbackPlanExecItemResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CallbackPlanExecItemResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CallbackPlanExecItemResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CallbackPlanExecItemResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CallbackPlanExecItemResValidationError) ErrorName() string {
	return "CallbackPlanExecItemResValidationError"
}

// Error satisfies the builtin error interface
func (e CallbackPlanExecItemResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCallbackPlanExecItemRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CallbackPlanExecItemResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CallbackPlanExecItemResValidationError{}

// Validate checks the field values on NextIdReq with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NextIdReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NextIdReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NextIdReqMultiError, or nil
// if none found.
func (m *NextIdReq) ValidateAll() error {
	return m.validate(true)
}

func (m *NextIdReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetOutDescType()) > 64 {
		err := NextIdReqValidationError{
			field:  "OutDescType",
			reason: "value length must be at most 64 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Separate

	if len(errors) > 0 {
		return NextIdReqMultiError(errors)
	}

	return nil
}

// NextIdReqMultiError is an error wrapping multiple validation errors returned
// by NextIdReq.ValidateAll() if the designated constraints aren't met.
type NextIdReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NextIdReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NextIdReqMultiError) AllErrors() []error { return m }

// NextIdReqValidationError is the validation error returned by
// NextIdReq.Validate if the designated constraints aren't met.
type NextIdReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NextIdReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NextIdReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NextIdReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NextIdReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NextIdReqValidationError) ErrorName() string { return "NextIdReqValidationError" }

// Error satisfies the builtin error interface
func (e NextIdReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNextIdReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NextIdReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NextIdReqValidationError{}

// Validate checks the field values on NextIdRes with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NextIdRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NextIdRes with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NextIdResMultiError, or nil
// if none found.
func (m *NextIdRes) ValidateAll() error {
	return m.validate(true)
}

func (m *NextIdRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for NextId

	if len(errors) > 0 {
		return NextIdResMultiError(errors)
	}

	return nil
}

// NextIdResMultiError is an error wrapping multiple validation errors returned
// by NextIdRes.ValidateAll() if the designated constraints aren't met.
type NextIdResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NextIdResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NextIdResMultiError) AllErrors() []error { return m }

// NextIdResValidationError is the validation error returned by
// NextIdRes.Validate if the designated constraints aren't met.
type NextIdResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NextIdResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NextIdResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NextIdResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NextIdResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NextIdResValidationError) ErrorName() string { return "NextIdResValidationError" }

// Error satisfies the builtin error interface
func (e NextIdResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNextIdRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NextIdResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NextIdResValidationError{}
