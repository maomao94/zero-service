// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: trigger.proto

package trigger

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on PbTaskInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PbTaskInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PbTaskInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PbTaskInfoMultiError, or
// nil if none found.
func (m *PbTaskInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *PbTaskInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Queue

	// no validation rules for Type

	// no validation rules for Payload

	// no validation rules for State

	// no validation rules for MaxRetry

	// no validation rules for Retried

	// no validation rules for LastErr

	// no validation rules for LastFailedAt

	// no validation rules for Timeout

	// no validation rules for Deadline

	// no validation rules for Group

	// no validation rules for NextProcessAt

	// no validation rules for IsOrphaned

	// no validation rules for Retention

	// no validation rules for CompletedAt

	// no validation rules for Result

	if len(errors) > 0 {
		return PbTaskInfoMultiError(errors)
	}

	return nil
}

// PbTaskInfoMultiError is an error wrapping multiple validation errors
// returned by PbTaskInfo.ValidateAll() if the designated constraints aren't met.
type PbTaskInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PbTaskInfoMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PbTaskInfoMultiError) AllErrors() []error { return m }

// PbTaskInfoValidationError is the validation error returned by
// PbTaskInfo.Validate if the designated constraints aren't met.
type PbTaskInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PbTaskInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PbTaskInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PbTaskInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PbTaskInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PbTaskInfoValidationError) ErrorName() string { return "PbTaskInfoValidationError" }

// Error satisfies the builtin error interface
func (e PbTaskInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPbTaskInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PbTaskInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PbTaskInfoValidationError{}

// Validate checks the field values on PbDailyStats with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PbDailyStats) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PbDailyStats with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PbDailyStatsMultiError, or
// nil if none found.
func (m *PbDailyStats) ValidateAll() error {
	return m.validate(true)
}

func (m *PbDailyStats) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Queue

	// no validation rules for Processed

	// no validation rules for Failed

	// no validation rules for Date

	if len(errors) > 0 {
		return PbDailyStatsMultiError(errors)
	}

	return nil
}

// PbDailyStatsMultiError is an error wrapping multiple validation errors
// returned by PbDailyStats.ValidateAll() if the designated constraints aren't met.
type PbDailyStatsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PbDailyStatsMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PbDailyStatsMultiError) AllErrors() []error { return m }

// PbDailyStatsValidationError is the validation error returned by
// PbDailyStats.Validate if the designated constraints aren't met.
type PbDailyStatsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PbDailyStatsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PbDailyStatsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PbDailyStatsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PbDailyStatsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PbDailyStatsValidationError) ErrorName() string { return "PbDailyStatsValidationError" }

// Error satisfies the builtin error interface
func (e PbDailyStatsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPbDailyStats.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PbDailyStatsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PbDailyStatsValidationError{}

// Validate checks the field values on Req with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Req) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Req with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ReqMultiError, or nil if none found.
func (m *Req) ValidateAll() error {
	return m.validate(true)
}

func (m *Req) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Ping

	if len(errors) > 0 {
		return ReqMultiError(errors)
	}

	return nil
}

// ReqMultiError is an error wrapping multiple validation errors returned by
// Req.ValidateAll() if the designated constraints aren't met.
type ReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReqMultiError) AllErrors() []error { return m }

// ReqValidationError is the validation error returned by Req.Validate if the
// designated constraints aren't met.
type ReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReqValidationError) ErrorName() string { return "ReqValidationError" }

// Error satisfies the builtin error interface
func (e ReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReqValidationError{}

// Validate checks the field values on Res with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Res) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Res with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ResMultiError, or nil if none found.
func (m *Res) ValidateAll() error {
	return m.validate(true)
}

func (m *Res) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Pong

	if len(errors) > 0 {
		return ResMultiError(errors)
	}

	return nil
}

// ResMultiError is an error wrapping multiple validation errors returned by
// Res.ValidateAll() if the designated constraints aren't met.
type ResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResMultiError) AllErrors() []error { return m }

// ResValidationError is the validation error returned by Res.Validate if the
// designated constraints aren't met.
type ResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResValidationError) ErrorName() string { return "ResValidationError" }

// Error satisfies the builtin error interface
func (e ResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResValidationError{}

// Validate checks the field values on SendTriggerReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SendTriggerReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SendTriggerReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SendTriggerReqMultiError,
// or nil if none found.
func (m *SendTriggerReq) ValidateAll() error {
	return m.validate(true)
}

func (m *SendTriggerReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCurrentUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SendTriggerReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SendTriggerReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrentUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SendTriggerReqValidationError{
				field:  "CurrentUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ProcessIn

	// no validation rules for TriggerTime

	// no validation rules for Url

	// no validation rules for MaxRetry

	// no validation rules for MsgId

	// no validation rules for Body

	if len(errors) > 0 {
		return SendTriggerReqMultiError(errors)
	}

	return nil
}

// SendTriggerReqMultiError is an error wrapping multiple validation errors
// returned by SendTriggerReq.ValidateAll() if the designated constraints
// aren't met.
type SendTriggerReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SendTriggerReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SendTriggerReqMultiError) AllErrors() []error { return m }

// SendTriggerReqValidationError is the validation error returned by
// SendTriggerReq.Validate if the designated constraints aren't met.
type SendTriggerReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SendTriggerReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SendTriggerReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SendTriggerReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SendTriggerReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SendTriggerReqValidationError) ErrorName() string { return "SendTriggerReqValidationError" }

// Error satisfies the builtin error interface
func (e SendTriggerReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSendTriggerReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SendTriggerReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SendTriggerReqValidationError{}

// Validate checks the field values on SendTriggerRes with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SendTriggerRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SendTriggerRes with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SendTriggerResMultiError,
// or nil if none found.
func (m *SendTriggerRes) ValidateAll() error {
	return m.validate(true)
}

func (m *SendTriggerRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TraceId

	// no validation rules for Queue

	// no validation rules for Id

	if len(errors) > 0 {
		return SendTriggerResMultiError(errors)
	}

	return nil
}

// SendTriggerResMultiError is an error wrapping multiple validation errors
// returned by SendTriggerRes.ValidateAll() if the designated constraints
// aren't met.
type SendTriggerResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SendTriggerResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SendTriggerResMultiError) AllErrors() []error { return m }

// SendTriggerResValidationError is the validation error returned by
// SendTriggerRes.Validate if the designated constraints aren't met.
type SendTriggerResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SendTriggerResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SendTriggerResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SendTriggerResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SendTriggerResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SendTriggerResValidationError) ErrorName() string { return "SendTriggerResValidationError" }

// Error satisfies the builtin error interface
func (e SendTriggerResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSendTriggerRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SendTriggerResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SendTriggerResValidationError{}

// Validate checks the field values on SendProtoTriggerReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SendProtoTriggerReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SendProtoTriggerReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SendProtoTriggerReqMultiError, or nil if none found.
func (m *SendProtoTriggerReq) ValidateAll() error {
	return m.validate(true)
}

func (m *SendProtoTriggerReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCurrentUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SendProtoTriggerReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SendProtoTriggerReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrentUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SendProtoTriggerReqValidationError{
				field:  "CurrentUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ProcessIn

	// no validation rules for TriggerTime

	// no validation rules for MaxRetry

	// no validation rules for MsgId

	// no validation rules for GrpcServer

	// no validation rules for Method

	// no validation rules for Payload

	// no validation rules for RequestTimeout

	if len(errors) > 0 {
		return SendProtoTriggerReqMultiError(errors)
	}

	return nil
}

// SendProtoTriggerReqMultiError is an error wrapping multiple validation
// errors returned by SendProtoTriggerReq.ValidateAll() if the designated
// constraints aren't met.
type SendProtoTriggerReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SendProtoTriggerReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SendProtoTriggerReqMultiError) AllErrors() []error { return m }

// SendProtoTriggerReqValidationError is the validation error returned by
// SendProtoTriggerReq.Validate if the designated constraints aren't met.
type SendProtoTriggerReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SendProtoTriggerReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SendProtoTriggerReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SendProtoTriggerReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SendProtoTriggerReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SendProtoTriggerReqValidationError) ErrorName() string {
	return "SendProtoTriggerReqValidationError"
}

// Error satisfies the builtin error interface
func (e SendProtoTriggerReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSendProtoTriggerReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SendProtoTriggerReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SendProtoTriggerReqValidationError{}

// Validate checks the field values on SendProtoTriggerRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SendProtoTriggerRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SendProtoTriggerRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SendProtoTriggerResMultiError, or nil if none found.
func (m *SendProtoTriggerRes) ValidateAll() error {
	return m.validate(true)
}

func (m *SendProtoTriggerRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TraceId

	// no validation rules for Queue

	// no validation rules for Id

	if len(errors) > 0 {
		return SendProtoTriggerResMultiError(errors)
	}

	return nil
}

// SendProtoTriggerResMultiError is an error wrapping multiple validation
// errors returned by SendProtoTriggerRes.ValidateAll() if the designated
// constraints aren't met.
type SendProtoTriggerResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SendProtoTriggerResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SendProtoTriggerResMultiError) AllErrors() []error { return m }

// SendProtoTriggerResValidationError is the validation error returned by
// SendProtoTriggerRes.Validate if the designated constraints aren't met.
type SendProtoTriggerResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SendProtoTriggerResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SendProtoTriggerResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SendProtoTriggerResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SendProtoTriggerResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SendProtoTriggerResValidationError) ErrorName() string {
	return "SendProtoTriggerResValidationError"
}

// Error satisfies the builtin error interface
func (e SendProtoTriggerResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSendProtoTriggerRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SendProtoTriggerResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SendProtoTriggerResValidationError{}

// Validate checks the field values on ArchiveTaskReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ArchiveTaskReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ArchiveTaskReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ArchiveTaskReqMultiError,
// or nil if none found.
func (m *ArchiveTaskReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ArchiveTaskReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCurrentUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ArchiveTaskReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ArchiveTaskReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrentUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ArchiveTaskReqValidationError{
				field:  "CurrentUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if utf8.RuneCountInString(m.GetQueue()) < 1 {
		err := ArchiveTaskReqValidationError{
			field:  "Queue",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetId()) < 1 {
		err := ArchiveTaskReqValidationError{
			field:  "Id",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ArchiveTaskReqMultiError(errors)
	}

	return nil
}

// ArchiveTaskReqMultiError is an error wrapping multiple validation errors
// returned by ArchiveTaskReq.ValidateAll() if the designated constraints
// aren't met.
type ArchiveTaskReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ArchiveTaskReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ArchiveTaskReqMultiError) AllErrors() []error { return m }

// ArchiveTaskReqValidationError is the validation error returned by
// ArchiveTaskReq.Validate if the designated constraints aren't met.
type ArchiveTaskReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ArchiveTaskReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ArchiveTaskReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ArchiveTaskReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ArchiveTaskReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ArchiveTaskReqValidationError) ErrorName() string { return "ArchiveTaskReqValidationError" }

// Error satisfies the builtin error interface
func (e ArchiveTaskReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sArchiveTaskReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ArchiveTaskReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ArchiveTaskReqValidationError{}

// Validate checks the field values on ArchiveTaskRes with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ArchiveTaskRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ArchiveTaskRes with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ArchiveTaskResMultiError,
// or nil if none found.
func (m *ArchiveTaskRes) ValidateAll() error {
	return m.validate(true)
}

func (m *ArchiveTaskRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ArchiveTaskResMultiError(errors)
	}

	return nil
}

// ArchiveTaskResMultiError is an error wrapping multiple validation errors
// returned by ArchiveTaskRes.ValidateAll() if the designated constraints
// aren't met.
type ArchiveTaskResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ArchiveTaskResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ArchiveTaskResMultiError) AllErrors() []error { return m }

// ArchiveTaskResValidationError is the validation error returned by
// ArchiveTaskRes.Validate if the designated constraints aren't met.
type ArchiveTaskResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ArchiveTaskResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ArchiveTaskResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ArchiveTaskResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ArchiveTaskResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ArchiveTaskResValidationError) ErrorName() string { return "ArchiveTaskResValidationError" }

// Error satisfies the builtin error interface
func (e ArchiveTaskResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sArchiveTaskRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ArchiveTaskResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ArchiveTaskResValidationError{}

// Validate checks the field values on DeleteTaskReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DeleteTaskReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteTaskReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DeleteTaskReqMultiError, or
// nil if none found.
func (m *DeleteTaskReq) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteTaskReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCurrentUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteTaskReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteTaskReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrentUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteTaskReqValidationError{
				field:  "CurrentUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if utf8.RuneCountInString(m.GetQueue()) < 1 {
		err := DeleteTaskReqValidationError{
			field:  "Queue",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetId()) < 1 {
		err := DeleteTaskReqValidationError{
			field:  "Id",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteTaskReqMultiError(errors)
	}

	return nil
}

// DeleteTaskReqMultiError is an error wrapping multiple validation errors
// returned by DeleteTaskReq.ValidateAll() if the designated constraints
// aren't met.
type DeleteTaskReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteTaskReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteTaskReqMultiError) AllErrors() []error { return m }

// DeleteTaskReqValidationError is the validation error returned by
// DeleteTaskReq.Validate if the designated constraints aren't met.
type DeleteTaskReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteTaskReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteTaskReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteTaskReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteTaskReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteTaskReqValidationError) ErrorName() string { return "DeleteTaskReqValidationError" }

// Error satisfies the builtin error interface
func (e DeleteTaskReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteTaskReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteTaskReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteTaskReqValidationError{}

// Validate checks the field values on DeleteTaskRes with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DeleteTaskRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteTaskRes with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DeleteTaskResMultiError, or
// nil if none found.
func (m *DeleteTaskRes) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteTaskRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DeleteTaskResMultiError(errors)
	}

	return nil
}

// DeleteTaskResMultiError is an error wrapping multiple validation errors
// returned by DeleteTaskRes.ValidateAll() if the designated constraints
// aren't met.
type DeleteTaskResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteTaskResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteTaskResMultiError) AllErrors() []error { return m }

// DeleteTaskResValidationError is the validation error returned by
// DeleteTaskRes.Validate if the designated constraints aren't met.
type DeleteTaskResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteTaskResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteTaskResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteTaskResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteTaskResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteTaskResValidationError) ErrorName() string { return "DeleteTaskResValidationError" }

// Error satisfies the builtin error interface
func (e DeleteTaskResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteTaskRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteTaskResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteTaskResValidationError{}

// Validate checks the field values on GetTaskInfoReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetTaskInfoReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTaskInfoReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetTaskInfoReqMultiError,
// or nil if none found.
func (m *GetTaskInfoReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTaskInfoReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCurrentUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetTaskInfoReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetTaskInfoReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrentUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetTaskInfoReqValidationError{
				field:  "CurrentUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if utf8.RuneCountInString(m.GetQueue()) < 1 {
		err := GetTaskInfoReqValidationError{
			field:  "Queue",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetId()) < 1 {
		err := GetTaskInfoReqValidationError{
			field:  "Id",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetTaskInfoReqMultiError(errors)
	}

	return nil
}

// GetTaskInfoReqMultiError is an error wrapping multiple validation errors
// returned by GetTaskInfoReq.ValidateAll() if the designated constraints
// aren't met.
type GetTaskInfoReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTaskInfoReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTaskInfoReqMultiError) AllErrors() []error { return m }

// GetTaskInfoReqValidationError is the validation error returned by
// GetTaskInfoReq.Validate if the designated constraints aren't met.
type GetTaskInfoReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTaskInfoReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTaskInfoReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTaskInfoReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTaskInfoReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTaskInfoReqValidationError) ErrorName() string { return "GetTaskInfoReqValidationError" }

// Error satisfies the builtin error interface
func (e GetTaskInfoReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTaskInfoReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTaskInfoReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTaskInfoReqValidationError{}

// Validate checks the field values on GetTaskInfoRes with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetTaskInfoRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTaskInfoRes with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetTaskInfoResMultiError,
// or nil if none found.
func (m *GetTaskInfoRes) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTaskInfoRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTaskInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetTaskInfoResValidationError{
					field:  "TaskInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetTaskInfoResValidationError{
					field:  "TaskInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTaskInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetTaskInfoResValidationError{
				field:  "TaskInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetTaskInfoResMultiError(errors)
	}

	return nil
}

// GetTaskInfoResMultiError is an error wrapping multiple validation errors
// returned by GetTaskInfoRes.ValidateAll() if the designated constraints
// aren't met.
type GetTaskInfoResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTaskInfoResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTaskInfoResMultiError) AllErrors() []error { return m }

// GetTaskInfoResValidationError is the validation error returned by
// GetTaskInfoRes.Validate if the designated constraints aren't met.
type GetTaskInfoResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTaskInfoResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTaskInfoResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTaskInfoResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTaskInfoResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTaskInfoResValidationError) ErrorName() string { return "GetTaskInfoResValidationError" }

// Error satisfies the builtin error interface
func (e GetTaskInfoResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTaskInfoRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTaskInfoResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTaskInfoResValidationError{}

// Validate checks the field values on HistoricalStatsReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *HistoricalStatsReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HistoricalStatsReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HistoricalStatsReqMultiError, or nil if none found.
func (m *HistoricalStatsReq) ValidateAll() error {
	return m.validate(true)
}

func (m *HistoricalStatsReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCurrentUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HistoricalStatsReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HistoricalStatsReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrentUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HistoricalStatsReqValidationError{
				field:  "CurrentUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if utf8.RuneCountInString(m.GetQueue()) < 1 {
		err := HistoricalStatsReqValidationError{
			field:  "Queue",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetN(); val < 1 || val > 90 {
		err := HistoricalStatsReqValidationError{
			field:  "N",
			reason: "value must be inside range [1, 90]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return HistoricalStatsReqMultiError(errors)
	}

	return nil
}

// HistoricalStatsReqMultiError is an error wrapping multiple validation errors
// returned by HistoricalStatsReq.ValidateAll() if the designated constraints
// aren't met.
type HistoricalStatsReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HistoricalStatsReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HistoricalStatsReqMultiError) AllErrors() []error { return m }

// HistoricalStatsReqValidationError is the validation error returned by
// HistoricalStatsReq.Validate if the designated constraints aren't met.
type HistoricalStatsReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HistoricalStatsReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HistoricalStatsReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HistoricalStatsReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HistoricalStatsReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HistoricalStatsReqValidationError) ErrorName() string {
	return "HistoricalStatsReqValidationError"
}

// Error satisfies the builtin error interface
func (e HistoricalStatsReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHistoricalStatsReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HistoricalStatsReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HistoricalStatsReqValidationError{}

// Validate checks the field values on HistoricalStatsRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *HistoricalStatsRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HistoricalStatsRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HistoricalStatsResMultiError, or nil if none found.
func (m *HistoricalStatsRes) ValidateAll() error {
	return m.validate(true)
}

func (m *HistoricalStatsRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetDailyStat() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, HistoricalStatsResValidationError{
						field:  fmt.Sprintf("DailyStat[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, HistoricalStatsResValidationError{
						field:  fmt.Sprintf("DailyStat[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return HistoricalStatsResValidationError{
					field:  fmt.Sprintf("DailyStat[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return HistoricalStatsResMultiError(errors)
	}

	return nil
}

// HistoricalStatsResMultiError is an error wrapping multiple validation errors
// returned by HistoricalStatsRes.ValidateAll() if the designated constraints
// aren't met.
type HistoricalStatsResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HistoricalStatsResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HistoricalStatsResMultiError) AllErrors() []error { return m }

// HistoricalStatsResValidationError is the validation error returned by
// HistoricalStatsRes.Validate if the designated constraints aren't met.
type HistoricalStatsResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HistoricalStatsResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HistoricalStatsResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HistoricalStatsResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HistoricalStatsResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HistoricalStatsResValidationError) ErrorName() string {
	return "HistoricalStatsResValidationError"
}

// Error satisfies the builtin error interface
func (e HistoricalStatsResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHistoricalStatsRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HistoricalStatsResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HistoricalStatsResValidationError{}
