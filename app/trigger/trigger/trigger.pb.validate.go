// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: trigger.proto

package trigger

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on PbTaskInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PbTaskInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PbTaskInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PbTaskInfoMultiError, or
// nil if none found.
func (m *PbTaskInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *PbTaskInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Queue

	// no validation rules for Type

	// no validation rules for Payload

	// no validation rules for State

	// no validation rules for MaxRetry

	// no validation rules for Retried

	// no validation rules for LastErr

	// no validation rules for LastFailedAt

	// no validation rules for Timeout

	// no validation rules for Deadline

	// no validation rules for Group

	// no validation rules for NextProcessAt

	// no validation rules for IsOrphaned

	// no validation rules for Retention

	// no validation rules for CompletedAt

	// no validation rules for Result

	if len(errors) > 0 {
		return PbTaskInfoMultiError(errors)
	}

	return nil
}

// PbTaskInfoMultiError is an error wrapping multiple validation errors
// returned by PbTaskInfo.ValidateAll() if the designated constraints aren't met.
type PbTaskInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PbTaskInfoMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PbTaskInfoMultiError) AllErrors() []error { return m }

// PbTaskInfoValidationError is the validation error returned by
// PbTaskInfo.Validate if the designated constraints aren't met.
type PbTaskInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PbTaskInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PbTaskInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PbTaskInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PbTaskInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PbTaskInfoValidationError) ErrorName() string { return "PbTaskInfoValidationError" }

// Error satisfies the builtin error interface
func (e PbTaskInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPbTaskInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PbTaskInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PbTaskInfoValidationError{}

// Validate checks the field values on PbDailyStats with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PbDailyStats) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PbDailyStats with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PbDailyStatsMultiError, or
// nil if none found.
func (m *PbDailyStats) ValidateAll() error {
	return m.validate(true)
}

func (m *PbDailyStats) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Queue

	// no validation rules for Processed

	// no validation rules for Failed

	// no validation rules for Date

	if len(errors) > 0 {
		return PbDailyStatsMultiError(errors)
	}

	return nil
}

// PbDailyStatsMultiError is an error wrapping multiple validation errors
// returned by PbDailyStats.ValidateAll() if the designated constraints aren't met.
type PbDailyStatsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PbDailyStatsMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PbDailyStatsMultiError) AllErrors() []error { return m }

// PbDailyStatsValidationError is the validation error returned by
// PbDailyStats.Validate if the designated constraints aren't met.
type PbDailyStatsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PbDailyStatsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PbDailyStatsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PbDailyStatsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PbDailyStatsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PbDailyStatsValidationError) ErrorName() string { return "PbDailyStatsValidationError" }

// Error satisfies the builtin error interface
func (e PbDailyStatsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPbDailyStats.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PbDailyStatsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PbDailyStatsValidationError{}

// Validate checks the field values on PbQueueInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PbQueueInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PbQueueInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PbQueueInfoMultiError, or
// nil if none found.
func (m *PbQueueInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *PbQueueInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Queue

	// no validation rules for MemoryUsage

	// no validation rules for Latency

	// no validation rules for Size

	// no validation rules for Groups

	// no validation rules for Pending

	// no validation rules for Active

	// no validation rules for Scheduled

	// no validation rules for Retry

	// no validation rules for Archived

	// no validation rules for Completed

	// no validation rules for Aggregating

	// no validation rules for Processed

	// no validation rules for Failed

	// no validation rules for ProcessedTotal

	// no validation rules for FailedTotal

	// no validation rules for Paused

	// no validation rules for Timestamp

	if len(errors) > 0 {
		return PbQueueInfoMultiError(errors)
	}

	return nil
}

// PbQueueInfoMultiError is an error wrapping multiple validation errors
// returned by PbQueueInfo.ValidateAll() if the designated constraints aren't met.
type PbQueueInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PbQueueInfoMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PbQueueInfoMultiError) AllErrors() []error { return m }

// PbQueueInfoValidationError is the validation error returned by
// PbQueueInfo.Validate if the designated constraints aren't met.
type PbQueueInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PbQueueInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PbQueueInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PbQueueInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PbQueueInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PbQueueInfoValidationError) ErrorName() string { return "PbQueueInfoValidationError" }

// Error satisfies the builtin error interface
func (e PbQueueInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPbQueueInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PbQueueInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PbQueueInfoValidationError{}

// Validate checks the field values on Req with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Req) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Req with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ReqMultiError, or nil if none found.
func (m *Req) ValidateAll() error {
	return m.validate(true)
}

func (m *Req) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Ping

	if len(errors) > 0 {
		return ReqMultiError(errors)
	}

	return nil
}

// ReqMultiError is an error wrapping multiple validation errors returned by
// Req.ValidateAll() if the designated constraints aren't met.
type ReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReqMultiError) AllErrors() []error { return m }

// ReqValidationError is the validation error returned by Req.Validate if the
// designated constraints aren't met.
type ReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReqValidationError) ErrorName() string { return "ReqValidationError" }

// Error satisfies the builtin error interface
func (e ReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReqValidationError{}

// Validate checks the field values on Res with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Res) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Res with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ResMultiError, or nil if none found.
func (m *Res) ValidateAll() error {
	return m.validate(true)
}

func (m *Res) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Pong

	if len(errors) > 0 {
		return ResMultiError(errors)
	}

	return nil
}

// ResMultiError is an error wrapping multiple validation errors returned by
// Res.ValidateAll() if the designated constraints aren't met.
type ResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResMultiError) AllErrors() []error { return m }

// ResValidationError is the validation error returned by Res.Validate if the
// designated constraints aren't met.
type ResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResValidationError) ErrorName() string { return "ResValidationError" }

// Error satisfies the builtin error interface
func (e ResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResValidationError{}

// Validate checks the field values on SendTriggerReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SendTriggerReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SendTriggerReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SendTriggerReqMultiError,
// or nil if none found.
func (m *SendTriggerReq) ValidateAll() error {
	return m.validate(true)
}

func (m *SendTriggerReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCurrentUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SendTriggerReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SendTriggerReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrentUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SendTriggerReqValidationError{
				field:  "CurrentUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ProcessIn

	// no validation rules for TriggerTime

	// no validation rules for Url

	// no validation rules for MaxRetry

	// no validation rules for MsgId

	// no validation rules for Body

	if len(errors) > 0 {
		return SendTriggerReqMultiError(errors)
	}

	return nil
}

// SendTriggerReqMultiError is an error wrapping multiple validation errors
// returned by SendTriggerReq.ValidateAll() if the designated constraints
// aren't met.
type SendTriggerReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SendTriggerReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SendTriggerReqMultiError) AllErrors() []error { return m }

// SendTriggerReqValidationError is the validation error returned by
// SendTriggerReq.Validate if the designated constraints aren't met.
type SendTriggerReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SendTriggerReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SendTriggerReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SendTriggerReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SendTriggerReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SendTriggerReqValidationError) ErrorName() string { return "SendTriggerReqValidationError" }

// Error satisfies the builtin error interface
func (e SendTriggerReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSendTriggerReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SendTriggerReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SendTriggerReqValidationError{}

// Validate checks the field values on SendTriggerRes with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SendTriggerRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SendTriggerRes with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SendTriggerResMultiError,
// or nil if none found.
func (m *SendTriggerRes) ValidateAll() error {
	return m.validate(true)
}

func (m *SendTriggerRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TraceId

	// no validation rules for Queue

	// no validation rules for Id

	if len(errors) > 0 {
		return SendTriggerResMultiError(errors)
	}

	return nil
}

// SendTriggerResMultiError is an error wrapping multiple validation errors
// returned by SendTriggerRes.ValidateAll() if the designated constraints
// aren't met.
type SendTriggerResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SendTriggerResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SendTriggerResMultiError) AllErrors() []error { return m }

// SendTriggerResValidationError is the validation error returned by
// SendTriggerRes.Validate if the designated constraints aren't met.
type SendTriggerResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SendTriggerResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SendTriggerResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SendTriggerResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SendTriggerResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SendTriggerResValidationError) ErrorName() string { return "SendTriggerResValidationError" }

// Error satisfies the builtin error interface
func (e SendTriggerResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSendTriggerRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SendTriggerResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SendTriggerResValidationError{}

// Validate checks the field values on SendProtoTriggerReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SendProtoTriggerReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SendProtoTriggerReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SendProtoTriggerReqMultiError, or nil if none found.
func (m *SendProtoTriggerReq) ValidateAll() error {
	return m.validate(true)
}

func (m *SendProtoTriggerReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCurrentUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SendProtoTriggerReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SendProtoTriggerReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrentUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SendProtoTriggerReqValidationError{
				field:  "CurrentUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ProcessIn

	// no validation rules for TriggerTime

	// no validation rules for MaxRetry

	// no validation rules for MsgId

	// no validation rules for GrpcServer

	// no validation rules for Method

	// no validation rules for Payload

	// no validation rules for RequestTimeout

	if len(errors) > 0 {
		return SendProtoTriggerReqMultiError(errors)
	}

	return nil
}

// SendProtoTriggerReqMultiError is an error wrapping multiple validation
// errors returned by SendProtoTriggerReq.ValidateAll() if the designated
// constraints aren't met.
type SendProtoTriggerReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SendProtoTriggerReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SendProtoTriggerReqMultiError) AllErrors() []error { return m }

// SendProtoTriggerReqValidationError is the validation error returned by
// SendProtoTriggerReq.Validate if the designated constraints aren't met.
type SendProtoTriggerReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SendProtoTriggerReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SendProtoTriggerReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SendProtoTriggerReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SendProtoTriggerReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SendProtoTriggerReqValidationError) ErrorName() string {
	return "SendProtoTriggerReqValidationError"
}

// Error satisfies the builtin error interface
func (e SendProtoTriggerReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSendProtoTriggerReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SendProtoTriggerReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SendProtoTriggerReqValidationError{}

// Validate checks the field values on SendProtoTriggerRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SendProtoTriggerRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SendProtoTriggerRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SendProtoTriggerResMultiError, or nil if none found.
func (m *SendProtoTriggerRes) ValidateAll() error {
	return m.validate(true)
}

func (m *SendProtoTriggerRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TraceId

	// no validation rules for Queue

	// no validation rules for Id

	if len(errors) > 0 {
		return SendProtoTriggerResMultiError(errors)
	}

	return nil
}

// SendProtoTriggerResMultiError is an error wrapping multiple validation
// errors returned by SendProtoTriggerRes.ValidateAll() if the designated
// constraints aren't met.
type SendProtoTriggerResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SendProtoTriggerResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SendProtoTriggerResMultiError) AllErrors() []error { return m }

// SendProtoTriggerResValidationError is the validation error returned by
// SendProtoTriggerRes.Validate if the designated constraints aren't met.
type SendProtoTriggerResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SendProtoTriggerResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SendProtoTriggerResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SendProtoTriggerResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SendProtoTriggerResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SendProtoTriggerResValidationError) ErrorName() string {
	return "SendProtoTriggerResValidationError"
}

// Error satisfies the builtin error interface
func (e SendProtoTriggerResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSendProtoTriggerRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SendProtoTriggerResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SendProtoTriggerResValidationError{}

// Validate checks the field values on QueuesReq with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *QueuesReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueuesReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in QueuesReqMultiError, or nil
// if none found.
func (m *QueuesReq) ValidateAll() error {
	return m.validate(true)
}

func (m *QueuesReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCurrentUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, QueuesReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, QueuesReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrentUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return QueuesReqValidationError{
				field:  "CurrentUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return QueuesReqMultiError(errors)
	}

	return nil
}

// QueuesReqMultiError is an error wrapping multiple validation errors returned
// by QueuesReq.ValidateAll() if the designated constraints aren't met.
type QueuesReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueuesReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueuesReqMultiError) AllErrors() []error { return m }

// QueuesReqValidationError is the validation error returned by
// QueuesReq.Validate if the designated constraints aren't met.
type QueuesReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueuesReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueuesReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueuesReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueuesReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueuesReqValidationError) ErrorName() string { return "QueuesReqValidationError" }

// Error satisfies the builtin error interface
func (e QueuesReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueuesReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueuesReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueuesReqValidationError{}

// Validate checks the field values on QueuesRes with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *QueuesRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueuesRes with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in QueuesResMultiError, or nil
// if none found.
func (m *QueuesRes) ValidateAll() error {
	return m.validate(true)
}

func (m *QueuesRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return QueuesResMultiError(errors)
	}

	return nil
}

// QueuesResMultiError is an error wrapping multiple validation errors returned
// by QueuesRes.ValidateAll() if the designated constraints aren't met.
type QueuesResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueuesResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueuesResMultiError) AllErrors() []error { return m }

// QueuesResValidationError is the validation error returned by
// QueuesRes.Validate if the designated constraints aren't met.
type QueuesResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueuesResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueuesResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueuesResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueuesResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueuesResValidationError) ErrorName() string { return "QueuesResValidationError" }

// Error satisfies the builtin error interface
func (e QueuesResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueuesRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueuesResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueuesResValidationError{}

// Validate checks the field values on GetQueueInfoReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetQueueInfoReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetQueueInfoReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetQueueInfoReqMultiError, or nil if none found.
func (m *GetQueueInfoReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetQueueInfoReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCurrentUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetQueueInfoReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetQueueInfoReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrentUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetQueueInfoReqValidationError{
				field:  "CurrentUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if utf8.RuneCountInString(m.GetQueue()) < 1 {
		err := GetQueueInfoReqValidationError{
			field:  "Queue",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetQueueInfoReqMultiError(errors)
	}

	return nil
}

// GetQueueInfoReqMultiError is an error wrapping multiple validation errors
// returned by GetQueueInfoReq.ValidateAll() if the designated constraints
// aren't met.
type GetQueueInfoReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetQueueInfoReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetQueueInfoReqMultiError) AllErrors() []error { return m }

// GetQueueInfoReqValidationError is the validation error returned by
// GetQueueInfoReq.Validate if the designated constraints aren't met.
type GetQueueInfoReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetQueueInfoReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetQueueInfoReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetQueueInfoReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetQueueInfoReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetQueueInfoReqValidationError) ErrorName() string { return "GetQueueInfoReqValidationError" }

// Error satisfies the builtin error interface
func (e GetQueueInfoReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetQueueInfoReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetQueueInfoReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetQueueInfoReqValidationError{}

// Validate checks the field values on GetQueueInfoRes with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetQueueInfoRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetQueueInfoRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetQueueInfoResMultiError, or nil if none found.
func (m *GetQueueInfoRes) ValidateAll() error {
	return m.validate(true)
}

func (m *GetQueueInfoRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetQueueInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetQueueInfoResValidationError{
					field:  "QueueInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetQueueInfoResValidationError{
					field:  "QueueInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetQueueInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetQueueInfoResValidationError{
				field:  "QueueInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetQueueInfoResMultiError(errors)
	}

	return nil
}

// GetQueueInfoResMultiError is an error wrapping multiple validation errors
// returned by GetQueueInfoRes.ValidateAll() if the designated constraints
// aren't met.
type GetQueueInfoResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetQueueInfoResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetQueueInfoResMultiError) AllErrors() []error { return m }

// GetQueueInfoResValidationError is the validation error returned by
// GetQueueInfoRes.Validate if the designated constraints aren't met.
type GetQueueInfoResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetQueueInfoResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetQueueInfoResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetQueueInfoResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetQueueInfoResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetQueueInfoResValidationError) ErrorName() string { return "GetQueueInfoResValidationError" }

// Error satisfies the builtin error interface
func (e GetQueueInfoResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetQueueInfoRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetQueueInfoResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetQueueInfoResValidationError{}

// Validate checks the field values on ArchiveTaskReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ArchiveTaskReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ArchiveTaskReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ArchiveTaskReqMultiError,
// or nil if none found.
func (m *ArchiveTaskReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ArchiveTaskReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCurrentUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ArchiveTaskReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ArchiveTaskReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrentUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ArchiveTaskReqValidationError{
				field:  "CurrentUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if utf8.RuneCountInString(m.GetQueue()) < 1 {
		err := ArchiveTaskReqValidationError{
			field:  "Queue",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetId()) < 1 {
		err := ArchiveTaskReqValidationError{
			field:  "Id",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ArchiveTaskReqMultiError(errors)
	}

	return nil
}

// ArchiveTaskReqMultiError is an error wrapping multiple validation errors
// returned by ArchiveTaskReq.ValidateAll() if the designated constraints
// aren't met.
type ArchiveTaskReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ArchiveTaskReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ArchiveTaskReqMultiError) AllErrors() []error { return m }

// ArchiveTaskReqValidationError is the validation error returned by
// ArchiveTaskReq.Validate if the designated constraints aren't met.
type ArchiveTaskReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ArchiveTaskReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ArchiveTaskReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ArchiveTaskReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ArchiveTaskReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ArchiveTaskReqValidationError) ErrorName() string { return "ArchiveTaskReqValidationError" }

// Error satisfies the builtin error interface
func (e ArchiveTaskReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sArchiveTaskReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ArchiveTaskReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ArchiveTaskReqValidationError{}

// Validate checks the field values on ArchiveTaskRes with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ArchiveTaskRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ArchiveTaskRes with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ArchiveTaskResMultiError,
// or nil if none found.
func (m *ArchiveTaskRes) ValidateAll() error {
	return m.validate(true)
}

func (m *ArchiveTaskRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ArchiveTaskResMultiError(errors)
	}

	return nil
}

// ArchiveTaskResMultiError is an error wrapping multiple validation errors
// returned by ArchiveTaskRes.ValidateAll() if the designated constraints
// aren't met.
type ArchiveTaskResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ArchiveTaskResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ArchiveTaskResMultiError) AllErrors() []error { return m }

// ArchiveTaskResValidationError is the validation error returned by
// ArchiveTaskRes.Validate if the designated constraints aren't met.
type ArchiveTaskResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ArchiveTaskResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ArchiveTaskResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ArchiveTaskResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ArchiveTaskResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ArchiveTaskResValidationError) ErrorName() string { return "ArchiveTaskResValidationError" }

// Error satisfies the builtin error interface
func (e ArchiveTaskResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sArchiveTaskRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ArchiveTaskResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ArchiveTaskResValidationError{}

// Validate checks the field values on DeleteTaskReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DeleteTaskReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteTaskReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DeleteTaskReqMultiError, or
// nil if none found.
func (m *DeleteTaskReq) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteTaskReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCurrentUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteTaskReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteTaskReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrentUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteTaskReqValidationError{
				field:  "CurrentUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if utf8.RuneCountInString(m.GetQueue()) < 1 {
		err := DeleteTaskReqValidationError{
			field:  "Queue",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetId()) < 1 {
		err := DeleteTaskReqValidationError{
			field:  "Id",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteTaskReqMultiError(errors)
	}

	return nil
}

// DeleteTaskReqMultiError is an error wrapping multiple validation errors
// returned by DeleteTaskReq.ValidateAll() if the designated constraints
// aren't met.
type DeleteTaskReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteTaskReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteTaskReqMultiError) AllErrors() []error { return m }

// DeleteTaskReqValidationError is the validation error returned by
// DeleteTaskReq.Validate if the designated constraints aren't met.
type DeleteTaskReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteTaskReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteTaskReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteTaskReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteTaskReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteTaskReqValidationError) ErrorName() string { return "DeleteTaskReqValidationError" }

// Error satisfies the builtin error interface
func (e DeleteTaskReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteTaskReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteTaskReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteTaskReqValidationError{}

// Validate checks the field values on DeleteTaskRes with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DeleteTaskRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteTaskRes with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DeleteTaskResMultiError, or
// nil if none found.
func (m *DeleteTaskRes) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteTaskRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DeleteTaskResMultiError(errors)
	}

	return nil
}

// DeleteTaskResMultiError is an error wrapping multiple validation errors
// returned by DeleteTaskRes.ValidateAll() if the designated constraints
// aren't met.
type DeleteTaskResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteTaskResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteTaskResMultiError) AllErrors() []error { return m }

// DeleteTaskResValidationError is the validation error returned by
// DeleteTaskRes.Validate if the designated constraints aren't met.
type DeleteTaskResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteTaskResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteTaskResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteTaskResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteTaskResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteTaskResValidationError) ErrorName() string { return "DeleteTaskResValidationError" }

// Error satisfies the builtin error interface
func (e DeleteTaskResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteTaskRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteTaskResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteTaskResValidationError{}

// Validate checks the field values on GetTaskInfoReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetTaskInfoReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTaskInfoReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetTaskInfoReqMultiError,
// or nil if none found.
func (m *GetTaskInfoReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTaskInfoReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCurrentUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetTaskInfoReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetTaskInfoReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrentUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetTaskInfoReqValidationError{
				field:  "CurrentUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if utf8.RuneCountInString(m.GetQueue()) < 1 {
		err := GetTaskInfoReqValidationError{
			field:  "Queue",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetId()) < 1 {
		err := GetTaskInfoReqValidationError{
			field:  "Id",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetTaskInfoReqMultiError(errors)
	}

	return nil
}

// GetTaskInfoReqMultiError is an error wrapping multiple validation errors
// returned by GetTaskInfoReq.ValidateAll() if the designated constraints
// aren't met.
type GetTaskInfoReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTaskInfoReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTaskInfoReqMultiError) AllErrors() []error { return m }

// GetTaskInfoReqValidationError is the validation error returned by
// GetTaskInfoReq.Validate if the designated constraints aren't met.
type GetTaskInfoReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTaskInfoReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTaskInfoReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTaskInfoReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTaskInfoReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTaskInfoReqValidationError) ErrorName() string { return "GetTaskInfoReqValidationError" }

// Error satisfies the builtin error interface
func (e GetTaskInfoReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTaskInfoReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTaskInfoReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTaskInfoReqValidationError{}

// Validate checks the field values on GetTaskInfoRes with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetTaskInfoRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTaskInfoRes with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetTaskInfoResMultiError,
// or nil if none found.
func (m *GetTaskInfoRes) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTaskInfoRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTaskInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetTaskInfoResValidationError{
					field:  "TaskInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetTaskInfoResValidationError{
					field:  "TaskInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTaskInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetTaskInfoResValidationError{
				field:  "TaskInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetTaskInfoResMultiError(errors)
	}

	return nil
}

// GetTaskInfoResMultiError is an error wrapping multiple validation errors
// returned by GetTaskInfoRes.ValidateAll() if the designated constraints
// aren't met.
type GetTaskInfoResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTaskInfoResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTaskInfoResMultiError) AllErrors() []error { return m }

// GetTaskInfoResValidationError is the validation error returned by
// GetTaskInfoRes.Validate if the designated constraints aren't met.
type GetTaskInfoResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTaskInfoResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTaskInfoResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTaskInfoResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTaskInfoResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTaskInfoResValidationError) ErrorName() string { return "GetTaskInfoResValidationError" }

// Error satisfies the builtin error interface
func (e GetTaskInfoResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTaskInfoRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTaskInfoResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTaskInfoResValidationError{}

// Validate checks the field values on HistoricalStatsReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *HistoricalStatsReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HistoricalStatsReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HistoricalStatsReqMultiError, or nil if none found.
func (m *HistoricalStatsReq) ValidateAll() error {
	return m.validate(true)
}

func (m *HistoricalStatsReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCurrentUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HistoricalStatsReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HistoricalStatsReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrentUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HistoricalStatsReqValidationError{
				field:  "CurrentUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if utf8.RuneCountInString(m.GetQueue()) < 1 {
		err := HistoricalStatsReqValidationError{
			field:  "Queue",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetN(); val < 1 || val > 90 {
		err := HistoricalStatsReqValidationError{
			field:  "N",
			reason: "value must be inside range [1, 90]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return HistoricalStatsReqMultiError(errors)
	}

	return nil
}

// HistoricalStatsReqMultiError is an error wrapping multiple validation errors
// returned by HistoricalStatsReq.ValidateAll() if the designated constraints
// aren't met.
type HistoricalStatsReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HistoricalStatsReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HistoricalStatsReqMultiError) AllErrors() []error { return m }

// HistoricalStatsReqValidationError is the validation error returned by
// HistoricalStatsReq.Validate if the designated constraints aren't met.
type HistoricalStatsReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HistoricalStatsReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HistoricalStatsReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HistoricalStatsReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HistoricalStatsReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HistoricalStatsReqValidationError) ErrorName() string {
	return "HistoricalStatsReqValidationError"
}

// Error satisfies the builtin error interface
func (e HistoricalStatsReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHistoricalStatsReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HistoricalStatsReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HistoricalStatsReqValidationError{}

// Validate checks the field values on HistoricalStatsRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *HistoricalStatsRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HistoricalStatsRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HistoricalStatsResMultiError, or nil if none found.
func (m *HistoricalStatsRes) ValidateAll() error {
	return m.validate(true)
}

func (m *HistoricalStatsRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetDailyStat() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, HistoricalStatsResValidationError{
						field:  fmt.Sprintf("DailyStat[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, HistoricalStatsResValidationError{
						field:  fmt.Sprintf("DailyStat[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return HistoricalStatsResValidationError{
					field:  fmt.Sprintf("DailyStat[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return HistoricalStatsResMultiError(errors)
	}

	return nil
}

// HistoricalStatsResMultiError is an error wrapping multiple validation errors
// returned by HistoricalStatsRes.ValidateAll() if the designated constraints
// aren't met.
type HistoricalStatsResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HistoricalStatsResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HistoricalStatsResMultiError) AllErrors() []error { return m }

// HistoricalStatsResValidationError is the validation error returned by
// HistoricalStatsRes.Validate if the designated constraints aren't met.
type HistoricalStatsResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HistoricalStatsResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HistoricalStatsResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HistoricalStatsResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HistoricalStatsResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HistoricalStatsResValidationError) ErrorName() string {
	return "HistoricalStatsResValidationError"
}

// Error satisfies the builtin error interface
func (e HistoricalStatsResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHistoricalStatsRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HistoricalStatsResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HistoricalStatsResValidationError{}

// Validate checks the field values on ListActiveTasksReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListActiveTasksReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListActiveTasksReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListActiveTasksReqMultiError, or nil if none found.
func (m *ListActiveTasksReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListActiveTasksReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCurrentUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListActiveTasksReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListActiveTasksReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrentUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListActiveTasksReqValidationError{
				field:  "CurrentUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetPageSize() < 0 {
		err := ListActiveTasksReqValidationError{
			field:  "PageSize",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetPageNum() < 0 {
		err := ListActiveTasksReqValidationError{
			field:  "PageNum",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetQueue()) < 1 {
		err := ListActiveTasksReqValidationError{
			field:  "Queue",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListActiveTasksReqMultiError(errors)
	}

	return nil
}

// ListActiveTasksReqMultiError is an error wrapping multiple validation errors
// returned by ListActiveTasksReq.ValidateAll() if the designated constraints
// aren't met.
type ListActiveTasksReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListActiveTasksReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListActiveTasksReqMultiError) AllErrors() []error { return m }

// ListActiveTasksReqValidationError is the validation error returned by
// ListActiveTasksReq.Validate if the designated constraints aren't met.
type ListActiveTasksReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListActiveTasksReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListActiveTasksReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListActiveTasksReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListActiveTasksReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListActiveTasksReqValidationError) ErrorName() string {
	return "ListActiveTasksReqValidationError"
}

// Error satisfies the builtin error interface
func (e ListActiveTasksReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListActiveTasksReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListActiveTasksReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListActiveTasksReqValidationError{}

// Validate checks the field values on ListActiveTasksRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListActiveTasksRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListActiveTasksRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListActiveTasksResMultiError, or nil if none found.
func (m *ListActiveTasksRes) ValidateAll() error {
	return m.validate(true)
}

func (m *ListActiveTasksRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetQueueInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListActiveTasksResValidationError{
					field:  "QueueInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListActiveTasksResValidationError{
					field:  "QueueInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetQueueInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListActiveTasksResValidationError{
				field:  "QueueInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetTasksInfo() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListActiveTasksResValidationError{
						field:  fmt.Sprintf("TasksInfo[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListActiveTasksResValidationError{
						field:  fmt.Sprintf("TasksInfo[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListActiveTasksResValidationError{
					field:  fmt.Sprintf("TasksInfo[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListActiveTasksResMultiError(errors)
	}

	return nil
}

// ListActiveTasksResMultiError is an error wrapping multiple validation errors
// returned by ListActiveTasksRes.ValidateAll() if the designated constraints
// aren't met.
type ListActiveTasksResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListActiveTasksResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListActiveTasksResMultiError) AllErrors() []error { return m }

// ListActiveTasksResValidationError is the validation error returned by
// ListActiveTasksRes.Validate if the designated constraints aren't met.
type ListActiveTasksResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListActiveTasksResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListActiveTasksResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListActiveTasksResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListActiveTasksResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListActiveTasksResValidationError) ErrorName() string {
	return "ListActiveTasksResValidationError"
}

// Error satisfies the builtin error interface
func (e ListActiveTasksResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListActiveTasksRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListActiveTasksResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListActiveTasksResValidationError{}

// Validate checks the field values on ListPendingTasksReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListPendingTasksReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListPendingTasksReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListPendingTasksReqMultiError, or nil if none found.
func (m *ListPendingTasksReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListPendingTasksReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCurrentUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListPendingTasksReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListPendingTasksReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrentUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListPendingTasksReqValidationError{
				field:  "CurrentUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetPageSize() < 0 {
		err := ListPendingTasksReqValidationError{
			field:  "PageSize",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetPageNum() < 0 {
		err := ListPendingTasksReqValidationError{
			field:  "PageNum",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetQueue()) < 1 {
		err := ListPendingTasksReqValidationError{
			field:  "Queue",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListPendingTasksReqMultiError(errors)
	}

	return nil
}

// ListPendingTasksReqMultiError is an error wrapping multiple validation
// errors returned by ListPendingTasksReq.ValidateAll() if the designated
// constraints aren't met.
type ListPendingTasksReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListPendingTasksReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListPendingTasksReqMultiError) AllErrors() []error { return m }

// ListPendingTasksReqValidationError is the validation error returned by
// ListPendingTasksReq.Validate if the designated constraints aren't met.
type ListPendingTasksReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListPendingTasksReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListPendingTasksReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListPendingTasksReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListPendingTasksReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListPendingTasksReqValidationError) ErrorName() string {
	return "ListPendingTasksReqValidationError"
}

// Error satisfies the builtin error interface
func (e ListPendingTasksReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListPendingTasksReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListPendingTasksReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListPendingTasksReqValidationError{}

// Validate checks the field values on ListPendingTasksRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListPendingTasksRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListPendingTasksRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListPendingTasksResMultiError, or nil if none found.
func (m *ListPendingTasksRes) ValidateAll() error {
	return m.validate(true)
}

func (m *ListPendingTasksRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetQueueInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListPendingTasksResValidationError{
					field:  "QueueInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListPendingTasksResValidationError{
					field:  "QueueInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetQueueInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListPendingTasksResValidationError{
				field:  "QueueInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetTasksInfo() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListPendingTasksResValidationError{
						field:  fmt.Sprintf("TasksInfo[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListPendingTasksResValidationError{
						field:  fmt.Sprintf("TasksInfo[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListPendingTasksResValidationError{
					field:  fmt.Sprintf("TasksInfo[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListPendingTasksResMultiError(errors)
	}

	return nil
}

// ListPendingTasksResMultiError is an error wrapping multiple validation
// errors returned by ListPendingTasksRes.ValidateAll() if the designated
// constraints aren't met.
type ListPendingTasksResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListPendingTasksResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListPendingTasksResMultiError) AllErrors() []error { return m }

// ListPendingTasksResValidationError is the validation error returned by
// ListPendingTasksRes.Validate if the designated constraints aren't met.
type ListPendingTasksResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListPendingTasksResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListPendingTasksResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListPendingTasksResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListPendingTasksResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListPendingTasksResValidationError) ErrorName() string {
	return "ListPendingTasksResValidationError"
}

// Error satisfies the builtin error interface
func (e ListPendingTasksResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListPendingTasksRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListPendingTasksResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListPendingTasksResValidationError{}

// Validate checks the field values on ListAggregatingTasksReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListAggregatingTasksReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListAggregatingTasksReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListAggregatingTasksReqMultiError, or nil if none found.
func (m *ListAggregatingTasksReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListAggregatingTasksReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCurrentUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListAggregatingTasksReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListAggregatingTasksReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrentUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListAggregatingTasksReqValidationError{
				field:  "CurrentUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetPageSize() < 0 {
		err := ListAggregatingTasksReqValidationError{
			field:  "PageSize",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetPageNum() < 0 {
		err := ListAggregatingTasksReqValidationError{
			field:  "PageNum",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetQueue()) < 1 {
		err := ListAggregatingTasksReqValidationError{
			field:  "Queue",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetGroup()) < 1 {
		err := ListAggregatingTasksReqValidationError{
			field:  "Group",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListAggregatingTasksReqMultiError(errors)
	}

	return nil
}

// ListAggregatingTasksReqMultiError is an error wrapping multiple validation
// errors returned by ListAggregatingTasksReq.ValidateAll() if the designated
// constraints aren't met.
type ListAggregatingTasksReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListAggregatingTasksReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListAggregatingTasksReqMultiError) AllErrors() []error { return m }

// ListAggregatingTasksReqValidationError is the validation error returned by
// ListAggregatingTasksReq.Validate if the designated constraints aren't met.
type ListAggregatingTasksReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListAggregatingTasksReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListAggregatingTasksReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListAggregatingTasksReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListAggregatingTasksReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListAggregatingTasksReqValidationError) ErrorName() string {
	return "ListAggregatingTasksReqValidationError"
}

// Error satisfies the builtin error interface
func (e ListAggregatingTasksReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListAggregatingTasksReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListAggregatingTasksReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListAggregatingTasksReqValidationError{}

// Validate checks the field values on ListAggregatingTasksRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListAggregatingTasksRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListAggregatingTasksRes with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListAggregatingTasksResMultiError, or nil if none found.
func (m *ListAggregatingTasksRes) ValidateAll() error {
	return m.validate(true)
}

func (m *ListAggregatingTasksRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetQueueInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListAggregatingTasksResValidationError{
					field:  "QueueInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListAggregatingTasksResValidationError{
					field:  "QueueInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetQueueInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListAggregatingTasksResValidationError{
				field:  "QueueInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetTasksInfo() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListAggregatingTasksResValidationError{
						field:  fmt.Sprintf("TasksInfo[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListAggregatingTasksResValidationError{
						field:  fmt.Sprintf("TasksInfo[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListAggregatingTasksResValidationError{
					field:  fmt.Sprintf("TasksInfo[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListAggregatingTasksResMultiError(errors)
	}

	return nil
}

// ListAggregatingTasksResMultiError is an error wrapping multiple validation
// errors returned by ListAggregatingTasksRes.ValidateAll() if the designated
// constraints aren't met.
type ListAggregatingTasksResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListAggregatingTasksResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListAggregatingTasksResMultiError) AllErrors() []error { return m }

// ListAggregatingTasksResValidationError is the validation error returned by
// ListAggregatingTasksRes.Validate if the designated constraints aren't met.
type ListAggregatingTasksResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListAggregatingTasksResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListAggregatingTasksResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListAggregatingTasksResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListAggregatingTasksResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListAggregatingTasksResValidationError) ErrorName() string {
	return "ListAggregatingTasksResValidationError"
}

// Error satisfies the builtin error interface
func (e ListAggregatingTasksResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListAggregatingTasksRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListAggregatingTasksResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListAggregatingTasksResValidationError{}

// Validate checks the field values on ListScheduledTasksReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListScheduledTasksReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListScheduledTasksReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListScheduledTasksReqMultiError, or nil if none found.
func (m *ListScheduledTasksReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListScheduledTasksReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCurrentUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListScheduledTasksReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListScheduledTasksReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrentUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListScheduledTasksReqValidationError{
				field:  "CurrentUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetPageSize() < 0 {
		err := ListScheduledTasksReqValidationError{
			field:  "PageSize",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetPageNum() < 0 {
		err := ListScheduledTasksReqValidationError{
			field:  "PageNum",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetQueue()) < 1 {
		err := ListScheduledTasksReqValidationError{
			field:  "Queue",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListScheduledTasksReqMultiError(errors)
	}

	return nil
}

// ListScheduledTasksReqMultiError is an error wrapping multiple validation
// errors returned by ListScheduledTasksReq.ValidateAll() if the designated
// constraints aren't met.
type ListScheduledTasksReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListScheduledTasksReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListScheduledTasksReqMultiError) AllErrors() []error { return m }

// ListScheduledTasksReqValidationError is the validation error returned by
// ListScheduledTasksReq.Validate if the designated constraints aren't met.
type ListScheduledTasksReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListScheduledTasksReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListScheduledTasksReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListScheduledTasksReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListScheduledTasksReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListScheduledTasksReqValidationError) ErrorName() string {
	return "ListScheduledTasksReqValidationError"
}

// Error satisfies the builtin error interface
func (e ListScheduledTasksReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListScheduledTasksReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListScheduledTasksReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListScheduledTasksReqValidationError{}

// Validate checks the field values on ListScheduledTasksRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListScheduledTasksRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListScheduledTasksRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListScheduledTasksResMultiError, or nil if none found.
func (m *ListScheduledTasksRes) ValidateAll() error {
	return m.validate(true)
}

func (m *ListScheduledTasksRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetQueueInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListScheduledTasksResValidationError{
					field:  "QueueInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListScheduledTasksResValidationError{
					field:  "QueueInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetQueueInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListScheduledTasksResValidationError{
				field:  "QueueInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetTasksInfo() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListScheduledTasksResValidationError{
						field:  fmt.Sprintf("TasksInfo[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListScheduledTasksResValidationError{
						field:  fmt.Sprintf("TasksInfo[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListScheduledTasksResValidationError{
					field:  fmt.Sprintf("TasksInfo[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListScheduledTasksResMultiError(errors)
	}

	return nil
}

// ListScheduledTasksResMultiError is an error wrapping multiple validation
// errors returned by ListScheduledTasksRes.ValidateAll() if the designated
// constraints aren't met.
type ListScheduledTasksResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListScheduledTasksResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListScheduledTasksResMultiError) AllErrors() []error { return m }

// ListScheduledTasksResValidationError is the validation error returned by
// ListScheduledTasksRes.Validate if the designated constraints aren't met.
type ListScheduledTasksResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListScheduledTasksResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListScheduledTasksResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListScheduledTasksResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListScheduledTasksResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListScheduledTasksResValidationError) ErrorName() string {
	return "ListScheduledTasksResValidationError"
}

// Error satisfies the builtin error interface
func (e ListScheduledTasksResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListScheduledTasksRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListScheduledTasksResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListScheduledTasksResValidationError{}

// Validate checks the field values on ListRetryTasksReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListRetryTasksReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListRetryTasksReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListRetryTasksReqMultiError, or nil if none found.
func (m *ListRetryTasksReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListRetryTasksReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCurrentUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListRetryTasksReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListRetryTasksReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrentUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListRetryTasksReqValidationError{
				field:  "CurrentUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetPageSize() < 0 {
		err := ListRetryTasksReqValidationError{
			field:  "PageSize",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetPageNum() < 0 {
		err := ListRetryTasksReqValidationError{
			field:  "PageNum",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetQueue()) < 1 {
		err := ListRetryTasksReqValidationError{
			field:  "Queue",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListRetryTasksReqMultiError(errors)
	}

	return nil
}

// ListRetryTasksReqMultiError is an error wrapping multiple validation errors
// returned by ListRetryTasksReq.ValidateAll() if the designated constraints
// aren't met.
type ListRetryTasksReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListRetryTasksReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListRetryTasksReqMultiError) AllErrors() []error { return m }

// ListRetryTasksReqValidationError is the validation error returned by
// ListRetryTasksReq.Validate if the designated constraints aren't met.
type ListRetryTasksReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListRetryTasksReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListRetryTasksReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListRetryTasksReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListRetryTasksReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListRetryTasksReqValidationError) ErrorName() string {
	return "ListRetryTasksReqValidationError"
}

// Error satisfies the builtin error interface
func (e ListRetryTasksReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListRetryTasksReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListRetryTasksReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListRetryTasksReqValidationError{}

// Validate checks the field values on ListRetryTasksRes with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListRetryTasksRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListRetryTasksRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListRetryTasksResMultiError, or nil if none found.
func (m *ListRetryTasksRes) ValidateAll() error {
	return m.validate(true)
}

func (m *ListRetryTasksRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetQueueInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListRetryTasksResValidationError{
					field:  "QueueInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListRetryTasksResValidationError{
					field:  "QueueInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetQueueInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListRetryTasksResValidationError{
				field:  "QueueInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetTasksInfo() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListRetryTasksResValidationError{
						field:  fmt.Sprintf("TasksInfo[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListRetryTasksResValidationError{
						field:  fmt.Sprintf("TasksInfo[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListRetryTasksResValidationError{
					field:  fmt.Sprintf("TasksInfo[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListRetryTasksResMultiError(errors)
	}

	return nil
}

// ListRetryTasksResMultiError is an error wrapping multiple validation errors
// returned by ListRetryTasksRes.ValidateAll() if the designated constraints
// aren't met.
type ListRetryTasksResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListRetryTasksResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListRetryTasksResMultiError) AllErrors() []error { return m }

// ListRetryTasksResValidationError is the validation error returned by
// ListRetryTasksRes.Validate if the designated constraints aren't met.
type ListRetryTasksResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListRetryTasksResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListRetryTasksResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListRetryTasksResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListRetryTasksResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListRetryTasksResValidationError) ErrorName() string {
	return "ListRetryTasksResValidationError"
}

// Error satisfies the builtin error interface
func (e ListRetryTasksResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListRetryTasksRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListRetryTasksResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListRetryTasksResValidationError{}

// Validate checks the field values on ListArchivedTasksReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListArchivedTasksReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListArchivedTasksReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListArchivedTasksReqMultiError, or nil if none found.
func (m *ListArchivedTasksReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListArchivedTasksReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCurrentUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListArchivedTasksReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListArchivedTasksReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrentUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListArchivedTasksReqValidationError{
				field:  "CurrentUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetPageSize() < 0 {
		err := ListArchivedTasksReqValidationError{
			field:  "PageSize",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetPageNum() < 0 {
		err := ListArchivedTasksReqValidationError{
			field:  "PageNum",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetQueue()) < 1 {
		err := ListArchivedTasksReqValidationError{
			field:  "Queue",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListArchivedTasksReqMultiError(errors)
	}

	return nil
}

// ListArchivedTasksReqMultiError is an error wrapping multiple validation
// errors returned by ListArchivedTasksReq.ValidateAll() if the designated
// constraints aren't met.
type ListArchivedTasksReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListArchivedTasksReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListArchivedTasksReqMultiError) AllErrors() []error { return m }

// ListArchivedTasksReqValidationError is the validation error returned by
// ListArchivedTasksReq.Validate if the designated constraints aren't met.
type ListArchivedTasksReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListArchivedTasksReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListArchivedTasksReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListArchivedTasksReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListArchivedTasksReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListArchivedTasksReqValidationError) ErrorName() string {
	return "ListArchivedTasksReqValidationError"
}

// Error satisfies the builtin error interface
func (e ListArchivedTasksReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListArchivedTasksReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListArchivedTasksReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListArchivedTasksReqValidationError{}

// Validate checks the field values on ListArchivedTasksRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListArchivedTasksRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListArchivedTasksRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListArchivedTasksResMultiError, or nil if none found.
func (m *ListArchivedTasksRes) ValidateAll() error {
	return m.validate(true)
}

func (m *ListArchivedTasksRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetQueueInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListArchivedTasksResValidationError{
					field:  "QueueInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListArchivedTasksResValidationError{
					field:  "QueueInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetQueueInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListArchivedTasksResValidationError{
				field:  "QueueInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetTasksInfo() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListArchivedTasksResValidationError{
						field:  fmt.Sprintf("TasksInfo[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListArchivedTasksResValidationError{
						field:  fmt.Sprintf("TasksInfo[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListArchivedTasksResValidationError{
					field:  fmt.Sprintf("TasksInfo[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListArchivedTasksResMultiError(errors)
	}

	return nil
}

// ListArchivedTasksResMultiError is an error wrapping multiple validation
// errors returned by ListArchivedTasksRes.ValidateAll() if the designated
// constraints aren't met.
type ListArchivedTasksResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListArchivedTasksResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListArchivedTasksResMultiError) AllErrors() []error { return m }

// ListArchivedTasksResValidationError is the validation error returned by
// ListArchivedTasksRes.Validate if the designated constraints aren't met.
type ListArchivedTasksResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListArchivedTasksResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListArchivedTasksResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListArchivedTasksResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListArchivedTasksResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListArchivedTasksResValidationError) ErrorName() string {
	return "ListArchivedTasksResValidationError"
}

// Error satisfies the builtin error interface
func (e ListArchivedTasksResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListArchivedTasksRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListArchivedTasksResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListArchivedTasksResValidationError{}

// Validate checks the field values on ListCompletedTasksReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListCompletedTasksReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListCompletedTasksReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListCompletedTasksReqMultiError, or nil if none found.
func (m *ListCompletedTasksReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListCompletedTasksReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCurrentUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListCompletedTasksReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListCompletedTasksReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrentUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListCompletedTasksReqValidationError{
				field:  "CurrentUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetPageSize() < 0 {
		err := ListCompletedTasksReqValidationError{
			field:  "PageSize",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetPageNum() < 0 {
		err := ListCompletedTasksReqValidationError{
			field:  "PageNum",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetQueue()) < 1 {
		err := ListCompletedTasksReqValidationError{
			field:  "Queue",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListCompletedTasksReqMultiError(errors)
	}

	return nil
}

// ListCompletedTasksReqMultiError is an error wrapping multiple validation
// errors returned by ListCompletedTasksReq.ValidateAll() if the designated
// constraints aren't met.
type ListCompletedTasksReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCompletedTasksReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCompletedTasksReqMultiError) AllErrors() []error { return m }

// ListCompletedTasksReqValidationError is the validation error returned by
// ListCompletedTasksReq.Validate if the designated constraints aren't met.
type ListCompletedTasksReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCompletedTasksReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCompletedTasksReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCompletedTasksReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCompletedTasksReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCompletedTasksReqValidationError) ErrorName() string {
	return "ListCompletedTasksReqValidationError"
}

// Error satisfies the builtin error interface
func (e ListCompletedTasksReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCompletedTasksReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCompletedTasksReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCompletedTasksReqValidationError{}

// Validate checks the field values on ListCompletedTasksRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListCompletedTasksRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListCompletedTasksRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListCompletedTasksResMultiError, or nil if none found.
func (m *ListCompletedTasksRes) ValidateAll() error {
	return m.validate(true)
}

func (m *ListCompletedTasksRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetQueueInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListCompletedTasksResValidationError{
					field:  "QueueInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListCompletedTasksResValidationError{
					field:  "QueueInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetQueueInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListCompletedTasksResValidationError{
				field:  "QueueInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetTasksInfo() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListCompletedTasksResValidationError{
						field:  fmt.Sprintf("TasksInfo[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListCompletedTasksResValidationError{
						field:  fmt.Sprintf("TasksInfo[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListCompletedTasksResValidationError{
					field:  fmt.Sprintf("TasksInfo[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListCompletedTasksResMultiError(errors)
	}

	return nil
}

// ListCompletedTasksResMultiError is an error wrapping multiple validation
// errors returned by ListCompletedTasksRes.ValidateAll() if the designated
// constraints aren't met.
type ListCompletedTasksResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCompletedTasksResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCompletedTasksResMultiError) AllErrors() []error { return m }

// ListCompletedTasksResValidationError is the validation error returned by
// ListCompletedTasksRes.Validate if the designated constraints aren't met.
type ListCompletedTasksResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCompletedTasksResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCompletedTasksResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCompletedTasksResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCompletedTasksResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCompletedTasksResValidationError) ErrorName() string {
	return "ListCompletedTasksResValidationError"
}

// Error satisfies the builtin error interface
func (e ListCompletedTasksResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCompletedTasksRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCompletedTasksResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCompletedTasksResValidationError{}

// Validate checks the field values on RunTaskReq with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RunTaskReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RunTaskReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RunTaskReqMultiError, or
// nil if none found.
func (m *RunTaskReq) ValidateAll() error {
	return m.validate(true)
}

func (m *RunTaskReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCurrentUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RunTaskReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RunTaskReqValidationError{
					field:  "CurrentUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrentUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RunTaskReqValidationError{
				field:  "CurrentUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if utf8.RuneCountInString(m.GetQueue()) < 1 {
		err := RunTaskReqValidationError{
			field:  "Queue",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetId()) < 1 {
		err := RunTaskReqValidationError{
			field:  "Id",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return RunTaskReqMultiError(errors)
	}

	return nil
}

// RunTaskReqMultiError is an error wrapping multiple validation errors
// returned by RunTaskReq.ValidateAll() if the designated constraints aren't met.
type RunTaskReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RunTaskReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RunTaskReqMultiError) AllErrors() []error { return m }

// RunTaskReqValidationError is the validation error returned by
// RunTaskReq.Validate if the designated constraints aren't met.
type RunTaskReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RunTaskReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RunTaskReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RunTaskReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RunTaskReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RunTaskReqValidationError) ErrorName() string { return "RunTaskReqValidationError" }

// Error satisfies the builtin error interface
func (e RunTaskReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRunTaskReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RunTaskReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RunTaskReqValidationError{}

// Validate checks the field values on RunTaskRes with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RunTaskRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RunTaskRes with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RunTaskResMultiError, or
// nil if none found.
func (m *RunTaskRes) ValidateAll() error {
	return m.validate(true)
}

func (m *RunTaskRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return RunTaskResMultiError(errors)
	}

	return nil
}

// RunTaskResMultiError is an error wrapping multiple validation errors
// returned by RunTaskRes.ValidateAll() if the designated constraints aren't met.
type RunTaskResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RunTaskResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RunTaskResMultiError) AllErrors() []error { return m }

// RunTaskResValidationError is the validation error returned by
// RunTaskRes.Validate if the designated constraints aren't met.
type RunTaskResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RunTaskResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RunTaskResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RunTaskResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RunTaskResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RunTaskResValidationError) ErrorName() string { return "RunTaskResValidationError" }

// Error satisfies the builtin error interface
func (e RunTaskResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRunTaskRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RunTaskResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RunTaskResValidationError{}
