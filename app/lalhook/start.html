<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>高级TS播放器 - HLS流媒体播放</title>
<link href="https://vjs.zencdn.net/8.10.0/video-js.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<script src="https://cdn.jsdelivr.net/npm/hls.js@1.1.4/dist/hls.min.js"></script>
<script>
const apiUrl = "http://localhost:11002/v1/api/ts/list";
let currentStream = "";
let player, hls;
let tsFiles = [];
let prevTsFiles = []; // 用于比较新旧TS列表
let totalDuration = 0;
let updateInterval;
let isSeeking = false; // 新增：标记是否正在跳转
let isDragging = false;
let currentScale = 1; // 时间轴缩放级别

// 格式化时间
function formatTime(seconds) {
  const h = Math.floor(seconds / 3600);
  const m = Math.floor((seconds % 3600) / 60);
  const s = Math.floor(seconds % 60);
  return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
}

// 格式化日期时间
function formatDateTime(timestamp) {
  if (!timestamp) return '-';
  const date = new Date(Number(timestamp));
  return date.toLocaleString();
}

// 更新时间显示
function updateTimeDisplay() {
  const startTime = tsFiles.length > 0 ? tsFiles[0].timestamp : 0;
  const endTime = tsFiles.length > 0 ? tsFiles[tsFiles.length - 1].timestamp : 0;
  
  document.getElementById('start-time').textContent = formatDateTime(startTime).split(' ')[1];
  document.getElementById('end-time').textContent = formatDateTime(endTime).split(' ')[1];
  document.getElementById('total-time').textContent = formatTime(totalDuration);
  document.getElementById('ts-count').textContent = tsFiles.length;
  document.getElementById('last-update').textContent = new Date().toLocaleTimeString();
}

async function fetchTsList() {
  if (!currentStream || isSeeking) return; // 如果正在跳转，跳过此次更新

  // 获取时间范围参数
  const minutes = parseInt(document.getElementById("minutes-input").value) || 5;
  const startTimeInput = document.getElementById("start-time-input");
  const endTimeInput = document.getElementById("end-time-input");
  
  let startTime = null;
  let endTime = null;
  
  // 如果提供了开始和结束时间，则使用它们
  if (startTimeInput && startTimeInput.value && endTimeInput && endTimeInput.value) {
    startTime = new Date(startTimeInput.value).getTime();
    endTime = new Date(endTimeInput.value).getTime();
    console.log(`使用自定义时间范围: ${startTimeInput.value} 到 ${endTimeInput.value}`);
  } else {
    // 否则使用分钟参数
    const now = Date.now();
    const cutoff = now - minutes * 60 * 1000;
    startTime = cutoff;
    endTime = now;
    console.log(`使用分钟参数: ${minutes} 分钟`);
  }

  try {
    const res = await fetch(apiUrl, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ streamName: currentStream, event: "close", startTime: startTime, endTime: endTime })
    });
    const data = await res.json();

    if (!data.files || data.files.length === 0) {
      console.log('API未返回TS文件');
      return;
    }

    // 使用后端返回的TsTimestamp字段，提高准确性
    let newTsFiles = data.files
      .map(f => ({
        url: `http://localhost:8081/lal_record/hls/${currentStream}/${f.tsFile.split("/").pop()}`,
        duration: f.duration,
        tsId: f.tsId,
        timestamp: f.tsTimestamp,  // 直接使用后端返回的时间戳
        tsFile: f.tsFile  // 保留原始tsFile路径，用于显示文件名
      }))
      .filter(f => {
        // 使用后端返回的时间戳进行过滤
        return f.timestamp >= startTime && f.timestamp <= endTime;
      })
      .sort((a, b) => a.timestamp - b.timestamp); // 按时间戳升序排序

    console.log('新TS文件列表（已排序）:', newTsFiles.map(f => ({ timestamp: f.timestamp, url: f.url })));

    // 保存当前播放状态
    const video = document.getElementById("my-video");
    let currentPlaybackTime = 0;
    let wasPlaying = false;
    
    if (video) {
      currentPlaybackTime = video.currentTime;
      wasPlaying = !video.paused;
      console.log(`保存播放状态: 时间=${currentPlaybackTime}, 播放中=${wasPlaying}`);
    }
    
    // 比较新旧列表（通过JSON字符串比较，避免对象引用问题）
    if (JSON.stringify(newTsFiles) === JSON.stringify(prevTsFiles)) {
      console.log('TS列表无变化，跳过重建M3U8');
      return; // 无变化，不更新
    }

    // 更新tsFiles和prevTsFiles
    tsFiles = newTsFiles;
    prevTsFiles = [...tsFiles]; // 深拷贝

    if (tsFiles.length === 0) {
      console.log('没有符合时间范围的TS文件');
      return;
    }

    // 计算总时长
  totalDuration = tsFiles.reduce((sum, f) => sum + f.duration, 0);
  
  // 更新状态显示
  document.getElementById('current-stream').textContent = currentStream;
  updateTimeDisplay();
  
  // 确保在更新显示后重新渲染时间轴和播放列表
  renderTsBlocks();
  
  // 更新播放列表
  renderPlaylist();

    // 拼M3U8（正序）
    let m3u8 = "#EXTM3U\n#EXT-X-VERSION:3\n";
    m3u8 += `#EXT-X-TARGETDURATION:${Math.ceil(Math.max(...tsFiles.map(f => f.duration)))}\n`;
    m3u8 += "#EXT-X-MEDIA-SEQUENCE:0\n";
    tsFiles.forEach(f => m3u8 += `#EXTINF:${f.duration.toFixed(3)},\n${f.url}\n`);
    m3u8 += "#EXT-X-ENDLIST"; // 点播模式；如果想切换直播模式，注释此行

    console.log('生成的M3U8:', m3u8);

    const blob = new Blob([m3u8], { type: "application/vnd.apple.mpegurl" });
    const m3u8Url = URL.createObjectURL(blob);
    
    // 优化HLS播放器更新逻辑，避免不必要的重新初始化
    if (Hls.isSupported()) {
      // 如果HLS实例不存在，则创建新的实例
      if (!hls) {
        hls = new Hls();
        hls.attachMedia(video);
        
        // 添加事件监听器
        hls.on(Hls.Events.MANIFEST_PARSED, () => {
          console.log('HLS manifest parsed');
          
          // 恢复播放状态
          if (currentPlaybackTime > 0) {
            console.log(`尝试恢复播放状态: 时间=${currentPlaybackTime}, 播放中=${wasPlaying}`);
            video.currentTime = currentPlaybackTime;
            if (wasPlaying) {
              video.play().catch(e => {
                console.log('恢复播放失败:', e);
              });
            }
          } else {
            // 如果没有保存的播放状态，则尝试自动播放
            video.play().catch(e => {
              console.log('Auto-play prevented:', e);
              // 如果自动播放被阻止，添加一个点击事件来手动播放
              video.addEventListener('click', function playVideo() {
                video.play().catch(e => console.log('Play prevented:', e));
                video.removeEventListener('click', playVideo);
              });
            });
          }
        });
        
      }
      
      // 直接加载新的播放列表源
      hls.loadSource(m3u8Url);
      
      // 添加播放事件监听器
      hls.on(Hls.Events.MEDIA_ATTACHED, () => {
        console.log('Media attached');
        video.addEventListener('play', () => {
          console.log('Video play event');
        });
        
        video.addEventListener('playing', () => {
          console.log('Video playing event');
          // 视频开始播放时，更新播放列表活动状态
          updatePlaylistActiveItem();
        });
        
        video.addEventListener('pause', () => {
          console.log('Video pause event');
        });
        
        video.addEventListener('ended', () => {
          console.log('Video ended event');
          // 视频结束时，尝试播放下一个片段
          playNextSegment();
        });
      });
      
      // 添加错误事件监听器
      hls.on(Hls.Events.ERROR, (event, data) => {
        console.error('HLS error:', data);
        // 处理非致命错误
        if (!data.fatal) {
          console.warn('Non-fatal HLS error:', data.type, data.details);
          return;
        }
        
        // 处理致命错误
        switch(data.type) {
          case Hls.ErrorTypes.NETWORK_ERROR:
            console.log("网络错误，尝试重新加载...");
            // 销毁当前实例并重新创建
            if (hls) {
              hls.destroy();
              hls = null;
            }
            // 重新初始化播放器
            fetchTsList();
            break;
          case Hls.ErrorTypes.MEDIA_ERROR:
            console.log("媒体错误，尝试恢复...");
            // 先尝试恢复媒体错误
            hls.recoverMediaError();
            // 如果恢复失败，尝试再次恢复
            setTimeout(() => {
              hls.recoverMediaError();
            }, 3000);
            break;
          default:
            // 其他致命错误，重新加载源
            console.log("其他致命错误，重新加载源...");
            if (hls) {
              hls.destroy();
              hls = null;
            }
            fetchTsList();
            break;
        }
      });
    } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
      // Safari原生HLS支持
      video.src = m3u8Url;
      video.addEventListener('loadedmetadata', () => {
        console.log('Safari HLS loaded');
        
        // 恢复播放状态
        if (currentPlaybackTime > 0) {
          console.log(`尝试恢复播放状态: 时间=${currentPlaybackTime}, 播放中=${wasPlaying}`);
          video.currentTime = currentPlaybackTime;
          if (wasPlaying) {
            video.play().catch(e => {
              console.log('恢复播放失败:', e);
            });
          }
        } else {
          // 如果没有保存的播放状态，则尝试自动播放
          video.play().catch(e => {
            console.log('Auto-play prevented:', e);
            // 如果自动播放被阻止，添加一个点击事件来手动播放
            video.addEventListener('click', function playVideo() {
              video.play().catch(e => console.log('Play prevented:', e));
              video.removeEventListener('click', playVideo);
            });
          });
        }
      });
      
      // 添加播放事件监听器
      video.addEventListener('play', () => {
        console.log('Safari Video play event');
      });
      
      video.addEventListener('playing', () => {
        console.log('Safari Video playing event');
        // 视频开始播放时，更新播放列表活动状态
        updatePlaylistActiveItem();
      });
      
      video.addEventListener('pause', () => {
        console.log('Safari Video pause event');
      });
      
      video.addEventListener('ended', () => {
        console.log('Safari Video ended event');
        // 视频结束时，尝试播放下一个片段
        playNextSegment();
      });
      
      // 添加错误事件监听器
      video.addEventListener('error', (e) => {
        console.error('Safari Video error:', e);
        // 提供更详细的错误信息
        const errorMsg = e.message || e.target.error?.message || '未知错误';
        alert(`播放器遇到错误: ${errorMsg}，请刷新页面重试`);
        // 尝试重新加载源
        fetchTsList();
      });
    }
    
    // 渲染时间轴和播放列表
    renderTsBlocks();
  } catch (error) {
    console.error("获取TS列表失败:", error);
  }
}

// 初始化时间轴组件
function initTimeline() {
  // 初始化时间轴相关元素
  const timelineTrack = document.getElementById('timeline-track');
  const timelineSegments = document.getElementById('timeline-segments');
  const playhead = document.getElementById('playhead');
  
  // 确保元素存在
  if (!timelineTrack || !timelineSegments || !playhead) {
    console.warn('Timeline elements not found');
    return;
  }
  
  // 可以在这里添加任何需要的初始化逻辑
  // 目前时间轴是静态的，所以不需要复杂的初始化
}

// 初始化键盘控制
function initKeyboardControls() {
  // 可以在这里添加键盘控制逻辑
  // 目前没有实现具体的键盘控制功能
  console.log('Keyboard controls initialized');
}

// 更新播放头位置
function updatePlayheadPosition(percentage) {
  const playhead = document.getElementById('playhead');
  if (playhead) {
    // 确保百分比在0-100范围内
    const clampedPercentage = Math.max(0, Math.min(100, percentage));
    playhead.style.left = clampedPercentage + '%';
  }
}

// 添加时间轴点击事件处理函数
function setupTimelineClick() {
  const timelineTrack = document.getElementById('timeline-track');
  const segmentsContainer = document.getElementById("timeline-segments");
  
  if (!timelineTrack || !segmentsContainer) return;
  
  // 为时间轴轨道添加点击事件
  timelineTrack.addEventListener('click', function(e) {
    // 计算点击位置的百分比
    const rect = timelineTrack.getBoundingClientRect();
    const pos = (e.clientX - rect.left) / rect.width;
    const percentage = Math.max(0, Math.min(100, pos * 100));
    
    // 计算对应的视频时间
    const totalDuration = tsFiles.reduce((sum, f) => sum + f.duration, 0);
    const targetTime = (percentage / 100) * totalDuration;
    
    // 跳转到对应时间
    const video = document.getElementById("my-video");
    if (video) {
      // 设置跳转标记，防止定时刷新干扰
      isSeeking = true;
      
      video.currentTime = targetTime;
      
      // 确保视频在跳转后播放
      video.play().catch(e => console.log('Play prevented:', e));
      
      // 延迟重置跳转标记
      setTimeout(() => {
        isSeeking = false;
      }, 1000);
    }
  });
}

document.addEventListener('DOMContentLoaded', function() {
  initTimeline();
  initKeyboardControls(); // 初始化键盘控制
  setupTimelineClick(); // 设置时间轴点击事件
  
  // 设置默认值
  document.getElementById("stream-input").value = "test";
  document.getElementById("minutes-input").value = 5;
  
  // 设置默认的开始和结束时间
  const now = new Date();
  const fiveMinutesAgo = new Date(now.getTime() - 5 * 60 * 1000);
  
  // 格式化日期时间以适应datetime-local输入控件
  const formatDateTimeLocal = (date) => {
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    const hours = String(date.getHours()).padStart(2, '0');
    const minutes = String(date.getMinutes()).padStart(2, '0');
    return `${year}-${month}-${day}T${hours}:${minutes}`;
  };
  
  document.getElementById("start-time-input").value = formatDateTimeLocal(fiveMinutesAgo);
  document.getElementById("end-time-input").value = formatDateTimeLocal(now);
  
  // 绑定按钮事件
  document.getElementById('load-stream').addEventListener('click', startPlay);
  
  // 绑定自动刷新开关事件
  const autoRefreshCheckbox = document.getElementById('auto-refresh');
  if (autoRefreshCheckbox) {
    autoRefreshCheckbox.addEventListener('change', function() {
      if (this.checked) {
        console.log('启用自动刷新');
        // 如果当前有流正在播放，则启动定时刷新
        if (currentStream && updateInterval === null) {
          updateInterval = setInterval(fetchTsList, 5000);
        }
      } else {
        console.log('禁用自动刷新');
        // 清除定时刷新
        if (updateInterval) {
          clearInterval(updateInterval);
          updateInterval = null;
        }
      }
    });
  }
});

// renderTsBlocks
function renderTsBlocks() {
  const segmentsContainer = document.getElementById("timeline-segments");
  
  if (tsFiles.length === 0) {
    // 如果没有TS文件，清空时间轴
    if (segmentsContainer) segmentsContainer.innerHTML = "";
    return;
  }
  
  // 计算总时长
  const totalDuration = tsFiles.reduce((sum, f) => sum + f.duration, 0);
  
  // 如果总时长为0，不渲染
  if (totalDuration <= 0) return;
  
  // 检查是否需要重新渲染时间轴
  const existingSegments = segmentsContainer.querySelectorAll('.segment');
  
  // 如果现有片段数量与TS文件数量不匹配，则需要重新渲染
  if (existingSegments.length !== tsFiles.length) {
    // 清空现有内容
    segmentsContainer.innerHTML = "";
    
    let currentTime = 0; // 累计时间，用于计算每个片段的开始时间
    
    // 创建时间片段
    tsFiles.forEach((f, index) => {
      const widthPercent = (f.duration / totalDuration) * 100;
      
      // 避免创建宽度为0的片段
      if (widthPercent <= 0) return;
      
      const segment = document.createElement("div");
      segment.className = "segment has-data";
      segment.style.width = `${widthPercent}%`;
      
      // 添加title属性显示时间信息
      segment.title = `片段 ${index + 1}: ${formatTime(f.duration)} (${formatDateTime(f.timestamp)})`;
      
      // 添加点击事件，跳转到对应时间点
      segment.addEventListener('click', () => {
        const video = document.getElementById("my-video");
        if (video) {
          // 设置跳转标记，防止定时刷新干扰
          isSeeking = true;
          
          video.currentTime = currentTime;
          
          // 确保视频在跳转后播放
          video.play().catch(e => console.log('Play prevented:', e));
          
          // 延迟重置跳转标记
          setTimeout(() => {
            isSeeking = false;
          }, 1000);
        }
      });
      
      segmentsContainer.appendChild(segment);
      currentTime += f.duration; // 更新累计时间
    });
  } else {
    // 如果片段数量匹配，则只更新宽度和title属性
    tsFiles.forEach((f, index) => {
      const widthPercent = (f.duration / totalDuration) * 100;
      
      // 避免创建宽度为0的片段
      if (widthPercent <= 0) return;
      
      if (existingSegments[index]) {
        existingSegments[index].style.width = `${widthPercent}%`;
        existingSegments[index].title = `片段 ${index + 1}: ${formatTime(f.duration)} (${formatDateTime(f.timestamp)})`;
      }
    });
  }

  const video = document.getElementById("my-video");
  // 移除之前的时间更新监听器
  if (video) {
    video.removeEventListener("timeupdate", onVideoTimeUpdate);
    // 添加新的时间更新监听器
    video.addEventListener("timeupdate", onVideoTimeUpdate);
  }
  
  updateTimeDisplay();
  renderPlaylist(); // 渲染播放列表
}

// 视频时间更新处理函数
function onVideoTimeUpdate() {
  const video = document.getElementById("my-video");
  
  if (!video || tsFiles.length === 0) return;
  
  // 计算总时长
  const totalDuration = tsFiles.reduce((sum, f) => sum + f.duration, 0);
  
  // 避免除以零的情况
  if (totalDuration <= 0) return;
  
  const currentPercentage = (video.currentTime / totalDuration) * 100;
  
  // 更新播放头位置
  updatePlayheadPosition(currentPercentage);
  
  // 更新时间提示
  const playheadTooltip = document.getElementById('playhead-tooltip');
  if (playheadTooltip) {
    playheadTooltip.textContent = formatTime(video.currentTime);
  }
  
  // 更新时间轴高亮
  let currentTime = 0;
  const segments = document.querySelectorAll(".segment");
  
  tsFiles.forEach((f, idx) => {
    const start = currentTime;
    const end = currentTime + f.duration;
    if (segments[idx]) {
      segments[idx].classList.toggle("active", video.currentTime >= start && video.currentTime < end);
    }
    currentTime = end;
  });
  
  // 使用requestAnimationFrame确保更新播放列表活动项时DOM已更新
  requestAnimationFrame(() => {
    // 更新播放列表活动项
    updatePlaylistActiveItem();
  });
}

function startPlay() {
  const streamName = document.getElementById("stream-input").value.trim();
  if (!streamName) {
    // 将alert改为console.warn，避免弹窗影响其他程序使用
    console.warn("请输入streamName");
    return;
  }

  console.log(`开始加载流: ${streamName}`);
  
  currentStream = streamName;

  // 清除之前的更新间隔
  if (updateInterval) {
    console.log('清除之前的更新间隔');
    clearInterval(updateInterval);
    updateInterval = null;
  }

  // 重置prevTsFiles
  console.log('重置prevTsFiles');
  prevTsFiles = [];

  // 销毁之前的HLS实例
  if (hls) {
    console.log('销毁之前的HLS实例');
    hls.destroy();
    hls = null;
  }

  // 重置tsFiles
  console.log('重置tsFiles');
  tsFiles = [];
  
  // 重置总时长
  console.log('重置总时长');
  totalDuration = 0;

  // 立即获取一次数据
  console.log('立即获取一次数据');
  fetchTsList();
  
  // 检查是否启用自动刷新
  const autoRefreshCheckbox = document.getElementById('auto-refresh');
  if (autoRefreshCheckbox && autoRefreshCheckbox.checked) {
    // 每 5 秒刷新
    console.log('设置更新间隔');
    updateInterval = setInterval(fetchTsList, 5000);
  } else {
    console.log('自动刷新已禁用');
  }
}

// 渲染播放列表
function renderPlaylist() {
  const playlistContainer = document.getElementById("playlist");
  
  if (tsFiles.length === 0) {
    // 如果没有TS文件，清空播放列表
    if (playlistContainer) playlistContainer.innerHTML = "";
    return;
  }
  
  // 检查是否需要重新渲染播放列表
  const existingItems = playlistContainer.querySelectorAll('.playlist-item');
  
  // 如果现有项数量与TS文件数量不匹配，则需要重新渲染
  if (existingItems.length !== tsFiles.length) {
    // 清空现有内容
    playlistContainer.innerHTML = "";
    
    tsFiles.forEach((f, index) => {
      const listItem = document.createElement("li");
      listItem.className = "playlist-item";
      
      // 格式化时间戳
      const timestamp = formatDateTime(f.timestamp);
      
      // 格式化时长
      const duration = formatTime(f.duration);
      
      // 显示TSID
      const tsId = f.tsId || 'N/A';
      
      // 从文件URL中提取文件名
      const fileName = f.tsFile ? f.tsFile.split('/').pop() : 'N/A';
      
      listItem.innerHTML = `
        <span class="name">片段 ${index + 1} (ID: ${tsId})</span>
        <span class="filename">文件: ${fileName}</span>
        <span class="time">${timestamp}</span>
        <span class="duration">时长: ${duration}</span>
      `;
      
      // 添加点击事件
      listItem.addEventListener('click', () => {
        const video = document.getElementById("my-video");
        if (video) {
          // 计算前面片段的总时长，作为跳转时间点
          let seekTime = 0;
          for (let i = 0; i < index; i++) {
            seekTime += tsFiles[i].duration;
          }
          
          // 设置跳转标记，防止定时刷新干扰
          isSeeking = true;
          
          video.currentTime = seekTime;
          
          // 确保视频在跳转后播放
          video.play().catch(e => console.log('Play prevented:', e));
          
          // 更新活动状态
          document.querySelectorAll('.playlist-item').forEach(item => item.classList.remove('active'));
          listItem.classList.add('active');
          
          // 延迟重置跳转标记
          setTimeout(() => {
            isSeeking = false;
          }, 1000);
        }
      });
      
      playlistContainer.appendChild(listItem);
    });
  } else {
    // 如果项数量匹配，则只更新内容
    tsFiles.forEach((f, index) => {
      // 格式化时间戳
      const timestamp = formatDateTime(f.timestamp);
      
      // 格式化时长
      const duration = formatTime(f.duration);
      
      // 显示TSID
      const tsId = f.tsId || 'N/A';
      
      if (existingItems[index]) {
        // 从文件URL中提取文件名
        const fileName = f.tsFile ? f.tsFile.split('/').pop() : 'N/A';
        
        existingItems[index].innerHTML = `
          <span class="name">片段 ${index + 1} (ID: ${tsId})</span>
          <span class="filename">文件: ${fileName}</span>
          <span class="time">${timestamp}</span>
          <span class="duration">时长: ${duration}</span>
        `;
      }
    });
  }
  
  // 添加滚动事件监听器，确保播放列表能正确滚动
  const playlist = document.getElementById("playlist");
  if (playlist) {
    let scrollTimer;
    playlist.addEventListener('scroll', () => {
      console.log('Playlist scrolled');
      // 设置滚动标记
      isDragging = true;
      
      // 清除之前的定时器
      clearTimeout(scrollTimer);
      
      // 设置新的定时器，在滚动停止后重置标记
      scrollTimer = setTimeout(() => {
        isDragging = false;
        console.log('Scrolling stopped');
      }, 150); // 减少延迟到150ms，使自动滚动响应更灵敏
    });
  }
  
  // 初始化时更新活动项
  // 只有在非自动滚动状态下才更新活动项，避免自动刷新时干扰用户滚动
  if (!isDragging) {
    updatePlaylistActiveItem();
  }
}

// 播放下一个片段
function playNextSegment() {
  console.log('Attempting to play next segment');
  
  // 检查当前播放时间
  const video = document.getElementById("my-video");
  const currentTime = video.currentTime;
  
  // 查找当前播放的片段
  let currentSegmentIndex = -1;
  let accumulatedTime = 0;
  
  for (let i = 0; i < tsFiles.length; i++) {
    accumulatedTime += tsFiles[i].duration;
    if (currentTime < accumulatedTime) {
      currentSegmentIndex = i;
      break;
    }
  }
  
  // 如果找到了当前片段，并且还有下一个片段
  if (currentSegmentIndex >= 0 && currentSegmentIndex < tsFiles.length - 1) {
    const nextSegmentIndex = currentSegmentIndex + 1;
    const nextSegmentStartTime = accumulatedTime - tsFiles[currentSegmentIndex].duration;
    
    console.log(`Playing next segment: ${nextSegmentIndex}`);
    
    // 跳转到下一个片段的开始时间
    video.currentTime = nextSegmentStartTime;
    
    // 确保视频继续播放
    video.play().catch(e => {
      console.log('Failed to play next segment:', e);
    });
  } else {
    console.log('No next segment to play or reached end of playlist');
  }
}

// 更新播放列表活动项
function updatePlaylistActiveItem() {
  const video = document.getElementById("my-video");
  if (!video || tsFiles.length === 0) return;
  
  const currentTime = video.currentTime;
  let accumulatedTime = 0;
  let activeIndex = -1;
  
  // 查找当前播放的片段索引
  for (let i = 0; i < tsFiles.length; i++) {
    if (currentTime >= accumulatedTime && currentTime < accumulatedTime + tsFiles[i].duration) {
      activeIndex = i;
      break;
    }
    accumulatedTime += tsFiles[i].duration;
  }
  
  // 更新播放列表项的活动状态
  const playlistItems = document.querySelectorAll('.playlist-item');
  playlistItems.forEach((item, index) => {
    if (index === activeIndex) {
      item.classList.add('active');
      // 只在用户没有主动滚动时才自动滚动到活动项
      const playlistContainer = document.getElementById("playlist");
      if (playlistContainer && !isDragging) {
        // 使用requestAnimationFrame确保DOM更新完成后再执行滚动
        requestAnimationFrame(() => {
          // 检查元素是否在可视区域内
          const containerRect = playlistContainer.getBoundingClientRect();
          const itemRect = item.getBoundingClientRect();
          
          // 如果元素不在可视区域内，则滚动到元素位置
          if (itemRect.top < containerRect.top || itemRect.bottom > containerRect.bottom) {
            // 在执行自动滚动前，再次检查isDragging状态
            if (!isDragging) {
              // 计算滚动位置，使元素居中显示
              const scrollTop = item.offsetTop - playlistContainer.offsetHeight / 2 + item.offsetHeight / 2;
              // 使用平滑滚动，但添加边界检查
              if (!isNaN(scrollTop) && isFinite(scrollTop)) {
                playlistContainer.scrollTo({
                  top: Math.max(0, scrollTop),
                  behavior: 'smooth'
                });
              }
            }
          }
        });
      }
    } else {
      item.classList.remove('active');
    }
  });
}

</script>
<style>
  :root {
    --primary-color: #ff9e01;
    --bg-dark: #121212;
    --bg-card: #1e1e1e;
    --bg-hover: #2d2d2d;
    --text-primary: #ffffff;
    --text-secondary: #aaaaaa;
    --border-radius: 8px;
    --transition: all 0.3s ease;
  }
  
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }
  
  body {
    background: var(--bg-dark);
    color: var(--text-primary);
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    line-height: 1.6;
    padding: 0; /* 移除body的padding，使用.container的padding */
    min-height: 100vh;
  }
  
  .container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 20px;
  }
  
  header {
    text-align: center;
    margin-bottom: 25px;
  }
  
  h1 {
    font-size: 2.2rem;
    margin-bottom: 10px;
    color: var(--primary-color);
  }
  
  .subtitle {
    color: var(--text-secondary);
    font-size: 1.1rem;
  }
  
  /* 响应式设计 */
  @media (max-width: 768px) {
    .container {
      padding: 10px;
    }
    
    .control-group {
      flex-direction: column;
      align-items: stretch;
    }
    
    .control-group label {
      margin-bottom: 5px;
    }
    
    .control-group input[type="text"],
    .control-group input[type="number"],
    .control-group input[type="datetime-local"] {
      min-width: unset;
    }
    
    #my-video {
      height: 300px;
    }
    
    .status-content {
      grid-template-columns: 1fr;
    }
    
    .time-scale {
      font-size: 0.75rem;
    }
  }
  
  .control-panel {
    background: var(--bg-card);
    padding: 20px;
    border-radius: var(--border-radius);
    margin-bottom: 25px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
  }
  
  .control-group {
    display: flex;
    gap: 15px;
    flex-wrap: wrap;
    align-items: center;
    margin-bottom: 15px;
  }
  
  .control-group label {
    font-weight: 500;
    color: var(--text-primary);
    white-space: nowrap;
  }
  
  .control-group input[type="text"],
  .control-group input[type="number"],
  .control-group input[type="datetime-local"] {
    padding: 8px 12px;
    border: 1px solid #444;
    border-radius: 4px;
    background: #2a2a2a;
    color: var(--text-primary);
    font-size: 1rem;
    min-width: 120px;
  }
  
  .control-group input[type="datetime-local"] {
    min-width: 180px;
  }
  
  .control-group button {
    padding: 8px 15px;
    background: var(--primary-color);
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-weight: 500;
    transition: var(--transition);
  }
  
  .control-group button:hover {
    background: #e68a00;
    transform: translateY(-2px);
  }
  
  .input-group {
    display: flex;
    gap: 15px;
    flex-wrap: wrap;
    align-items: center;
    margin-bottom: 15px;
    flex-wrap: wrap;
  }
  
  .input-group label {
    font-weight: 500;
    color: var(--text-primary);
    white-space: nowrap;
  }
  
  .input-group input[type="text"],
  .input-group input[type="number"],
  .input-group input[type="datetime-local"] {
    padding: 8px 12px;
    border: 1px solid #444;
    border-radius: 4px;
    background: #2a2a2a;
    color: var(--text-primary);
    font-size: 1rem;
    min-width: 120px;
  }
  
  .input-group input[type="datetime-local"] {
    min-width: 180px;
  }
  
  .input-group button {
    padding: 8px 15px;
    background: var(--primary-color);
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-weight: 500;
    transition: var(--transition);
  }
  
  .input-group button:hover {
    background: #e68a00;
    transform: translateY(-2px);
  }
  
  .input-field {
    flex: 1;
    min-width: 250px;
  }
  
  .input-field label {
    display: block;
    margin-bottom: 8px;
    font-weight: 500;
    color: var(--text-secondary);
  }
  
  .input-field input {
    width: 100%;
    padding: 12px 15px;
    border: 1px solid #444;
    border-radius: var(--border-radius);
    background: #2a2a2a;
    color: var(--text-primary);
    font-size: 1rem;
    transition: var(--transition);
  }
  
  .input-field input:focus {
    outline: none;
    border-color: var(--primary-color);
    box-shadow: 0 0 0 2px rgba(255, 158, 1, 0.2);
  }
  
  .btn {
    padding: 12px 25px;
    background: var(--primary-color);
    color: #000;
    border: none;
    border-radius: var(--border-radius);
    cursor: pointer;
    font-weight: 600;
    font-size: 1rem;
    transition: var(--transition);
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
  }
  
  .btn:hover {
    background: #ffb43a;
    transform: translateY(-2px);
  }
  
  .btn:active {
    transform: translateY(0);
  }
  
  .btn i {
    font-size: 1.1rem;
  }
  
  .video-container {
    position: relative;
    margin-bottom: 25px;
    border-radius: var(--border-radius);
    overflow: hidden;
    box-shadow: 0 6px 16px rgba(0, 0, 0, 0.3);
    background: #000; /* 添加黑色背景 */
    z-index: 1;
  }
  
  #my-video {
    width: 100%;
    height: 500px;
    background: #000;
  }
  
  .controls {
    background: var(--bg-card);
    padding: 15px 20px;
    border-bottom: 1px solid #333;
  }
  
  .timeline-container {
    background: var(--bg-card);
    padding: 20px;
    border-radius: var(--border-radius);
    margin-bottom: 25px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
    position: relative;
    z-index: 2;
  }
  
  .timeline-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
  }
  
  .timeline-title {
    font-size: 1.2rem;
    font-weight: 600;
  }
  
  .timeline-actions button {
    background: transparent;
    border: 1px solid #444;
    color: var(--text-secondary);
    padding: 8px 15px;
    border-radius: var(--border-radius);
    cursor: pointer;
    transition: var(--transition);
  }
  
  .timeline-actions button:hover {
    color: var(--primary-color);
    border-color: var(--primary-color);
  }
  
  #timestamps {
    width: 100%;
    height: 60px;
    padding: 10px 0;
    background: #2a2a2a;
    border-radius: var(--border-radius);
    position: relative;
    overflow: hidden;
  }
  
  .timeline-wrapper {
    width: 100%;
    height: 100%;
    position: relative;
    overflow-x: hidden;
  }
  
  .timeline-track {
    width: 100%;
    height: 20px;
    background: #333;
    border-radius: 10px;
    position: relative;
    cursor: pointer;
    margin-top: 10px;
    transform-origin: left center;
    transition: transform 0.2s ease;
  }
  
  .timeline-progress {
    height: 100%;
    background: var(--primary-color);
    border-radius: 10px;
    width: 0%;
    position: relative;
    transition: width 0.1s linear;
  }
  
  .timeline-segments {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
  }
  
  .segment {
    height: 100%;
    background: #444;
    border-right: 1px solid #2a2a2a;
    position: relative;
    transition: background 0.2s;
  }
  
  .segment.has-data {
    background: #555;
  }
  
  .segment.active {
    background: #007acc;
  }
  
  .playhead {
    position: absolute;
    top: -5px;
    left: 0;
    width: 10px;
    height: 30px;
    background: var(--primary-color);
    border-radius: 3px;
    cursor: pointer;
    z-index: 10;
    transform: translateX(-50%);
    box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
    transition: left 0.1s linear;
  }
  
  .playhead::after {
    content: '';
    position: absolute;
    top: 100%;
    left: 50%;
    transform: translateX(-50%);
    border-left: 5px solid transparent;
    border-right: 5px solid transparent;
    border-top: 5px solid var(--primary-color);
  }
  
  .playhead.dragging {
    background: #007acc;
  }
  
  .playhead-tooltip {
    position: absolute;
    bottom: 100%;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0, 0, 0, 0.8);
    color: white;
    padding: 5px 10px;
    border-radius: 4px;
    font-size: 0.85rem;
    white-space: nowrap;
    z-index: 1000;
    display: none;
    margin-bottom: 5px;
  }
  
  .playhead:hover .playhead-tooltip,
  .playhead.dragging .playhead-tooltip {
    display: block;
  }
  
  .time-scale {
    display: flex;
    justify-content: space-between;
    margin-top: 8px;
    color: var(--text-secondary);
    font-size: 0.85rem;
  }
  
  .status-panel {
    background: var(--bg-card);
    padding: 20px;
    border-radius: var(--border-radius);
    margin-bottom: 25px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
  }
  
  .status-title {
    font-size: 1.2rem;
    font-weight: 600;
    margin-bottom: 15px;
    color: var(--primary-color);
  }
  
  .status-content {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
    gap: 15px;
  }
  
  .status-item {
    background: #2a2a2a;
    padding: 15px;
    border-radius: var(--border-radius);
    border-left: 3px solid var(--primary-color);
  }
  
  .status-item .label {
    color: var(--text-secondary);
    font-size: 0.9rem;
    margin-bottom: 5px;
  }
  
  .status-item .value {
    font-size: 1.1rem;
    font-weight: 500;
  }
  
  .playlist-container {
    background: var(--bg-card);
    padding: 20px;
    border-radius: var(--border-radius);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
    margin-bottom: 25px;
  }
  
  .playlist-header {
    font-size: 1.2rem;
    font-weight: 600;
    margin-bottom: 15px;
    color: var(--primary-color);
  }
  
  #playlist {
    list-style: none;
    max-height: 300px;
    overflow-y: auto;
    /* 确保滚动条在不同浏览器中都能正常显示 */
    scrollbar-width: thin;
    scrollbar-color: #555 #2a2a2a;
  }
  
  .playlist-item {
    padding: 12px 15px;
    border-bottom: 1px solid #333;
    cursor: pointer;
    transition: var(--transition);
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  
  .playlist-item:hover {
    background: var(--bg-hover);
  }
  
  .playlist-item.active {
    background: rgba(255, 158, 1, 0.15);
    border-left: 3px solid var(--primary-color);
  }
  
  .playlist-item .time {
    color: var(--text-secondary);
    font-size: 0.9rem;
  }
  
  .playlist-item .duration {
    color: var(--text-secondary);
    font-size: 0.9rem;
    margin-left: 10px;
  }
  
  .playlist-item .filename {
    color: #ccc;
    font-size: 0.85rem;
    font-family: 'Courier New', monospace;
    margin: 5px 0;
    word-break: break-all;
  }
  
  /* 滚动条样式 */
  #playlist::-webkit-scrollbar {
    width: 8px;
  }
  
  #playlist::-webkit-scrollbar-track {
    background: #2a2a2a;
    border-radius: 4px;
  }
  
  #playlist::-webkit-scrollbar-thumb {
    background: #555;
    border-radius: 4px;
  }
  
  #playlist::-webkit-scrollbar-thumb:hover {
    background: #777;
  }
  
  /* 响应式设计调整 */
  @media (max-width: 768px) {
    .playlist-container {
      padding: 15px;
    }
    
    .playlist-item {
      flex-direction: column;
      align-items: flex-start;
    }
    
    .playlist-item .duration {
      margin-left: 0;
      margin-top: 5px;
    }
    
    .container {
      padding: 10px;
    }
    
    .control-group {
      flex-direction: column;
      align-items: stretch;
    }
    
    .control-group label {
      margin-bottom: 5px;
    }
    
    .control-group input[type="text"],
    .control-group input[type="number"],
    .control-group input[type="datetime-local"] {
      min-width: unset;
    }
    
    #my-video {
      height: 300px;
    }
    
    .status-content {
      grid-template-columns: 1fr;
    }
    
    .time-scale {
      font-size: 0.75rem;
    }
    
    .input-group {
      flex-direction: column;
      align-items: stretch;
    }
    
    .input-field {
      min-width: unset;
    }
  }
  
  footer {
    text-align: center;
    margin-top: 40px;
    color: var(--text-secondary);
    font-size: 0.9rem;
  }
  
  /* 滚动条样式 */
  ::-webkit-scrollbar {
    width: 12px;
  }
  
  ::-webkit-scrollbar-track {
    background: #2a2a2a;
  }
  
  ::-webkit-scrollbar-thumb {
    background: #555;
    border-radius: 6px;
  }
  
  ::-webkit-scrollbar-thumb:hover {
    background: #777;
  }

</style>
</head>
<body>
  <div class="container">
    <header>
      <h1>高级TS播放器</h1>
      <p class="subtitle">HLS流媒体播放解决方案</p>
    </header>
    
    <div class="main-container">
      <div class="video-container">
    <div class="video-wrapper">
      <video id="my-video" class="video-js vjs-default-skin" controls preload="auto" width="100%" height="360">
        <source src="" type="application/x-mpegURL">
      </video>
    </div>
    
    <div class="controls">
      <div class="control-group">
        <label for="stream-input">流地址:</label>
        <input type="text" id="stream-input" placeholder="请输入HLS流地址">
        <button id="load-stream">加载流</button>
        <label for="auto-refresh">自动刷新:</label>
        <input type="checkbox" id="auto-refresh" checked>
      </div>
      
      <!-- 移除上一个下一个流按钮，因为该功能没有必要 -->
      
      <div class="control-group">
        <label for="minutes-input">时间范围(分钟):</label>
        <input type="number" id="minutes-input" min="1" max="60" value="5">
        <span id="current-time">00:00:00</span>
        <span>/</span>
        <span id="total-time">00:00:00</span>
        <span id="zoom-indicator">缩放: 100%</span>
      </div>
      
      <div class="control-group">
        <label for="start-time-input">开始时间:</label>
        <input type="datetime-local" id="start-time-input">
        <label for="end-time-input">结束时间:</label>
        <input type="datetime-local" id="end-time-input">
      </div>
    </div>
    
    <div class="timeline-container">
      <div id="timestamps">
        <div class="timeline-wrapper">
          <div id="timeline-track" class="timeline-track">
            <div id="timeline-progress" class="timeline-progress"></div>
            <div id="timeline-segments" class="timeline-segments"></div>
            <div id="playhead" class="playhead">
              <div id="playhead-tooltip" class="playhead-tooltip"></div>
            </div>
          </div>
        </div>
      </div>
    </div>
    
    <div class="time-scale">
      <span id="start-time">00:00</span>
      <span id="end-time">00:00</span>
    </div>
    </div>
    
    <div class="status-panel">
      <div class="status-title">播放状态</div>
      <div class="status-content">
        <div class="status-item">
          <div class="label">当前流</div>
          <div id="current-stream" class="value">未选择</div>
        </div>
        <div class="status-item">
          <div class="label">TS片段数量</div>
          <div id="ts-count" class="value">0</div>
        </div>
        <div class="status-item">
          <div class="label">总时长</div>
          <div id="total-duration" class="value">00:00:00</div>
        </div>
        <div class="status-item">
          <div class="label">更新时间</div>
          <div id="last-update" class="value">-</div>
        </div>
      </div>
    </div>
    
    <div class="playlist-container">
      <div class="playlist-header">播放列表</div>
      <ul id="playlist"></ul>
    </div>
    
    <footer>
      <p>高级TS播放器 &copy; 2023 - HLS流媒体播放解决方案</p>
    </footer>
  </div>
</body>
</html>