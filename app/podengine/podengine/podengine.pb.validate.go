// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: podengine.proto

package podengine

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on PodCondition with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PodCondition) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PodCondition with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PodConditionMultiError, or
// nil if none found.
func (m *PodCondition) ValidateAll() error {
	return m.validate(true)
}

func (m *PodCondition) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Type

	// no validation rules for Status

	// no validation rules for Reason

	// no validation rules for Message

	// no validation rules for LastTransitionTime

	if len(errors) > 0 {
		return PodConditionMultiError(errors)
	}

	return nil
}

// PodConditionMultiError is an error wrapping multiple validation errors
// returned by PodCondition.ValidateAll() if the designated constraints aren't met.
type PodConditionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PodConditionMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PodConditionMultiError) AllErrors() []error { return m }

// PodConditionValidationError is the validation error returned by
// PodCondition.Validate if the designated constraints aren't met.
type PodConditionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PodConditionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PodConditionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PodConditionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PodConditionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PodConditionValidationError) ErrorName() string { return "PodConditionValidationError" }

// Error satisfies the builtin error interface
func (e PodConditionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPodCondition.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PodConditionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PodConditionValidationError{}

// Validate checks the field values on ContainerState with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ContainerState) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ContainerState with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ContainerStateMultiError,
// or nil if none found.
func (m *ContainerState) ValidateAll() error {
	return m.validate(true)
}

func (m *ContainerState) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Running

	// no validation rules for Terminated

	// no validation rules for Waiting

	// no validation rules for Reason

	// no validation rules for Message

	// no validation rules for StartedTime

	// no validation rules for FinishedTime

	// no validation rules for ExitCode

	if len(errors) > 0 {
		return ContainerStateMultiError(errors)
	}

	return nil
}

// ContainerStateMultiError is an error wrapping multiple validation errors
// returned by ContainerState.ValidateAll() if the designated constraints
// aren't met.
type ContainerStateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ContainerStateMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ContainerStateMultiError) AllErrors() []error { return m }

// ContainerStateValidationError is the validation error returned by
// ContainerState.Validate if the designated constraints aren't met.
type ContainerStateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ContainerStateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ContainerStateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ContainerStateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ContainerStateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ContainerStateValidationError) ErrorName() string { return "ContainerStateValidationError" }

// Error satisfies the builtin error interface
func (e ContainerStateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sContainerState.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ContainerStateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ContainerStateValidationError{}

// Validate checks the field values on Container with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Container) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Container with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ContainerMultiError, or nil
// if none found.
func (m *Container) ValidateAll() error {
	return m.validate(true)
}

func (m *Container) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Image

	if all {
		switch v := interface{}(m.GetState()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ContainerValidationError{
					field:  "State",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ContainerValidationError{
					field:  "State",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetState()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ContainerValidationError{
				field:  "State",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Env

	// no validation rules for Resources

	if len(errors) > 0 {
		return ContainerMultiError(errors)
	}

	return nil
}

// ContainerMultiError is an error wrapping multiple validation errors returned
// by Container.ValidateAll() if the designated constraints aren't met.
type ContainerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ContainerMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ContainerMultiError) AllErrors() []error { return m }

// ContainerValidationError is the validation error returned by
// Container.Validate if the designated constraints aren't met.
type ContainerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ContainerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ContainerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ContainerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ContainerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ContainerValidationError) ErrorName() string { return "ContainerValidationError" }

// Error satisfies the builtin error interface
func (e ContainerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sContainer.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ContainerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ContainerValidationError{}

// Validate checks the field values on ContainerSpec with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ContainerSpec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ContainerSpec with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ContainerSpecMultiError, or
// nil if none found.
func (m *ContainerSpec) ValidateAll() error {
	return m.validate(true)
}

func (m *ContainerSpec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetName()) < 1 {
		err := ContainerSpecValidationError{
			field:  "Name",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetImage()) < 1 {
		err := ContainerSpecValidationError{
			field:  "Image",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Env

	// no validation rules for Resources

	if len(errors) > 0 {
		return ContainerSpecMultiError(errors)
	}

	return nil
}

// ContainerSpecMultiError is an error wrapping multiple validation errors
// returned by ContainerSpec.ValidateAll() if the designated constraints
// aren't met.
type ContainerSpecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ContainerSpecMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ContainerSpecMultiError) AllErrors() []error { return m }

// ContainerSpecValidationError is the validation error returned by
// ContainerSpec.Validate if the designated constraints aren't met.
type ContainerSpecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ContainerSpecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ContainerSpecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ContainerSpecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ContainerSpecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ContainerSpecValidationError) ErrorName() string { return "ContainerSpecValidationError" }

// Error satisfies the builtin error interface
func (e ContainerSpecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sContainerSpec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ContainerSpecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ContainerSpecValidationError{}

// Validate checks the field values on PodSpec with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PodSpec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PodSpec with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in PodSpecMultiError, or nil if none found.
func (m *PodSpec) ValidateAll() error {
	return m.validate(true)
}

func (m *PodSpec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetName()) < 1 {
		err := PodSpecValidationError{
			field:  "Name",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetContainers()) < 1 {
		err := PodSpecValidationError{
			field:  "Containers",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetContainers() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PodSpecValidationError{
						field:  fmt.Sprintf("Containers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PodSpecValidationError{
						field:  fmt.Sprintf("Containers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PodSpecValidationError{
					field:  fmt.Sprintf("Containers[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Labels

	// no validation rules for Annotations

	if _, ok := _PodSpec_RestartPolicy_InLookup[m.GetRestartPolicy()]; !ok {
		err := PodSpecValidationError{
			field:  "RestartPolicy",
			reason: "value must be in list [no onFailure always]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for TerminationGracePeriodSeconds

	if _, ok := _PodSpec_NetworkMode_InLookup[m.GetNetworkMode()]; !ok {
		err := PodSpecValidationError{
			field:  "NetworkMode",
			reason: "value must be in list [bridge host none]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for NetworkName

	// no validation rules for NetworkConfig

	if len(errors) > 0 {
		return PodSpecMultiError(errors)
	}

	return nil
}

// PodSpecMultiError is an error wrapping multiple validation errors returned
// by PodSpec.ValidateAll() if the designated constraints aren't met.
type PodSpecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PodSpecMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PodSpecMultiError) AllErrors() []error { return m }

// PodSpecValidationError is the validation error returned by PodSpec.Validate
// if the designated constraints aren't met.
type PodSpecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PodSpecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PodSpecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PodSpecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PodSpecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PodSpecValidationError) ErrorName() string { return "PodSpecValidationError" }

// Error satisfies the builtin error interface
func (e PodSpecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPodSpec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PodSpecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PodSpecValidationError{}

var _PodSpec_RestartPolicy_InLookup = map[string]struct{}{
	"no":        {},
	"onFailure": {},
	"always":    {},
}

var _PodSpec_NetworkMode_InLookup = map[string]struct{}{
	"bridge": {},
	"host":   {},
	"none":   {},
}

// Validate checks the field values on Pod with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Pod) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Pod with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in PodMultiError, or nil if none found.
func (m *Pod) ValidateAll() error {
	return m.validate(true)
}

func (m *Pod) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for Phase

	for idx, item := range m.GetConditions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PodValidationError{
						field:  fmt.Sprintf("Conditions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PodValidationError{
						field:  fmt.Sprintf("Conditions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PodValidationError{
					field:  fmt.Sprintf("Conditions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetContainers() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PodValidationError{
						field:  fmt.Sprintf("Containers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PodValidationError{
						field:  fmt.Sprintf("Containers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PodValidationError{
					field:  fmt.Sprintf("Containers[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Labels

	// no validation rules for Annotations

	// no validation rules for CreationTime

	// no validation rules for StartTime

	// no validation rules for DeletionTime

	if len(errors) > 0 {
		return PodMultiError(errors)
	}

	return nil
}

// PodMultiError is an error wrapping multiple validation errors returned by
// Pod.ValidateAll() if the designated constraints aren't met.
type PodMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PodMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PodMultiError) AllErrors() []error { return m }

// PodValidationError is the validation error returned by Pod.Validate if the
// designated constraints aren't met.
type PodValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PodValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PodValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PodValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PodValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PodValidationError) ErrorName() string { return "PodValidationError" }

// Error satisfies the builtin error interface
func (e PodValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPod.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PodValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PodValidationError{}

// Validate checks the field values on CreatePodReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CreatePodReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreatePodReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CreatePodReqMultiError, or
// nil if none found.
func (m *CreatePodReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CreatePodReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetName()) < 1 {
		err := CreatePodReqValidationError{
			field:  "Name",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetSpec() == nil {
		err := CreatePodReqValidationError{
			field:  "Spec",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetSpec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreatePodReqValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreatePodReqValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSpec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreatePodReqValidationError{
				field:  "Spec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreatePodReqMultiError(errors)
	}

	return nil
}

// CreatePodReqMultiError is an error wrapping multiple validation errors
// returned by CreatePodReq.ValidateAll() if the designated constraints aren't met.
type CreatePodReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreatePodReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreatePodReqMultiError) AllErrors() []error { return m }

// CreatePodReqValidationError is the validation error returned by
// CreatePodReq.Validate if the designated constraints aren't met.
type CreatePodReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreatePodReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreatePodReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreatePodReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreatePodReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreatePodReqValidationError) ErrorName() string { return "CreatePodReqValidationError" }

// Error satisfies the builtin error interface
func (e CreatePodReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreatePodReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreatePodReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreatePodReqValidationError{}

// Validate checks the field values on CreatePodRes with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CreatePodRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreatePodRes with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CreatePodResMultiError, or
// nil if none found.
func (m *CreatePodRes) ValidateAll() error {
	return m.validate(true)
}

func (m *CreatePodRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPod()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreatePodResValidationError{
					field:  "Pod",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreatePodResValidationError{
					field:  "Pod",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPod()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreatePodResValidationError{
				field:  "Pod",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreatePodResMultiError(errors)
	}

	return nil
}

// CreatePodResMultiError is an error wrapping multiple validation errors
// returned by CreatePodRes.ValidateAll() if the designated constraints aren't met.
type CreatePodResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreatePodResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreatePodResMultiError) AllErrors() []error { return m }

// CreatePodResValidationError is the validation error returned by
// CreatePodRes.Validate if the designated constraints aren't met.
type CreatePodResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreatePodResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreatePodResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreatePodResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreatePodResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreatePodResValidationError) ErrorName() string { return "CreatePodResValidationError" }

// Error satisfies the builtin error interface
func (e CreatePodResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreatePodRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreatePodResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreatePodResValidationError{}

// Validate checks the field values on StartPodReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *StartPodReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StartPodReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in StartPodReqMultiError, or
// nil if none found.
func (m *StartPodReq) ValidateAll() error {
	return m.validate(true)
}

func (m *StartPodReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetId()) < 1 {
		err := StartPodReqValidationError{
			field:  "Id",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return StartPodReqMultiError(errors)
	}

	return nil
}

// StartPodReqMultiError is an error wrapping multiple validation errors
// returned by StartPodReq.ValidateAll() if the designated constraints aren't met.
type StartPodReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StartPodReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StartPodReqMultiError) AllErrors() []error { return m }

// StartPodReqValidationError is the validation error returned by
// StartPodReq.Validate if the designated constraints aren't met.
type StartPodReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StartPodReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StartPodReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StartPodReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StartPodReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StartPodReqValidationError) ErrorName() string { return "StartPodReqValidationError" }

// Error satisfies the builtin error interface
func (e StartPodReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStartPodReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StartPodReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StartPodReqValidationError{}

// Validate checks the field values on StartPodRes with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *StartPodRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StartPodRes with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in StartPodResMultiError, or
// nil if none found.
func (m *StartPodRes) ValidateAll() error {
	return m.validate(true)
}

func (m *StartPodRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPod()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StartPodResValidationError{
					field:  "Pod",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StartPodResValidationError{
					field:  "Pod",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPod()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StartPodResValidationError{
				field:  "Pod",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return StartPodResMultiError(errors)
	}

	return nil
}

// StartPodResMultiError is an error wrapping multiple validation errors
// returned by StartPodRes.ValidateAll() if the designated constraints aren't met.
type StartPodResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StartPodResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StartPodResMultiError) AllErrors() []error { return m }

// StartPodResValidationError is the validation error returned by
// StartPodRes.Validate if the designated constraints aren't met.
type StartPodResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StartPodResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StartPodResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StartPodResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StartPodResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StartPodResValidationError) ErrorName() string { return "StartPodResValidationError" }

// Error satisfies the builtin error interface
func (e StartPodResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStartPodRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StartPodResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StartPodResValidationError{}

// Validate checks the field values on StopPodReq with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *StopPodReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StopPodReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in StopPodReqMultiError, or
// nil if none found.
func (m *StopPodReq) ValidateAll() error {
	return m.validate(true)
}

func (m *StopPodReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetId()) < 1 {
		err := StopPodReqValidationError{
			field:  "Id",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Force

	if len(errors) > 0 {
		return StopPodReqMultiError(errors)
	}

	return nil
}

// StopPodReqMultiError is an error wrapping multiple validation errors
// returned by StopPodReq.ValidateAll() if the designated constraints aren't met.
type StopPodReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StopPodReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StopPodReqMultiError) AllErrors() []error { return m }

// StopPodReqValidationError is the validation error returned by
// StopPodReq.Validate if the designated constraints aren't met.
type StopPodReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StopPodReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StopPodReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StopPodReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StopPodReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StopPodReqValidationError) ErrorName() string { return "StopPodReqValidationError" }

// Error satisfies the builtin error interface
func (e StopPodReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStopPodReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StopPodReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StopPodReqValidationError{}

// Validate checks the field values on StopPodRes with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *StopPodRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StopPodRes with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in StopPodResMultiError, or
// nil if none found.
func (m *StopPodRes) ValidateAll() error {
	return m.validate(true)
}

func (m *StopPodRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return StopPodResMultiError(errors)
	}

	return nil
}

// StopPodResMultiError is an error wrapping multiple validation errors
// returned by StopPodRes.ValidateAll() if the designated constraints aren't met.
type StopPodResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StopPodResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StopPodResMultiError) AllErrors() []error { return m }

// StopPodResValidationError is the validation error returned by
// StopPodRes.Validate if the designated constraints aren't met.
type StopPodResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StopPodResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StopPodResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StopPodResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StopPodResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StopPodResValidationError) ErrorName() string { return "StopPodResValidationError" }

// Error satisfies the builtin error interface
func (e StopPodResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStopPodRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StopPodResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StopPodResValidationError{}

// Validate checks the field values on RestartPodReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RestartPodReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RestartPodReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RestartPodReqMultiError, or
// nil if none found.
func (m *RestartPodReq) ValidateAll() error {
	return m.validate(true)
}

func (m *RestartPodReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetId()) < 1 {
		err := RestartPodReqValidationError{
			field:  "Id",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return RestartPodReqMultiError(errors)
	}

	return nil
}

// RestartPodReqMultiError is an error wrapping multiple validation errors
// returned by RestartPodReq.ValidateAll() if the designated constraints
// aren't met.
type RestartPodReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RestartPodReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RestartPodReqMultiError) AllErrors() []error { return m }

// RestartPodReqValidationError is the validation error returned by
// RestartPodReq.Validate if the designated constraints aren't met.
type RestartPodReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RestartPodReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RestartPodReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RestartPodReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RestartPodReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RestartPodReqValidationError) ErrorName() string { return "RestartPodReqValidationError" }

// Error satisfies the builtin error interface
func (e RestartPodReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRestartPodReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RestartPodReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RestartPodReqValidationError{}

// Validate checks the field values on RestartPodRes with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RestartPodRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RestartPodRes with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RestartPodResMultiError, or
// nil if none found.
func (m *RestartPodRes) ValidateAll() error {
	return m.validate(true)
}

func (m *RestartPodRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPod()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RestartPodResValidationError{
					field:  "Pod",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RestartPodResValidationError{
					field:  "Pod",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPod()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RestartPodResValidationError{
				field:  "Pod",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RestartPodResMultiError(errors)
	}

	return nil
}

// RestartPodResMultiError is an error wrapping multiple validation errors
// returned by RestartPodRes.ValidateAll() if the designated constraints
// aren't met.
type RestartPodResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RestartPodResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RestartPodResMultiError) AllErrors() []error { return m }

// RestartPodResValidationError is the validation error returned by
// RestartPodRes.Validate if the designated constraints aren't met.
type RestartPodResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RestartPodResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RestartPodResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RestartPodResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RestartPodResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RestartPodResValidationError) ErrorName() string { return "RestartPodResValidationError" }

// Error satisfies the builtin error interface
func (e RestartPodResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRestartPodRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RestartPodResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RestartPodResValidationError{}

// Validate checks the field values on GetPodReq with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetPodReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetPodReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetPodReqMultiError, or nil
// if none found.
func (m *GetPodReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetPodReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetId()) < 1 {
		err := GetPodReqValidationError{
			field:  "Id",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetPodReqMultiError(errors)
	}

	return nil
}

// GetPodReqMultiError is an error wrapping multiple validation errors returned
// by GetPodReq.ValidateAll() if the designated constraints aren't met.
type GetPodReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetPodReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetPodReqMultiError) AllErrors() []error { return m }

// GetPodReqValidationError is the validation error returned by
// GetPodReq.Validate if the designated constraints aren't met.
type GetPodReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetPodReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetPodReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetPodReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetPodReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetPodReqValidationError) ErrorName() string { return "GetPodReqValidationError" }

// Error satisfies the builtin error interface
func (e GetPodReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetPodReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetPodReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetPodReqValidationError{}

// Validate checks the field values on GetPodRes with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetPodRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetPodRes with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetPodResMultiError, or nil
// if none found.
func (m *GetPodRes) ValidateAll() error {
	return m.validate(true)
}

func (m *GetPodRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPod()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetPodResValidationError{
					field:  "Pod",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetPodResValidationError{
					field:  "Pod",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPod()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetPodResValidationError{
				field:  "Pod",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetPodResMultiError(errors)
	}

	return nil
}

// GetPodResMultiError is an error wrapping multiple validation errors returned
// by GetPodRes.ValidateAll() if the designated constraints aren't met.
type GetPodResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetPodResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetPodResMultiError) AllErrors() []error { return m }

// GetPodResValidationError is the validation error returned by
// GetPodRes.Validate if the designated constraints aren't met.
type GetPodResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetPodResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetPodResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetPodResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetPodResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetPodResValidationError) ErrorName() string { return "GetPodResValidationError" }

// Error satisfies the builtin error interface
func (e GetPodResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetPodRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetPodResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetPodResValidationError{}

// Validate checks the field values on ListPodsReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ListPodsReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListPodsReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ListPodsReqMultiError, or
// nil if none found.
func (m *ListPodsReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListPodsReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetLimit() > 1000 {
		err := ListPodsReqValidationError{
			field:  "Limit",
			reason: "value must be less than or equal to 1000",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetOffset() > 1000 {
		err := ListPodsReqValidationError{
			field:  "Offset",
			reason: "value must be less than or equal to 1000",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Name

	// no validation rules for Id

	// no validation rules for Labels

	if len(errors) > 0 {
		return ListPodsReqMultiError(errors)
	}

	return nil
}

// ListPodsReqMultiError is an error wrapping multiple validation errors
// returned by ListPodsReq.ValidateAll() if the designated constraints aren't met.
type ListPodsReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListPodsReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListPodsReqMultiError) AllErrors() []error { return m }

// ListPodsReqValidationError is the validation error returned by
// ListPodsReq.Validate if the designated constraints aren't met.
type ListPodsReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListPodsReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListPodsReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListPodsReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListPodsReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListPodsReqValidationError) ErrorName() string { return "ListPodsReqValidationError" }

// Error satisfies the builtin error interface
func (e ListPodsReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListPodsReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListPodsReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListPodsReqValidationError{}

// Validate checks the field values on ListPodsRes with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ListPodsRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListPodsRes with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ListPodsResMultiError, or
// nil if none found.
func (m *ListPodsRes) ValidateAll() error {
	return m.validate(true)
}

func (m *ListPodsRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListPodsResValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListPodsResValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListPodsResValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Total

	if len(errors) > 0 {
		return ListPodsResMultiError(errors)
	}

	return nil
}

// ListPodsResMultiError is an error wrapping multiple validation errors
// returned by ListPodsRes.ValidateAll() if the designated constraints aren't met.
type ListPodsResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListPodsResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListPodsResMultiError) AllErrors() []error { return m }

// ListPodsResValidationError is the validation error returned by
// ListPodsRes.Validate if the designated constraints aren't met.
type ListPodsResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListPodsResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListPodsResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListPodsResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListPodsResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListPodsResValidationError) ErrorName() string { return "ListPodsResValidationError" }

// Error satisfies the builtin error interface
func (e ListPodsResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListPodsRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListPodsResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListPodsResValidationError{}

// Validate checks the field values on ListPodItem with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ListPodItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListPodItem with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ListPodItemMultiError, or
// nil if none found.
func (m *ListPodItem) ValidateAll() error {
	return m.validate(true)
}

func (m *ListPodItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for Phase

	// no validation rules for CreateTime

	if len(errors) > 0 {
		return ListPodItemMultiError(errors)
	}

	return nil
}

// ListPodItemMultiError is an error wrapping multiple validation errors
// returned by ListPodItem.ValidateAll() if the designated constraints aren't met.
type ListPodItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListPodItemMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListPodItemMultiError) AllErrors() []error { return m }

// ListPodItemValidationError is the validation error returned by
// ListPodItem.Validate if the designated constraints aren't met.
type ListPodItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListPodItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListPodItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListPodItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListPodItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListPodItemValidationError) ErrorName() string { return "ListPodItemValidationError" }

// Error satisfies the builtin error interface
func (e ListPodItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListPodItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListPodItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListPodItemValidationError{}

// Validate checks the field values on DeletePodReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DeletePodReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeletePodReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DeletePodReqMultiError, or
// nil if none found.
func (m *DeletePodReq) ValidateAll() error {
	return m.validate(true)
}

func (m *DeletePodReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetId()) < 1 {
		err := DeletePodReqValidationError{
			field:  "Id",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Force

	// no validation rules for RemoveVolumes

	if len(errors) > 0 {
		return DeletePodReqMultiError(errors)
	}

	return nil
}

// DeletePodReqMultiError is an error wrapping multiple validation errors
// returned by DeletePodReq.ValidateAll() if the designated constraints aren't met.
type DeletePodReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeletePodReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeletePodReqMultiError) AllErrors() []error { return m }

// DeletePodReqValidationError is the validation error returned by
// DeletePodReq.Validate if the designated constraints aren't met.
type DeletePodReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeletePodReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeletePodReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeletePodReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeletePodReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeletePodReqValidationError) ErrorName() string { return "DeletePodReqValidationError" }

// Error satisfies the builtin error interface
func (e DeletePodReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeletePodReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeletePodReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeletePodReqValidationError{}

// Validate checks the field values on DeletePodRes with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DeletePodRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeletePodRes with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DeletePodResMultiError, or
// nil if none found.
func (m *DeletePodRes) ValidateAll() error {
	return m.validate(true)
}

func (m *DeletePodRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DeletePodResMultiError(errors)
	}

	return nil
}

// DeletePodResMultiError is an error wrapping multiple validation errors
// returned by DeletePodRes.ValidateAll() if the designated constraints aren't met.
type DeletePodResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeletePodResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeletePodResMultiError) AllErrors() []error { return m }

// DeletePodResValidationError is the validation error returned by
// DeletePodRes.Validate if the designated constraints aren't met.
type DeletePodResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeletePodResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeletePodResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeletePodResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeletePodResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeletePodResValidationError) ErrorName() string { return "DeletePodResValidationError" }

// Error satisfies the builtin error interface
func (e DeletePodResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeletePodRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeletePodResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeletePodResValidationError{}
