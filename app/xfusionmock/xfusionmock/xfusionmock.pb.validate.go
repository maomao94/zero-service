// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: xfusionmock.proto

package xfusionmock

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on Req with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Req) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Req with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ReqMultiError, or nil if none found.
func (m *Req) ValidateAll() error {
	return m.validate(true)
}

func (m *Req) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetPing()) < 1 {
		err := ReqValidationError{
			field:  "Ping",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ReqMultiError(errors)
	}

	return nil
}

// ReqMultiError is an error wrapping multiple validation errors returned by
// Req.ValidateAll() if the designated constraints aren't met.
type ReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReqMultiError) AllErrors() []error { return m }

// ReqValidationError is the validation error returned by Req.Validate if the
// designated constraints aren't met.
type ReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReqValidationError) ErrorName() string { return "ReqValidationError" }

// Error satisfies the builtin error interface
func (e ReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReqValidationError{}

// Validate checks the field values on Res with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Res) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Res with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ResMultiError, or nil if none found.
func (m *Res) ValidateAll() error {
	return m.validate(true)
}

func (m *Res) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Pong

	if len(errors) > 0 {
		return ResMultiError(errors)
	}

	return nil
}

// ResMultiError is an error wrapping multiple validation errors returned by
// Res.ValidateAll() if the designated constraints aren't met.
type ResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResMultiError) AllErrors() []error { return m }

// ResValidationError is the validation error returned by Res.Validate if the
// designated constraints aren't met.
type ResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResValidationError) ErrorName() string { return "ResValidationError" }

// Error satisfies the builtin error interface
func (e ResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResValidationError{}

// Validate checks the field values on ReqPushTest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ReqPushTest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReqPushTest with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ReqPushTestMultiError, or
// nil if none found.
func (m *ReqPushTest) ValidateAll() error {
	return m.validate(true)
}

func (m *ReqPushTest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Body

	if len(errors) > 0 {
		return ReqPushTestMultiError(errors)
	}

	return nil
}

// ReqPushTestMultiError is an error wrapping multiple validation errors
// returned by ReqPushTest.ValidateAll() if the designated constraints aren't met.
type ReqPushTestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReqPushTestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReqPushTestMultiError) AllErrors() []error { return m }

// ReqPushTestValidationError is the validation error returned by
// ReqPushTest.Validate if the designated constraints aren't met.
type ReqPushTestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReqPushTestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReqPushTestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReqPushTestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReqPushTestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReqPushTestValidationError) ErrorName() string { return "ReqPushTestValidationError" }

// Error satisfies the builtin error interface
func (e ReqPushTestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReqPushTest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReqPushTestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReqPushTestValidationError{}

// Validate checks the field values on ResPushTest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ResPushTest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ResPushTest with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ResPushTestMultiError, or
// nil if none found.
func (m *ResPushTest) ValidateAll() error {
	return m.validate(true)
}

func (m *ResPushTest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ResPushTestMultiError(errors)
	}

	return nil
}

// ResPushTestMultiError is an error wrapping multiple validation errors
// returned by ResPushTest.ValidateAll() if the designated constraints aren't met.
type ResPushTestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResPushTestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResPushTestMultiError) AllErrors() []error { return m }

// ResPushTestValidationError is the validation error returned by
// ResPushTest.Validate if the designated constraints aren't met.
type ResPushTestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResPushTestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResPushTestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResPushTestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResPushTestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResPushTestValidationError) ErrorName() string { return "ResPushTestValidationError" }

// Error satisfies the builtin error interface
func (e ResPushTestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResPushTest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResPushTestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResPushTestValidationError{}

// Validate checks the field values on ReqPushPoint with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ReqPushPoint) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReqPushPoint with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ReqPushPointMultiError, or
// nil if none found.
func (m *ReqPushPoint) ValidateAll() error {
	return m.validate(true)
}

func (m *ReqPushPoint) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PushMode

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReqPushPointValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReqPushPointValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReqPushPointValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ReqPushPointMultiError(errors)
	}

	return nil
}

// ReqPushPointMultiError is an error wrapping multiple validation errors
// returned by ReqPushPoint.ValidateAll() if the designated constraints aren't met.
type ReqPushPointMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReqPushPointMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReqPushPointMultiError) AllErrors() []error { return m }

// ReqPushPointValidationError is the validation error returned by
// ReqPushPoint.Validate if the designated constraints aren't met.
type ReqPushPointValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReqPushPointValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReqPushPointValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReqPushPointValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReqPushPointValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReqPushPointValidationError) ErrorName() string { return "ReqPushPointValidationError" }

// Error satisfies the builtin error interface
func (e ReqPushPointValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReqPushPoint.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReqPushPointValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReqPushPointValidationError{}

// Validate checks the field values on ResPushPoint with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ResPushPoint) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ResPushPoint with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ResPushPointMultiError, or
// nil if none found.
func (m *ResPushPoint) ValidateAll() error {
	return m.validate(true)
}

func (m *ResPushPoint) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ResPushPointMultiError(errors)
	}

	return nil
}

// ResPushPointMultiError is an error wrapping multiple validation errors
// returned by ResPushPoint.ValidateAll() if the designated constraints aren't met.
type ResPushPointMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResPushPointMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResPushPointMultiError) AllErrors() []error { return m }

// ResPushPointValidationError is the validation error returned by
// ResPushPoint.Validate if the designated constraints aren't met.
type ResPushPointValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResPushPointValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResPushPointValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResPushPointValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResPushPointValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResPushPointValidationError) ErrorName() string { return "ResPushPointValidationError" }

// Error satisfies the builtin error interface
func (e ResPushPointValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResPushPoint.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResPushPointValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResPushPointValidationError{}

// Validate checks the field values on ReqPushAlarm with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ReqPushAlarm) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReqPushAlarm with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ReqPushAlarmMultiError, or
// nil if none found.
func (m *ReqPushAlarm) ValidateAll() error {
	return m.validate(true)
}

func (m *ReqPushAlarm) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PushMode

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReqPushAlarmValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReqPushAlarmValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReqPushAlarmValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ReqPushAlarmMultiError(errors)
	}

	return nil
}

// ReqPushAlarmMultiError is an error wrapping multiple validation errors
// returned by ReqPushAlarm.ValidateAll() if the designated constraints aren't met.
type ReqPushAlarmMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReqPushAlarmMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReqPushAlarmMultiError) AllErrors() []error { return m }

// ReqPushAlarmValidationError is the validation error returned by
// ReqPushAlarm.Validate if the designated constraints aren't met.
type ReqPushAlarmValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReqPushAlarmValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReqPushAlarmValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReqPushAlarmValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReqPushAlarmValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReqPushAlarmValidationError) ErrorName() string { return "ReqPushAlarmValidationError" }

// Error satisfies the builtin error interface
func (e ReqPushAlarmValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReqPushAlarm.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReqPushAlarmValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReqPushAlarmValidationError{}

// Validate checks the field values on ResPushAlarm with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ResPushAlarm) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ResPushAlarm with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ResPushAlarmMultiError, or
// nil if none found.
func (m *ResPushAlarm) ValidateAll() error {
	return m.validate(true)
}

func (m *ResPushAlarm) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ResPushAlarmMultiError(errors)
	}

	return nil
}

// ResPushAlarmMultiError is an error wrapping multiple validation errors
// returned by ResPushAlarm.ValidateAll() if the designated constraints aren't met.
type ResPushAlarmMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResPushAlarmMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResPushAlarmMultiError) AllErrors() []error { return m }

// ResPushAlarmValidationError is the validation error returned by
// ResPushAlarm.Validate if the designated constraints aren't met.
type ResPushAlarmValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResPushAlarmValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResPushAlarmValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResPushAlarmValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResPushAlarmValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResPushAlarmValidationError) ErrorName() string { return "ResPushAlarmValidationError" }

// Error satisfies the builtin error interface
func (e ResPushAlarmValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResPushAlarm.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResPushAlarmValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResPushAlarmValidationError{}

// Validate checks the field values on ReqPushEvent with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ReqPushEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReqPushEvent with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ReqPushEventMultiError, or
// nil if none found.
func (m *ReqPushEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *ReqPushEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PushMode

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReqPushEventValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReqPushEventValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReqPushEventValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ReqPushEventMultiError(errors)
	}

	return nil
}

// ReqPushEventMultiError is an error wrapping multiple validation errors
// returned by ReqPushEvent.ValidateAll() if the designated constraints aren't met.
type ReqPushEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReqPushEventMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReqPushEventMultiError) AllErrors() []error { return m }

// ReqPushEventValidationError is the validation error returned by
// ReqPushEvent.Validate if the designated constraints aren't met.
type ReqPushEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReqPushEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReqPushEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReqPushEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReqPushEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReqPushEventValidationError) ErrorName() string { return "ReqPushEventValidationError" }

// Error satisfies the builtin error interface
func (e ReqPushEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReqPushEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReqPushEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReqPushEventValidationError{}

// Validate checks the field values on ResPushEvent with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ResPushEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ResPushEvent with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ResPushEventMultiError, or
// nil if none found.
func (m *ResPushEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *ResPushEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ResPushEventMultiError(errors)
	}

	return nil
}

// ResPushEventMultiError is an error wrapping multiple validation errors
// returned by ResPushEvent.ValidateAll() if the designated constraints aren't met.
type ResPushEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResPushEventMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResPushEventMultiError) AllErrors() []error { return m }

// ResPushEventValidationError is the validation error returned by
// ResPushEvent.Validate if the designated constraints aren't met.
type ResPushEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResPushEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResPushEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResPushEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResPushEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResPushEventValidationError) ErrorName() string { return "ResPushEventValidationError" }

// Error satisfies the builtin error interface
func (e ResPushEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResPushEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResPushEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResPushEventValidationError{}

// Validate checks the field values on ReqPushTerminalBind with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReqPushTerminalBind) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReqPushTerminalBind with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReqPushTerminalBindMultiError, or nil if none found.
func (m *ReqPushTerminalBind) ValidateAll() error {
	return m.validate(true)
}

func (m *ReqPushTerminalBind) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PushMode

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReqPushTerminalBindValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReqPushTerminalBindValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReqPushTerminalBindValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ReqPushTerminalBindMultiError(errors)
	}

	return nil
}

// ReqPushTerminalBindMultiError is an error wrapping multiple validation
// errors returned by ReqPushTerminalBind.ValidateAll() if the designated
// constraints aren't met.
type ReqPushTerminalBindMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReqPushTerminalBindMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReqPushTerminalBindMultiError) AllErrors() []error { return m }

// ReqPushTerminalBindValidationError is the validation error returned by
// ReqPushTerminalBind.Validate if the designated constraints aren't met.
type ReqPushTerminalBindValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReqPushTerminalBindValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReqPushTerminalBindValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReqPushTerminalBindValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReqPushTerminalBindValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReqPushTerminalBindValidationError) ErrorName() string {
	return "ReqPushTerminalBindValidationError"
}

// Error satisfies the builtin error interface
func (e ReqPushTerminalBindValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReqPushTerminalBind.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReqPushTerminalBindValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReqPushTerminalBindValidationError{}

// Validate checks the field values on ResPushTerminalBind with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ResPushTerminalBind) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ResPushTerminalBind with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ResPushTerminalBindMultiError, or nil if none found.
func (m *ResPushTerminalBind) ValidateAll() error {
	return m.validate(true)
}

func (m *ResPushTerminalBind) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ResPushTerminalBindMultiError(errors)
	}

	return nil
}

// ResPushTerminalBindMultiError is an error wrapping multiple validation
// errors returned by ResPushTerminalBind.ValidateAll() if the designated
// constraints aren't met.
type ResPushTerminalBindMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResPushTerminalBindMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResPushTerminalBindMultiError) AllErrors() []error { return m }

// ResPushTerminalBindValidationError is the validation error returned by
// ResPushTerminalBind.Validate if the designated constraints aren't met.
type ResPushTerminalBindValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResPushTerminalBindValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResPushTerminalBindValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResPushTerminalBindValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResPushTerminalBindValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResPushTerminalBindValidationError) ErrorName() string {
	return "ResPushTerminalBindValidationError"
}

// Error satisfies the builtin error interface
func (e ResPushTerminalBindValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResPushTerminalBind.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResPushTerminalBindValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResPushTerminalBindValidationError{}

// Validate checks the field values on TerminalBind with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TerminalBind) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TerminalBind with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TerminalBindMultiError, or
// nil if none found.
func (m *TerminalBind) ValidateAll() error {
	return m.validate(true)
}

func (m *TerminalBind) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DataTagV1

	// no validation rules for Action

	// no validation rules for TerminalId

	// no validation rules for TerminalNo

	// no validation rules for StaffIdCardNo

	// no validation rules for TrackId

	// no validation rules for TrackNo

	// no validation rules for TrackType

	// no validation rules for TrackName

	// no validation rules for ActionTime

	if len(errors) > 0 {
		return TerminalBindMultiError(errors)
	}

	return nil
}

// TerminalBindMultiError is an error wrapping multiple validation errors
// returned by TerminalBind.ValidateAll() if the designated constraints aren't met.
type TerminalBindMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TerminalBindMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TerminalBindMultiError) AllErrors() []error { return m }

// TerminalBindValidationError is the validation error returned by
// TerminalBind.Validate if the designated constraints aren't met.
type TerminalBindValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TerminalBindValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TerminalBindValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TerminalBindValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TerminalBindValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TerminalBindValidationError) ErrorName() string { return "TerminalBindValidationError" }

// Error satisfies the builtin error interface
func (e TerminalBindValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTerminalBind.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TerminalBindValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TerminalBindValidationError{}

// Validate checks the field values on EventData with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *EventData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EventData with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in EventDataMultiError, or nil
// if none found.
func (m *EventData) ValidateAll() error {
	return m.validate(true)
}

func (m *EventData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DataTagV1

	// no validation rules for Id

	// no validation rules for EventTitle

	// no validation rules for EventCode

	// no validation rules for ServerTime

	// no validation rules for EpochTime

	if all {
		switch v := interface{}(m.GetTerminalInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EventDataValidationError{
					field:  "TerminalInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EventDataValidationError{
					field:  "TerminalInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTerminalInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EventDataValidationError{
				field:  "TerminalInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPosition()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EventDataValidationError{
					field:  "Position",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EventDataValidationError{
					field:  "Position",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPosition()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EventDataValidationError{
				field:  "Position",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return EventDataMultiError(errors)
	}

	return nil
}

// EventDataMultiError is an error wrapping multiple validation errors returned
// by EventData.ValidateAll() if the designated constraints aren't met.
type EventDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EventDataMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EventDataMultiError) AllErrors() []error { return m }

// EventDataValidationError is the validation error returned by
// EventData.Validate if the designated constraints aren't met.
type EventDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EventDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EventDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EventDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EventDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EventDataValidationError) ErrorName() string { return "EventDataValidationError" }

// Error satisfies the builtin error interface
func (e EventDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEventData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EventDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EventDataValidationError{}

// Validate checks the field values on TerminalData with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TerminalData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TerminalData with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TerminalDataMultiError, or
// nil if none found.
func (m *TerminalData) ValidateAll() error {
	return m.validate(true)
}

func (m *TerminalData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DataTagV1

	if all {
		switch v := interface{}(m.GetTerminalInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TerminalDataValidationError{
					field:  "TerminalInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TerminalDataValidationError{
					field:  "TerminalInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTerminalInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TerminalDataValidationError{
				field:  "TerminalInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for EpochTime

	if all {
		switch v := interface{}(m.GetLocation()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TerminalDataValidationError{
					field:  "Location",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TerminalDataValidationError{
					field:  "Location",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLocation()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TerminalDataValidationError{
				field:  "Location",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetBuildingInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TerminalDataValidationError{
					field:  "BuildingInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TerminalDataValidationError{
					field:  "BuildingInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBuildingInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TerminalDataValidationError{
				field:  "BuildingInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetStatus()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TerminalDataValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TerminalDataValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStatus()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TerminalDataValidationError{
				field:  "Status",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TerminalDataMultiError(errors)
	}

	return nil
}

// TerminalDataMultiError is an error wrapping multiple validation errors
// returned by TerminalData.ValidateAll() if the designated constraints aren't met.
type TerminalDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TerminalDataMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TerminalDataMultiError) AllErrors() []error { return m }

// TerminalDataValidationError is the validation error returned by
// TerminalData.Validate if the designated constraints aren't met.
type TerminalDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TerminalDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TerminalDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TerminalDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TerminalDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TerminalDataValidationError) ErrorName() string { return "TerminalDataValidationError" }

// Error satisfies the builtin error interface
func (e TerminalDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTerminalData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TerminalDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TerminalDataValidationError{}

// Validate checks the field values on AlarmData with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AlarmData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AlarmData with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AlarmDataMultiError, or nil
// if none found.
func (m *AlarmData) ValidateAll() error {
	return m.validate(true)
}

func (m *AlarmData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DataTagV1

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for AlarmNo

	// no validation rules for AlarmCode

	// no validation rules for Level

	for idx, item := range m.GetTrackInfoList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AlarmDataValidationError{
						field:  fmt.Sprintf("TrackInfoList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AlarmDataValidationError{
						field:  fmt.Sprintf("TrackInfoList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AlarmDataValidationError{
					field:  fmt.Sprintf("TrackInfoList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for TrackType

	if all {
		switch v := interface{}(m.GetPosition()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AlarmDataValidationError{
					field:  "Position",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AlarmDataValidationError{
					field:  "Position",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPosition()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AlarmDataValidationError{
				field:  "Position",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetStartFences() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AlarmDataValidationError{
						field:  fmt.Sprintf("StartFences[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AlarmDataValidationError{
						field:  fmt.Sprintf("StartFences[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AlarmDataValidationError{
					field:  fmt.Sprintf("StartFences[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetEndFences() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AlarmDataValidationError{
						field:  fmt.Sprintf("EndFences[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AlarmDataValidationError{
						field:  fmt.Sprintf("EndFences[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AlarmDataValidationError{
					field:  fmt.Sprintf("EndFences[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for StartTime

	// no validation rules for EndTime

	// no validation rules for Duration

	// no validation rules for AlarmStatus

	if len(errors) > 0 {
		return AlarmDataMultiError(errors)
	}

	return nil
}

// AlarmDataMultiError is an error wrapping multiple validation errors returned
// by AlarmData.ValidateAll() if the designated constraints aren't met.
type AlarmDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AlarmDataMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AlarmDataMultiError) AllErrors() []error { return m }

// AlarmDataValidationError is the validation error returned by
// AlarmData.Validate if the designated constraints aren't met.
type AlarmDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AlarmDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AlarmDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AlarmDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AlarmDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AlarmDataValidationError) ErrorName() string { return "AlarmDataValidationError" }

// Error satisfies the builtin error interface
func (e AlarmDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAlarmData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AlarmDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AlarmDataValidationError{}

// Validate checks the field values on FenceInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FenceInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FenceInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FenceInfoMultiError, or nil
// if none found.
func (m *FenceInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *FenceInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for FenceCode

	// no validation rules for OrgCode

	if len(errors) > 0 {
		return FenceInfoMultiError(errors)
	}

	return nil
}

// FenceInfoMultiError is an error wrapping multiple validation errors returned
// by FenceInfo.ValidateAll() if the designated constraints aren't met.
type FenceInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FenceInfoMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FenceInfoMultiError) AllErrors() []error { return m }

// FenceInfoValidationError is the validation error returned by
// FenceInfo.Validate if the designated constraints aren't met.
type FenceInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FenceInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FenceInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FenceInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FenceInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FenceInfoValidationError) ErrorName() string { return "FenceInfoValidationError" }

// Error satisfies the builtin error interface
func (e FenceInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFenceInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FenceInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FenceInfoValidationError{}

// Validate checks the field values on LocationPosition with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *LocationPosition) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LocationPosition with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LocationPositionMultiError, or nil if none found.
func (m *LocationPosition) ValidateAll() error {
	return m.validate(true)
}

func (m *LocationPosition) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Lat

	// no validation rules for Lon

	// no validation rules for Alt

	if len(errors) > 0 {
		return LocationPositionMultiError(errors)
	}

	return nil
}

// LocationPositionMultiError is an error wrapping multiple validation errors
// returned by LocationPosition.ValidateAll() if the designated constraints
// aren't met.
type LocationPositionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LocationPositionMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LocationPositionMultiError) AllErrors() []error { return m }

// LocationPositionValidationError is the validation error returned by
// LocationPosition.Validate if the designated constraints aren't met.
type LocationPositionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LocationPositionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LocationPositionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LocationPositionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LocationPositionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LocationPositionValidationError) ErrorName() string { return "LocationPositionValidationError" }

// Error satisfies the builtin error interface
func (e LocationPositionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLocationPosition.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LocationPositionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LocationPositionValidationError{}

// Validate checks the field values on TerminalInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TerminalInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TerminalInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TerminalInfoMultiError, or
// nil if none found.
func (m *TerminalInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *TerminalInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TerminalId

	// no validation rules for TerminalNo

	// no validation rules for TrackId

	// no validation rules for TrackNo

	// no validation rules for TrackType

	// no validation rules for TrackName

	// no validation rules for OrgCode

	// no validation rules for OrgName

	if len(errors) > 0 {
		return TerminalInfoMultiError(errors)
	}

	return nil
}

// TerminalInfoMultiError is an error wrapping multiple validation errors
// returned by TerminalInfo.ValidateAll() if the designated constraints aren't met.
type TerminalInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TerminalInfoMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TerminalInfoMultiError) AllErrors() []error { return m }

// TerminalInfoValidationError is the validation error returned by
// TerminalInfo.Validate if the designated constraints aren't met.
type TerminalInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TerminalInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TerminalInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TerminalInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TerminalInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TerminalInfoValidationError) ErrorName() string { return "TerminalInfoValidationError" }

// Error satisfies the builtin error interface
func (e TerminalInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTerminalInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TerminalInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TerminalInfoValidationError{}

// Validate checks the field values on Location with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Location) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Location with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LocationMultiError, or nil
// if none found.
func (m *Location) ValidateAll() error {
	return m.validate(true)
}

func (m *Location) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPosition()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LocationValidationError{
					field:  "Position",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LocationValidationError{
					field:  "Position",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPosition()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LocationValidationError{
				field:  "Position",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Speed

	// no validation rules for Direction

	// no validation rules for LocationMode

	// no validation rules for SatelliteNum

	// no validation rules for GgaStatus

	if len(errors) > 0 {
		return LocationMultiError(errors)
	}

	return nil
}

// LocationMultiError is an error wrapping multiple validation errors returned
// by Location.ValidateAll() if the designated constraints aren't met.
type LocationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LocationMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LocationMultiError) AllErrors() []error { return m }

// LocationValidationError is the validation error returned by
// Location.Validate if the designated constraints aren't met.
type LocationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LocationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LocationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LocationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LocationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LocationValidationError) ErrorName() string { return "LocationValidationError" }

// Error satisfies the builtin error interface
func (e LocationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLocation.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LocationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LocationValidationError{}

// Validate checks the field values on Position with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Position) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Position with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PositionMultiError, or nil
// if none found.
func (m *Position) ValidateAll() error {
	return m.validate(true)
}

func (m *Position) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Lat

	// no validation rules for Lon

	// no validation rules for Alt

	if len(errors) > 0 {
		return PositionMultiError(errors)
	}

	return nil
}

// PositionMultiError is an error wrapping multiple validation errors returned
// by Position.ValidateAll() if the designated constraints aren't met.
type PositionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PositionMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PositionMultiError) AllErrors() []error { return m }

// PositionValidationError is the validation error returned by
// Position.Validate if the designated constraints aren't met.
type PositionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PositionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PositionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PositionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PositionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PositionValidationError) ErrorName() string { return "PositionValidationError" }

// Error satisfies the builtin error interface
func (e PositionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPosition.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PositionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PositionValidationError{}

// Validate checks the field values on BuildingInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BuildingInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BuildingInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BuildingInfoMultiError, or
// nil if none found.
func (m *BuildingInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *BuildingInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for BuildingId

	// no validation rules for FloorNo

	if len(errors) > 0 {
		return BuildingInfoMultiError(errors)
	}

	return nil
}

// BuildingInfoMultiError is an error wrapping multiple validation errors
// returned by BuildingInfo.ValidateAll() if the designated constraints aren't met.
type BuildingInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BuildingInfoMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BuildingInfoMultiError) AllErrors() []error { return m }

// BuildingInfoValidationError is the validation error returned by
// BuildingInfo.Validate if the designated constraints aren't met.
type BuildingInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BuildingInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BuildingInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BuildingInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BuildingInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BuildingInfoValidationError) ErrorName() string { return "BuildingInfoValidationError" }

// Error satisfies the builtin error interface
func (e BuildingInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBuildingInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BuildingInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BuildingInfoValidationError{}

// Validate checks the field values on Status with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Status) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Status with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in StatusMultiError, or nil if none found.
func (m *Status) ValidateAll() error {
	return m.validate(true)
}

func (m *Status) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Acc

	// no validation rules for Emergency

	// no validation rules for MainSourceDown

	// no validation rules for Signal

	// no validation rules for Battery

	// no validation rules for MoveState

	if len(errors) > 0 {
		return StatusMultiError(errors)
	}

	return nil
}

// StatusMultiError is an error wrapping multiple validation errors returned by
// Status.ValidateAll() if the designated constraints aren't met.
type StatusMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StatusMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StatusMultiError) AllErrors() []error { return m }

// StatusValidationError is the validation error returned by Status.Validate if
// the designated constraints aren't met.
type StatusValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StatusValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StatusValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StatusValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StatusValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StatusValidationError) ErrorName() string { return "StatusValidationError" }

// Error satisfies the builtin error interface
func (e StatusValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStatus.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StatusValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StatusValidationError{}
