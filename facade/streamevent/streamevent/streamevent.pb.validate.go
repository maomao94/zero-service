// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: streamevent.proto

package streamevent

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on ReceiveMQTTMessageReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReceiveMQTTMessageReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReceiveMQTTMessageReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReceiveMQTTMessageReqMultiError, or nil if none found.
func (m *ReceiveMQTTMessageReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ReceiveMQTTMessageReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetMessages() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ReceiveMQTTMessageReqValidationError{
						field:  fmt.Sprintf("Messages[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ReceiveMQTTMessageReqValidationError{
						field:  fmt.Sprintf("Messages[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ReceiveMQTTMessageReqValidationError{
					field:  fmt.Sprintf("Messages[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ReceiveMQTTMessageReqMultiError(errors)
	}

	return nil
}

// ReceiveMQTTMessageReqMultiError is an error wrapping multiple validation
// errors returned by ReceiveMQTTMessageReq.ValidateAll() if the designated
// constraints aren't met.
type ReceiveMQTTMessageReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReceiveMQTTMessageReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReceiveMQTTMessageReqMultiError) AllErrors() []error { return m }

// ReceiveMQTTMessageReqValidationError is the validation error returned by
// ReceiveMQTTMessageReq.Validate if the designated constraints aren't met.
type ReceiveMQTTMessageReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReceiveMQTTMessageReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReceiveMQTTMessageReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReceiveMQTTMessageReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReceiveMQTTMessageReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReceiveMQTTMessageReqValidationError) ErrorName() string {
	return "ReceiveMQTTMessageReqValidationError"
}

// Error satisfies the builtin error interface
func (e ReceiveMQTTMessageReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReceiveMQTTMessageReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReceiveMQTTMessageReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReceiveMQTTMessageReqValidationError{}

// Validate checks the field values on ReceiveMQTTMessageRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReceiveMQTTMessageRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReceiveMQTTMessageRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReceiveMQTTMessageResMultiError, or nil if none found.
func (m *ReceiveMQTTMessageRes) ValidateAll() error {
	return m.validate(true)
}

func (m *ReceiveMQTTMessageRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ReceiveMQTTMessageResMultiError(errors)
	}

	return nil
}

// ReceiveMQTTMessageResMultiError is an error wrapping multiple validation
// errors returned by ReceiveMQTTMessageRes.ValidateAll() if the designated
// constraints aren't met.
type ReceiveMQTTMessageResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReceiveMQTTMessageResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReceiveMQTTMessageResMultiError) AllErrors() []error { return m }

// ReceiveMQTTMessageResValidationError is the validation error returned by
// ReceiveMQTTMessageRes.Validate if the designated constraints aren't met.
type ReceiveMQTTMessageResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReceiveMQTTMessageResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReceiveMQTTMessageResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReceiveMQTTMessageResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReceiveMQTTMessageResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReceiveMQTTMessageResValidationError) ErrorName() string {
	return "ReceiveMQTTMessageResValidationError"
}

// Error satisfies the builtin error interface
func (e ReceiveMQTTMessageResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReceiveMQTTMessageRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReceiveMQTTMessageResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReceiveMQTTMessageResValidationError{}

// Validate checks the field values on MqttMessage with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MqttMessage) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MqttMessage with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MqttMessageMultiError, or
// nil if none found.
func (m *MqttMessage) ValidateAll() error {
	return m.validate(true)
}

func (m *MqttMessage) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SessionId

	// no validation rules for MsgId

	// no validation rules for Topic

	// no validation rules for Payload

	// no validation rules for SendTime

	if len(errors) > 0 {
		return MqttMessageMultiError(errors)
	}

	return nil
}

// MqttMessageMultiError is an error wrapping multiple validation errors
// returned by MqttMessage.ValidateAll() if the designated constraints aren't met.
type MqttMessageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MqttMessageMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MqttMessageMultiError) AllErrors() []error { return m }

// MqttMessageValidationError is the validation error returned by
// MqttMessage.Validate if the designated constraints aren't met.
type MqttMessageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MqttMessageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MqttMessageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MqttMessageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MqttMessageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MqttMessageValidationError) ErrorName() string { return "MqttMessageValidationError" }

// Error satisfies the builtin error interface
func (e MqttMessageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMqttMessage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MqttMessageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MqttMessageValidationError{}

// Validate checks the field values on ReceiveWSMessageReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReceiveWSMessageReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReceiveWSMessageReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReceiveWSMessageReqMultiError, or nil if none found.
func (m *ReceiveWSMessageReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ReceiveWSMessageReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SessionId

	// no validation rules for MsgId

	// no validation rules for Payload

	// no validation rules for SendTime

	if len(errors) > 0 {
		return ReceiveWSMessageReqMultiError(errors)
	}

	return nil
}

// ReceiveWSMessageReqMultiError is an error wrapping multiple validation
// errors returned by ReceiveWSMessageReq.ValidateAll() if the designated
// constraints aren't met.
type ReceiveWSMessageReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReceiveWSMessageReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReceiveWSMessageReqMultiError) AllErrors() []error { return m }

// ReceiveWSMessageReqValidationError is the validation error returned by
// ReceiveWSMessageReq.Validate if the designated constraints aren't met.
type ReceiveWSMessageReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReceiveWSMessageReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReceiveWSMessageReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReceiveWSMessageReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReceiveWSMessageReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReceiveWSMessageReqValidationError) ErrorName() string {
	return "ReceiveWSMessageReqValidationError"
}

// Error satisfies the builtin error interface
func (e ReceiveWSMessageReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReceiveWSMessageReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReceiveWSMessageReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReceiveWSMessageReqValidationError{}

// Validate checks the field values on ReceiveWSMessageRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReceiveWSMessageRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReceiveWSMessageRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReceiveWSMessageResMultiError, or nil if none found.
func (m *ReceiveWSMessageRes) ValidateAll() error {
	return m.validate(true)
}

func (m *ReceiveWSMessageRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ReceiveWSMessageResMultiError(errors)
	}

	return nil
}

// ReceiveWSMessageResMultiError is an error wrapping multiple validation
// errors returned by ReceiveWSMessageRes.ValidateAll() if the designated
// constraints aren't met.
type ReceiveWSMessageResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReceiveWSMessageResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReceiveWSMessageResMultiError) AllErrors() []error { return m }

// ReceiveWSMessageResValidationError is the validation error returned by
// ReceiveWSMessageRes.Validate if the designated constraints aren't met.
type ReceiveWSMessageResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReceiveWSMessageResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReceiveWSMessageResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReceiveWSMessageResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReceiveWSMessageResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReceiveWSMessageResValidationError) ErrorName() string {
	return "ReceiveWSMessageResValidationError"
}

// Error satisfies the builtin error interface
func (e ReceiveWSMessageResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReceiveWSMessageRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReceiveWSMessageResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReceiveWSMessageResValidationError{}

// Validate checks the field values on PushChunkAsduReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *PushChunkAsduReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PushChunkAsduReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PushChunkAsduReqMultiError, or nil if none found.
func (m *PushChunkAsduReq) ValidateAll() error {
	return m.validate(true)
}

func (m *PushChunkAsduReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetMsgBody() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PushChunkAsduReqValidationError{
						field:  fmt.Sprintf("MsgBody[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PushChunkAsduReqValidationError{
						field:  fmt.Sprintf("MsgBody[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PushChunkAsduReqValidationError{
					field:  fmt.Sprintf("MsgBody[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return PushChunkAsduReqMultiError(errors)
	}

	return nil
}

// PushChunkAsduReqMultiError is an error wrapping multiple validation errors
// returned by PushChunkAsduReq.ValidateAll() if the designated constraints
// aren't met.
type PushChunkAsduReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PushChunkAsduReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PushChunkAsduReqMultiError) AllErrors() []error { return m }

// PushChunkAsduReqValidationError is the validation error returned by
// PushChunkAsduReq.Validate if the designated constraints aren't met.
type PushChunkAsduReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PushChunkAsduReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PushChunkAsduReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PushChunkAsduReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PushChunkAsduReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PushChunkAsduReqValidationError) ErrorName() string { return "PushChunkAsduReqValidationError" }

// Error satisfies the builtin error interface
func (e PushChunkAsduReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPushChunkAsduReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PushChunkAsduReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PushChunkAsduReqValidationError{}

// Validate checks the field values on PushChunkAsduRes with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *PushChunkAsduRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PushChunkAsduRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PushChunkAsduResMultiError, or nil if none found.
func (m *PushChunkAsduRes) ValidateAll() error {
	return m.validate(true)
}

func (m *PushChunkAsduRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return PushChunkAsduResMultiError(errors)
	}

	return nil
}

// PushChunkAsduResMultiError is an error wrapping multiple validation errors
// returned by PushChunkAsduRes.ValidateAll() if the designated constraints
// aren't met.
type PushChunkAsduResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PushChunkAsduResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PushChunkAsduResMultiError) AllErrors() []error { return m }

// PushChunkAsduResValidationError is the validation error returned by
// PushChunkAsduRes.Validate if the designated constraints aren't met.
type PushChunkAsduResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PushChunkAsduResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PushChunkAsduResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PushChunkAsduResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PushChunkAsduResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PushChunkAsduResValidationError) ErrorName() string { return "PushChunkAsduResValidationError" }

// Error satisfies the builtin error interface
func (e PushChunkAsduResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPushChunkAsduRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PushChunkAsduResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PushChunkAsduResValidationError{}

// Validate checks the field values on MsgBody with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MsgBody) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MsgBody with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in MsgBodyMultiError, or nil if none found.
func (m *MsgBody) ValidateAll() error {
	return m.validate(true)
}

func (m *MsgBody) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Host

	// no validation rules for Port

	// no validation rules for Asdu

	// no validation rules for TypeId

	// no validation rules for DataType

	// no validation rules for Coa

	// no validation rules for BodyRaw

	// no validation rules for Time

	// no validation rules for MetaDataRaw

	if len(errors) > 0 {
		return MsgBodyMultiError(errors)
	}

	return nil
}

// MsgBodyMultiError is an error wrapping multiple validation errors returned
// by MsgBody.ValidateAll() if the designated constraints aren't met.
type MsgBodyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MsgBodyMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MsgBodyMultiError) AllErrors() []error { return m }

// MsgBodyValidationError is the validation error returned by MsgBody.Validate
// if the designated constraints aren't met.
type MsgBodyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MsgBodyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MsgBodyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MsgBodyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MsgBodyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MsgBodyValidationError) ErrorName() string { return "MsgBodyValidationError" }

// Error satisfies the builtin error interface
func (e MsgBodyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMsgBody.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MsgBodyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MsgBodyValidationError{}

// Validate checks the field values on SinglePointInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SinglePointInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SinglePointInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SinglePointInfoMultiError, or nil if none found.
func (m *SinglePointInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *SinglePointInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Ioa

	// no validation rules for Value

	// no validation rules for Qds

	// no validation rules for QdsDesc

	// no validation rules for Ov

	// no validation rules for Bl

	// no validation rules for Sb

	// no validation rules for Nt

	// no validation rules for Iv

	// no validation rules for Time

	if len(errors) > 0 {
		return SinglePointInfoMultiError(errors)
	}

	return nil
}

// SinglePointInfoMultiError is an error wrapping multiple validation errors
// returned by SinglePointInfo.ValidateAll() if the designated constraints
// aren't met.
type SinglePointInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SinglePointInfoMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SinglePointInfoMultiError) AllErrors() []error { return m }

// SinglePointInfoValidationError is the validation error returned by
// SinglePointInfo.Validate if the designated constraints aren't met.
type SinglePointInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SinglePointInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SinglePointInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SinglePointInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SinglePointInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SinglePointInfoValidationError) ErrorName() string { return "SinglePointInfoValidationError" }

// Error satisfies the builtin error interface
func (e SinglePointInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSinglePointInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SinglePointInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SinglePointInfoValidationError{}

// Validate checks the field values on DoublePointInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DoublePointInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DoublePointInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DoublePointInfoMultiError, or nil if none found.
func (m *DoublePointInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *DoublePointInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Ioa

	// no validation rules for Value

	// no validation rules for Qds

	// no validation rules for QdsDesc

	// no validation rules for Ov

	// no validation rules for Bl

	// no validation rules for Sb

	// no validation rules for Nt

	// no validation rules for Iv

	// no validation rules for Time

	if len(errors) > 0 {
		return DoublePointInfoMultiError(errors)
	}

	return nil
}

// DoublePointInfoMultiError is an error wrapping multiple validation errors
// returned by DoublePointInfo.ValidateAll() if the designated constraints
// aren't met.
type DoublePointInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DoublePointInfoMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DoublePointInfoMultiError) AllErrors() []error { return m }

// DoublePointInfoValidationError is the validation error returned by
// DoublePointInfo.Validate if the designated constraints aren't met.
type DoublePointInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DoublePointInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DoublePointInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DoublePointInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DoublePointInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DoublePointInfoValidationError) ErrorName() string { return "DoublePointInfoValidationError" }

// Error satisfies the builtin error interface
func (e DoublePointInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDoublePointInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DoublePointInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DoublePointInfoValidationError{}

// Validate checks the field values on MeasuredValueScaledInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MeasuredValueScaledInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MeasuredValueScaledInfo with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MeasuredValueScaledInfoMultiError, or nil if none found.
func (m *MeasuredValueScaledInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *MeasuredValueScaledInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Ioa

	// no validation rules for Value

	// no validation rules for Qds

	// no validation rules for QdsDesc

	// no validation rules for Ov

	// no validation rules for Bl

	// no validation rules for Sb

	// no validation rules for Nt

	// no validation rules for Iv

	// no validation rules for Time

	if len(errors) > 0 {
		return MeasuredValueScaledInfoMultiError(errors)
	}

	return nil
}

// MeasuredValueScaledInfoMultiError is an error wrapping multiple validation
// errors returned by MeasuredValueScaledInfo.ValidateAll() if the designated
// constraints aren't met.
type MeasuredValueScaledInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MeasuredValueScaledInfoMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MeasuredValueScaledInfoMultiError) AllErrors() []error { return m }

// MeasuredValueScaledInfoValidationError is the validation error returned by
// MeasuredValueScaledInfo.Validate if the designated constraints aren't met.
type MeasuredValueScaledInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MeasuredValueScaledInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MeasuredValueScaledInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MeasuredValueScaledInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MeasuredValueScaledInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MeasuredValueScaledInfoValidationError) ErrorName() string {
	return "MeasuredValueScaledInfoValidationError"
}

// Error satisfies the builtin error interface
func (e MeasuredValueScaledInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMeasuredValueScaledInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MeasuredValueScaledInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MeasuredValueScaledInfoValidationError{}

// Validate checks the field values on MeasuredValueNormalInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MeasuredValueNormalInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MeasuredValueNormalInfo with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MeasuredValueNormalInfoMultiError, or nil if none found.
func (m *MeasuredValueNormalInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *MeasuredValueNormalInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Ioa

	// no validation rules for Value

	// no validation rules for Nva

	// no validation rules for Qds

	// no validation rules for QdsDesc

	// no validation rules for Ov

	// no validation rules for Bl

	// no validation rules for Sb

	// no validation rules for Nt

	// no validation rules for Iv

	// no validation rules for Time

	if len(errors) > 0 {
		return MeasuredValueNormalInfoMultiError(errors)
	}

	return nil
}

// MeasuredValueNormalInfoMultiError is an error wrapping multiple validation
// errors returned by MeasuredValueNormalInfo.ValidateAll() if the designated
// constraints aren't met.
type MeasuredValueNormalInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MeasuredValueNormalInfoMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MeasuredValueNormalInfoMultiError) AllErrors() []error { return m }

// MeasuredValueNormalInfoValidationError is the validation error returned by
// MeasuredValueNormalInfo.Validate if the designated constraints aren't met.
type MeasuredValueNormalInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MeasuredValueNormalInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MeasuredValueNormalInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MeasuredValueNormalInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MeasuredValueNormalInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MeasuredValueNormalInfoValidationError) ErrorName() string {
	return "MeasuredValueNormalInfoValidationError"
}

// Error satisfies the builtin error interface
func (e MeasuredValueNormalInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMeasuredValueNormalInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MeasuredValueNormalInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MeasuredValueNormalInfoValidationError{}

// Validate checks the field values on StepPositionInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *StepPositionInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StepPositionInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// StepPositionInfoMultiError, or nil if none found.
func (m *StepPositionInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *StepPositionInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Ioa

	if all {
		switch v := interface{}(m.GetValue()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StepPositionInfoValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StepPositionInfoValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetValue()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StepPositionInfoValidationError{
				field:  "Value",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Qds

	// no validation rules for QdsDesc

	// no validation rules for Ov

	// no validation rules for Bl

	// no validation rules for Sb

	// no validation rules for Nt

	// no validation rules for Iv

	// no validation rules for Time

	if len(errors) > 0 {
		return StepPositionInfoMultiError(errors)
	}

	return nil
}

// StepPositionInfoMultiError is an error wrapping multiple validation errors
// returned by StepPositionInfo.ValidateAll() if the designated constraints
// aren't met.
type StepPositionInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StepPositionInfoMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StepPositionInfoMultiError) AllErrors() []error { return m }

// StepPositionInfoValidationError is the validation error returned by
// StepPositionInfo.Validate if the designated constraints aren't met.
type StepPositionInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StepPositionInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StepPositionInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StepPositionInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StepPositionInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StepPositionInfoValidationError) ErrorName() string { return "StepPositionInfoValidationError" }

// Error satisfies the builtin error interface
func (e StepPositionInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStepPositionInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StepPositionInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StepPositionInfoValidationError{}

// Validate checks the field values on StepPosition with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *StepPosition) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StepPosition with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in StepPositionMultiError, or
// nil if none found.
func (m *StepPosition) ValidateAll() error {
	return m.validate(true)
}

func (m *StepPosition) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Val

	// no validation rules for HasTransient

	if len(errors) > 0 {
		return StepPositionMultiError(errors)
	}

	return nil
}

// StepPositionMultiError is an error wrapping multiple validation errors
// returned by StepPosition.ValidateAll() if the designated constraints aren't met.
type StepPositionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StepPositionMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StepPositionMultiError) AllErrors() []error { return m }

// StepPositionValidationError is the validation error returned by
// StepPosition.Validate if the designated constraints aren't met.
type StepPositionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StepPositionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StepPositionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StepPositionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StepPositionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StepPositionValidationError) ErrorName() string { return "StepPositionValidationError" }

// Error satisfies the builtin error interface
func (e StepPositionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStepPosition.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StepPositionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StepPositionValidationError{}

// Validate checks the field values on BitString32Info with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *BitString32Info) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BitString32Info with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BitString32InfoMultiError, or nil if none found.
func (m *BitString32Info) ValidateAll() error {
	return m.validate(true)
}

func (m *BitString32Info) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Ioa

	// no validation rules for Value

	// no validation rules for Qds

	// no validation rules for QdsDesc

	// no validation rules for Ov

	// no validation rules for Bl

	// no validation rules for Sb

	// no validation rules for Nt

	// no validation rules for Iv

	// no validation rules for Time

	if len(errors) > 0 {
		return BitString32InfoMultiError(errors)
	}

	return nil
}

// BitString32InfoMultiError is an error wrapping multiple validation errors
// returned by BitString32Info.ValidateAll() if the designated constraints
// aren't met.
type BitString32InfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BitString32InfoMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BitString32InfoMultiError) AllErrors() []error { return m }

// BitString32InfoValidationError is the validation error returned by
// BitString32Info.Validate if the designated constraints aren't met.
type BitString32InfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BitString32InfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BitString32InfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BitString32InfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BitString32InfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BitString32InfoValidationError) ErrorName() string { return "BitString32InfoValidationError" }

// Error satisfies the builtin error interface
func (e BitString32InfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBitString32Info.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BitString32InfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BitString32InfoValidationError{}

// Validate checks the field values on MeasuredValueFloatInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MeasuredValueFloatInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MeasuredValueFloatInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MeasuredValueFloatInfoMultiError, or nil if none found.
func (m *MeasuredValueFloatInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *MeasuredValueFloatInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Ioa

	// no validation rules for Value

	// no validation rules for Qds

	// no validation rules for QdsDesc

	// no validation rules for Ov

	// no validation rules for Bl

	// no validation rules for Sb

	// no validation rules for Nt

	// no validation rules for Iv

	// no validation rules for Time

	if len(errors) > 0 {
		return MeasuredValueFloatInfoMultiError(errors)
	}

	return nil
}

// MeasuredValueFloatInfoMultiError is an error wrapping multiple validation
// errors returned by MeasuredValueFloatInfo.ValidateAll() if the designated
// constraints aren't met.
type MeasuredValueFloatInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MeasuredValueFloatInfoMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MeasuredValueFloatInfoMultiError) AllErrors() []error { return m }

// MeasuredValueFloatInfoValidationError is the validation error returned by
// MeasuredValueFloatInfo.Validate if the designated constraints aren't met.
type MeasuredValueFloatInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MeasuredValueFloatInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MeasuredValueFloatInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MeasuredValueFloatInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MeasuredValueFloatInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MeasuredValueFloatInfoValidationError) ErrorName() string {
	return "MeasuredValueFloatInfoValidationError"
}

// Error satisfies the builtin error interface
func (e MeasuredValueFloatInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMeasuredValueFloatInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MeasuredValueFloatInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MeasuredValueFloatInfoValidationError{}

// Validate checks the field values on BinaryCounterReadingInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BinaryCounterReadingInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BinaryCounterReadingInfo with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BinaryCounterReadingInfoMultiError, or nil if none found.
func (m *BinaryCounterReadingInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *BinaryCounterReadingInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Ioa

	if all {
		switch v := interface{}(m.GetValue()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BinaryCounterReadingInfoValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BinaryCounterReadingInfoValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetValue()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BinaryCounterReadingInfoValidationError{
				field:  "Value",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Time

	if len(errors) > 0 {
		return BinaryCounterReadingInfoMultiError(errors)
	}

	return nil
}

// BinaryCounterReadingInfoMultiError is an error wrapping multiple validation
// errors returned by BinaryCounterReadingInfo.ValidateAll() if the designated
// constraints aren't met.
type BinaryCounterReadingInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BinaryCounterReadingInfoMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BinaryCounterReadingInfoMultiError) AllErrors() []error { return m }

// BinaryCounterReadingInfoValidationError is the validation error returned by
// BinaryCounterReadingInfo.Validate if the designated constraints aren't met.
type BinaryCounterReadingInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BinaryCounterReadingInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BinaryCounterReadingInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BinaryCounterReadingInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BinaryCounterReadingInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BinaryCounterReadingInfoValidationError) ErrorName() string {
	return "BinaryCounterReadingInfoValidationError"
}

// Error satisfies the builtin error interface
func (e BinaryCounterReadingInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBinaryCounterReadingInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BinaryCounterReadingInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BinaryCounterReadingInfoValidationError{}

// Validate checks the field values on BinaryCounterReading with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BinaryCounterReading) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BinaryCounterReading with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BinaryCounterReadingMultiError, or nil if none found.
func (m *BinaryCounterReading) ValidateAll() error {
	return m.validate(true)
}

func (m *BinaryCounterReading) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CounterReading

	// no validation rules for SeqNumber

	// no validation rules for HasCarry

	// no validation rules for IsAdjusted

	// no validation rules for IsInvalid

	if len(errors) > 0 {
		return BinaryCounterReadingMultiError(errors)
	}

	return nil
}

// BinaryCounterReadingMultiError is an error wrapping multiple validation
// errors returned by BinaryCounterReading.ValidateAll() if the designated
// constraints aren't met.
type BinaryCounterReadingMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BinaryCounterReadingMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BinaryCounterReadingMultiError) AllErrors() []error { return m }

// BinaryCounterReadingValidationError is the validation error returned by
// BinaryCounterReading.Validate if the designated constraints aren't met.
type BinaryCounterReadingValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BinaryCounterReadingValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BinaryCounterReadingValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BinaryCounterReadingValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BinaryCounterReadingValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BinaryCounterReadingValidationError) ErrorName() string {
	return "BinaryCounterReadingValidationError"
}

// Error satisfies the builtin error interface
func (e BinaryCounterReadingValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBinaryCounterReading.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BinaryCounterReadingValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BinaryCounterReadingValidationError{}

// Validate checks the field values on EventOfProtectionEquipmentInfo with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *EventOfProtectionEquipmentInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EventOfProtectionEquipmentInfo with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// EventOfProtectionEquipmentInfoMultiError, or nil if none found.
func (m *EventOfProtectionEquipmentInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *EventOfProtectionEquipmentInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Ioa

	// no validation rules for Event

	// no validation rules for Qdp

	// no validation rules for QdpDesc

	// no validation rules for Ei

	// no validation rules for Bl

	// no validation rules for Sb

	// no validation rules for Nt

	// no validation rules for Iv

	// no validation rules for Msec

	// no validation rules for Time

	if len(errors) > 0 {
		return EventOfProtectionEquipmentInfoMultiError(errors)
	}

	return nil
}

// EventOfProtectionEquipmentInfoMultiError is an error wrapping multiple
// validation errors returned by EventOfProtectionEquipmentInfo.ValidateAll()
// if the designated constraints aren't met.
type EventOfProtectionEquipmentInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EventOfProtectionEquipmentInfoMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EventOfProtectionEquipmentInfoMultiError) AllErrors() []error { return m }

// EventOfProtectionEquipmentInfoValidationError is the validation error
// returned by EventOfProtectionEquipmentInfo.Validate if the designated
// constraints aren't met.
type EventOfProtectionEquipmentInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EventOfProtectionEquipmentInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EventOfProtectionEquipmentInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EventOfProtectionEquipmentInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EventOfProtectionEquipmentInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EventOfProtectionEquipmentInfoValidationError) ErrorName() string {
	return "EventOfProtectionEquipmentInfoValidationError"
}

// Error satisfies the builtin error interface
func (e EventOfProtectionEquipmentInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEventOfProtectionEquipmentInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EventOfProtectionEquipmentInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EventOfProtectionEquipmentInfoValidationError{}

// Validate checks the field values on
// PackedStartEventsOfProtectionEquipmentInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PackedStartEventsOfProtectionEquipmentInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// PackedStartEventsOfProtectionEquipmentInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// PackedStartEventsOfProtectionEquipmentInfoMultiError, or nil if none found.
func (m *PackedStartEventsOfProtectionEquipmentInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *PackedStartEventsOfProtectionEquipmentInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Ioa

	// no validation rules for Event

	// no validation rules for Qdp

	// no validation rules for QdpDesc

	// no validation rules for Ei

	// no validation rules for Bl

	// no validation rules for Sb

	// no validation rules for Nt

	// no validation rules for Iv

	// no validation rules for Msec

	// no validation rules for Time

	if len(errors) > 0 {
		return PackedStartEventsOfProtectionEquipmentInfoMultiError(errors)
	}

	return nil
}

// PackedStartEventsOfProtectionEquipmentInfoMultiError is an error wrapping
// multiple validation errors returned by
// PackedStartEventsOfProtectionEquipmentInfo.ValidateAll() if the designated
// constraints aren't met.
type PackedStartEventsOfProtectionEquipmentInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PackedStartEventsOfProtectionEquipmentInfoMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PackedStartEventsOfProtectionEquipmentInfoMultiError) AllErrors() []error { return m }

// PackedStartEventsOfProtectionEquipmentInfoValidationError is the validation
// error returned by PackedStartEventsOfProtectionEquipmentInfo.Validate if
// the designated constraints aren't met.
type PackedStartEventsOfProtectionEquipmentInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PackedStartEventsOfProtectionEquipmentInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PackedStartEventsOfProtectionEquipmentInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PackedStartEventsOfProtectionEquipmentInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PackedStartEventsOfProtectionEquipmentInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PackedStartEventsOfProtectionEquipmentInfoValidationError) ErrorName() string {
	return "PackedStartEventsOfProtectionEquipmentInfoValidationError"
}

// Error satisfies the builtin error interface
func (e PackedStartEventsOfProtectionEquipmentInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPackedStartEventsOfProtectionEquipmentInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PackedStartEventsOfProtectionEquipmentInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PackedStartEventsOfProtectionEquipmentInfoValidationError{}

// Validate checks the field values on PackedOutputCircuitInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PackedOutputCircuitInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PackedOutputCircuitInfo with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PackedOutputCircuitInfoMultiError, or nil if none found.
func (m *PackedOutputCircuitInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *PackedOutputCircuitInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Ioa

	// no validation rules for Oci

	// no validation rules for Gc

	// no validation rules for Cl1

	// no validation rules for Cl2

	// no validation rules for Cl3

	// no validation rules for Qdp

	// no validation rules for QdpDesc

	// no validation rules for Ei

	// no validation rules for Bl

	// no validation rules for Sb

	// no validation rules for Nt

	// no validation rules for Iv

	// no validation rules for Msec

	// no validation rules for Time

	if len(errors) > 0 {
		return PackedOutputCircuitInfoMultiError(errors)
	}

	return nil
}

// PackedOutputCircuitInfoMultiError is an error wrapping multiple validation
// errors returned by PackedOutputCircuitInfo.ValidateAll() if the designated
// constraints aren't met.
type PackedOutputCircuitInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PackedOutputCircuitInfoMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PackedOutputCircuitInfoMultiError) AllErrors() []error { return m }

// PackedOutputCircuitInfoValidationError is the validation error returned by
// PackedOutputCircuitInfo.Validate if the designated constraints aren't met.
type PackedOutputCircuitInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PackedOutputCircuitInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PackedOutputCircuitInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PackedOutputCircuitInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PackedOutputCircuitInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PackedOutputCircuitInfoValidationError) ErrorName() string {
	return "PackedOutputCircuitInfoValidationError"
}

// Error satisfies the builtin error interface
func (e PackedOutputCircuitInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPackedOutputCircuitInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PackedOutputCircuitInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PackedOutputCircuitInfoValidationError{}

// Validate checks the field values on PackedSinglePointWithSCDInfo with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PackedSinglePointWithSCDInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PackedSinglePointWithSCDInfo with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PackedSinglePointWithSCDInfoMultiError, or nil if none found.
func (m *PackedSinglePointWithSCDInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *PackedSinglePointWithSCDInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Ioa

	// no validation rules for Scd

	// no validation rules for Stn

	// no validation rules for Cdn

	// no validation rules for Qds

	// no validation rules for QdsDesc

	// no validation rules for Ov

	// no validation rules for Bl

	// no validation rules for Sb

	// no validation rules for Nt

	// no validation rules for Iv

	if len(errors) > 0 {
		return PackedSinglePointWithSCDInfoMultiError(errors)
	}

	return nil
}

// PackedSinglePointWithSCDInfoMultiError is an error wrapping multiple
// validation errors returned by PackedSinglePointWithSCDInfo.ValidateAll() if
// the designated constraints aren't met.
type PackedSinglePointWithSCDInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PackedSinglePointWithSCDInfoMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PackedSinglePointWithSCDInfoMultiError) AllErrors() []error { return m }

// PackedSinglePointWithSCDInfoValidationError is the validation error returned
// by PackedSinglePointWithSCDInfo.Validate if the designated constraints
// aren't met.
type PackedSinglePointWithSCDInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PackedSinglePointWithSCDInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PackedSinglePointWithSCDInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PackedSinglePointWithSCDInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PackedSinglePointWithSCDInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PackedSinglePointWithSCDInfoValidationError) ErrorName() string {
	return "PackedSinglePointWithSCDInfoValidationError"
}

// Error satisfies the builtin error interface
func (e PackedSinglePointWithSCDInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPackedSinglePointWithSCDInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PackedSinglePointWithSCDInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PackedSinglePointWithSCDInfoValidationError{}
